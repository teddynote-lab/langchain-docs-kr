---
title: Jina Search
---

이 가이드는 Jina [tool](/oss/integrations/tools/) 시작하기에 대한 간단한 개요를 제공합니다. 모든 Jina 기능 및 구성에 대한 자세한 문서는 [API reference](https://python.langchain.com/api_reference/community/tools/langchain_community.tools.jina_search.tool.JinaSearch.html)를 참조하세요.

## Overview

### Integration details

| Class | Package | Serializable | JS support |  Version |
| :--- | :--- | :---: | :---: | :---: |
| [JinaSearch](https://python.langchain.com/api_reference/community/tools/langchain_community.tools.jina_search.tool.JinaSearch.html) | [langchain-community](https://python.langchain.com/api_reference/community/) | ❌ | ❌ |  ![PyPI - Version](https://img.shields.io/pypi/v/langchain-community?style=flat-square&label=%20) |

### Tool features

| [Returns artifact](/oss/langchain/tools) | Native async | Return data | Pricing |
| :---: | :---: | :---: | :---: |
| ❌ | ❌ | URL, Snippet, Title, Page Content | 1M response tokens free |

## Setup

이 integration은 `langchain-community` 패키지에 포함되어 있으며 버전 `0.2.16`에 추가되었습니다:

```python
pip install --quiet -U "langchain-community>=0.2.16"
```

### Credentials

```python
import getpass
import os

if not os.environ.get("JINA_API_KEY"):
    os.environ["JINA_API_KEY"] = getpass.getpass("Jina API key:\n")
```

최고 수준의 observability를 위해 [LangSmith](https://smith.langchain.com/)를 설정하는 것도 도움이 됩니다(필수는 아님):

```python
os.environ["LANGSMITH_TRACING"] = "true"
# os.environ["LANGSMITH_API_KEY"] = getpass.getpass()
```

## Instantiation

- TODO: Fill in instantiation params

다음은 Jina tool의 인스턴스를 생성하는 방법을 보여줍니다:

```python
from langchain_community.tools import JinaSearch

tool = JinaSearch()
```

## Invocation

### [Invoke directly with args](/oss/langchain/tools)

```python
print(tool.invoke({"query": "what is langgraph"})[:1000])
```

```output
[{"title": "LangGraph", "link": "https://www.langchain.com/langgraph", "snippet": "<strong>LangGraph</strong> helps teams of all sizes, across all industries, from ambitious startups to established enterprises. \u201cLangChain is streets ahead with what they&#x27;ve put forward with <strong>LangGraph</strong>.", "content": "![Image 1](https://cdn.prod.website-files.com/65b8cd72835ceeacd4449a53/667b080e4b3ca12dc5d5d439_Langgraph%20UI-2.webp)\n\nControllable cognitive architecture for any task\n------------------------------------------------\n\nLangGraph's flexible API supports diverse control flows \u2013 single agent, multi-agent, hierarchical, sequential \u2013 and robustly handles realistic, complex scenarios.\n\nEnsure reliability with easy-to-add moderation and quality loops that prevent agents from veering off course.\n\n[See the docs](https://langchain-ai.github.io/langgraph/)\n\nDesigned for human-agent collaboration\n--------------------------------------\n\nWith built-in stat
```

### [Invoke with ToolCall](/oss/langchain/tools)

모델이 생성한 ToolCall로 tool을 호출할 수도 있으며, 이 경우 ToolMessage가 반환됩니다:

```python
# This is usually generated by a model, but we'll create a tool call directly for demo purposes.
model_generated_tool_call = {
    "args": {"query": "what is langgraph"},
    "id": "1",
    "name": tool.name,
    "type": "tool_call",
}
tool_msg = tool.invoke(model_generated_tool_call)
print(tool_msg.content[:1000])
```

```output
[{"title": "LangGraph Tutorial: What Is LangGraph and How to Use It?", "link": "https://www.datacamp.com/tutorial/langgraph-tutorial", "snippet": "<strong>LangGraph</strong> <strong>is</strong> a library within the LangChain ecosystem that provides a framework for defining, coordinating, and executing multiple LLM agents (or chains) in a structured and efficient manner.", "content": "Imagine you're building a complex, multi-agent large language model (LLM) application. It's exciting, but it comes with challenges: managing the state of various agents, coordinating their interactions, and handling errors effectively. This is where LangGraph can help.\n\nLangGraph is a library within the LangChain ecosystem designed to tackle these challenges head-on. LangGraph provides a framework for defining, coordinating, and executing multiple LLM agents (or chains) in a structured manner.\n\nIt simplifies the development process by enabling the creation of cyclical graphs, which are essential for de
```

## Chaining

먼저 [tool-calling model](/oss/langchain/tools/)에 tool을 바인딩한 다음 호출하여 chain에서 tool을 사용할 수 있습니다:

<ChatModelTabs customVarName="llm" />

```python
# | output: false
# | echo: false

# !pip install -qU langchain langchain-openai
from langchain.chat_models import init_chat_model

model = init_chat_model(model="gpt-4o", model_provider="openai")
```

```python
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnableConfig, chain

prompt = ChatPromptTemplate(
    [
        ("system", "You are a helpful assistant."),
        ("human", "{user_input}"),
        ("placeholder", "{messages}"),
    ]
)


model_with_tools = model.bind_tools([tool])
model_chain = prompt | model_with_tools


@chain
def tool_chain(user_input: str, config: RunnableConfig):
    input_ = {"user_input": user_input}
    ai_msg = model_chain.invoke(input_, config=config)
    tool_msgs = tool.batch(ai_msg.tool_calls, config=config)
    return model_chain.invoke({**input_, "messages": [ai_msg, *tool_msgs]}, config=config)


tool_chain.invoke("what's langgraph")
```

```output
AIMessage(content="LangGraph is a library designed for building stateful, multi-actor applications with language models (LLMs). It is particularly useful for creating agent and multi-agent workflows. Compared to other LLM frameworks, LangGraph offers unique benefits such as cycles, controllability, and persistence. Here are some key points:\n\n1. **Stateful and Multi-Actor Applications**: LangGraph allows for the definition of flows involving cycles, essential for most agentic architectures. This is a significant differentiation from Directed Acyclic Graph (DAG)-based solutions.\n\n2. **Controllability**: The framework offers fine-grained control over both the flow and state of applications, which is crucial for creating reliable agents.\n\n3. **Persistence**: Built-in persistence is available, enabling advanced features like human-in-the-loop workflows and memory.\n\n4. **Human-in-the-Loop**: LangGraph supports interrupting graph execution for human approval or editing of the agent's next planned action.\n\n5. **Streaming Support**: The library can stream outputs as they are produced by each node, including token streaming.\n\n6. **Integration with LangChain**: While it integrates seamlessly with LangChain and LangSmith, LangGraph can also be used independently.\n\n7. **Inspiration and Interface**: LangGraph is inspired by systems like Pregel and Apache Beam, with its public interface drawing inspiration from NetworkX.\n\nLangGraph is designed to handle more complex agent applications that require cycles and state management, making it an ideal choice for developers seeking to build sophisticated LLM-driven applications. For more detailed information, you can visit their [official documentation](https://langchain-ai.github.io/langgraph/).", additional_kwargs={'refusal': None}, response_metadata={'token_usage': {'completion_tokens': 338, 'prompt_tokens': 14774, 'total_tokens': 15112}, 'model_name': 'gpt-4o-2024-05-13', 'system_fingerprint': 'fp_157b3831f5', 'finish_reason': 'stop', 'logprobs': None}, id='run-420d16ed-535c-41c6-8814-2186b42be0f8-0', usage_metadata={'input_tokens': 14774, 'output_tokens': 338, 'total_tokens': 15112})
```

## API reference

모든 Jina 기능 및 구성에 대한 자세한 문서는 API reference를 참조하세요: [python.langchain.com/api_reference/community/tools/langchain_community.tools.jina_search.tool.JinaSearch.html](https://python.langchain.com/api_reference/community/tools/langchain_community.tools.jina_search.tool.JinaSearch.html)