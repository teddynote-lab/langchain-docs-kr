---
title: Oracle AI Vector Search Generate Embeddings
---

Oracle AI Vector Search는 키워드가 아닌 의미론을 기반으로 데이터를 쿼리할 수 있는 인공지능(AI) 워크로드를 위해 설계되었습니다.
Oracle AI Vector Search의 가장 큰 장점 중 하나는 비정형 데이터에 대한 의미론적 검색을 단일 시스템에서 비즈니스 데이터에 대한 관계형 검색과 결합할 수 있다는 것입니다.
이는 강력할 뿐만 아니라 전문화된 vector database를 추가할 필요가 없어 여러 시스템 간의 데이터 분산으로 인한 문제를 제거하므로 훨씬 더 효과적입니다.

또한 vector는 다음과 같은 Oracle Database의 가장 강력한 기능들을 모두 활용할 수 있습니다:

* [Partitioning Support](https://www.oracle.com/database/technologies/partitioning.html)
* [Real Application Clusters scalability](https://www.oracle.com/database/real-application-clusters/)
* [Exadata smart scans](https://www.oracle.com/database/technologies/exadata/software/smartscan/)
* [Shard processing across geographically distributed databases](https://www.oracle.com/database/distributed-database/)
* [Transactions](https://docs.oracle.com/en/database/oracle/oracle-database/23/cncpt/transactions.html)
* [Parallel SQL](https://docs.oracle.com/en/database/oracle/oracle-database/21/vldbg/parallel-exec-intro.html#GUID-D28717E4-0F77-44F5-BB4E-234C31D4E4BA)
* [Disaster recovery](https://www.oracle.com/database/data-guard/)
* [Security](https://www.oracle.com/security/database-security/)
* [Oracle Machine Learning](https://www.oracle.com/artificial-intelligence/database-machine-learning/)
* [Oracle Graph Database](https://www.oracle.com/database/integrated-graph-database/)
* [Oracle Spatial and Graph](https://www.oracle.com/database/spatial/)
* [Oracle Blockchain](https://docs.oracle.com/en/database/oracle/oracle-database/23/arpls/dbms_blockchain_table.html#GUID-B469E277-978E-4378-A8C1-26D3FF96C9A6)
* [JSON](https://docs.oracle.com/en/database/oracle/oracle-database/23/adjsn/json-in-oracle-database.html)

이 가이드는 Oracle AI Vector Search 내의 Embedding 기능을 사용하여 OracleEmbeddings를 통해 문서에 대한 embedding을 생성하는 방법을 보여줍니다.

Oracle Database를 처음 시작하는 경우 데이터베이스 환경 설정에 대한 훌륭한 소개를 제공하는 [무료 Oracle 23 AI](https://www.oracle.com/database/free/#resources)를 살펴보는 것을 고려해보세요. 데이터베이스 작업 시 기본적으로 system user를 사용하지 않는 것이 좋으며, 대신 보안 강화와 사용자 정의를 위해 자체 user를 생성할 수 있습니다. user 생성에 대한 자세한 단계는 Oracle에서 user를 설정하는 방법도 보여주는 [엔드 투 엔드 가이드](https://github.com/langchain-ai/langchain/blob/v0.3/cookbook/oracleai_demo.ipynb)를 참조하세요. 또한 user 권한을 이해하는 것은 데이터베이스 보안을 효과적으로 관리하는 데 중요합니다. 이 주제에 대한 자세한 내용은 user 계정 및 보안 관리에 대한 공식 [Oracle 가이드](https://docs.oracle.com/en/database/oracle/oracle-database/19/admqs/administering-user-accounts-and-security.html#GUID-36B21D72-1BBB-46C9-A0C9-F0D2A8591B8D)에서 확인할 수 있습니다.

### 사전 요구사항

LangChain과 Oracle AI Vector Search의 통합을 용이하게 하기 위해 Oracle Python Client driver가 설치되어 있는지 확인하세요.

```python
# pip install oracledb
```

### Oracle Database에 연결하기

다음 샘플 코드는 Oracle Database에 연결하는 방법을 보여줍니다. 기본적으로 python-oracledb는 Oracle Database에 직접 연결하는 'Thin' 모드로 실행됩니다. 이 모드는 Oracle Client 라이브러리가 필요하지 않습니다. 그러나 python-oracledb가 이를 사용할 때 일부 추가 기능을 사용할 수 있습니다. Oracle Client 라이브러리를 사용할 때 Python-oracledb는 'Thick' 모드에 있다고 합니다. 두 모드 모두 Python Database API v2.0 사양을 지원하는 포괄적인 기능을 제공합니다. 각 모드에서 지원되는 기능에 대해 설명하는 다음 [가이드](https://python-oracledb.readthedocs.io/en/latest/user_guide/appendix_a.html#featuresummary)를 참조하세요. thin-mode를 사용할 수 없는 경우 thick-mode로 전환할 수 있습니다.

```python
import sys

import oracledb

# Update the following variables with your Oracle database credentials and connection details
username = "<username>"
password = "<password>"
dsn = "<hostname>/<service_name>"

try:
    conn = oracledb.connect(user=username, password=password, dsn=dsn)
    print("Connection successful!")
except Exception as e:
    print("Connection failed!")
    sys.exit(1)
```

embedding 생성을 위해 사용자는 데이터베이스 내 embedding 생성과 OcigenAI, Hugging Face, OpenAI와 같은 타사 서비스를 포함한 여러 provider 옵션을 사용할 수 있습니다. 타사 provider를 선택하는 사용자는 필수 인증 정보를 포함하는 credential을 설정해야 합니다. 또는 사용자가 provider로 'database'를 선택하는 경우 embedding을 용이하게 하기 위해 Oracle Database에 ONNX model을 로드해야 합니다.

### ONNX Model 로드하기

Oracle은 다양한 embedding provider를 지원하여 사용자가 독점 데이터베이스 솔루션과 OCIGENAI 및 HuggingFace와 같은 타사 서비스 중에서 선택할 수 있습니다. 이 선택은 embedding 생성 및 관리 방법론을 결정합니다.

***중요*** : 사용자가 database 옵션을 선택하는 경우 Oracle Database에 ONNX model을 업로드해야 합니다. 반대로 embedding 생성을 위해 타사 provider를 선택하는 경우 Oracle Database에 ONNX model을 업로드할 필요가 없습니다.

Oracle 내에서 직접 ONNX model을 사용하는 것의 중요한 장점은 외부 당사자에게 데이터를 전송할 필요가 없어 향상된 보안과 성능을 제공한다는 것입니다. 또한 이 방법은 일반적으로 network 또는 REST API 호출과 관련된 지연 시간을 방지합니다.

다음은 Oracle Database에 ONNX model을 업로드하는 예제 코드입니다:

```python
from langchain_community.embeddings.oracleai import OracleEmbeddings

# Update the directory and file names for your ONNX model
# make sure that you have onnx file in the system
onnx_dir = "DEMO_DIR"
onnx_file = "tinybert.onnx"
model_name = "demo_model"

try:
    OracleEmbeddings.load_onnx_model(conn, onnx_dir, onnx_file, model_name)
    print("ONNX model loaded.")
except Exception as e:
    print("ONNX model loading failed!")
    sys.exit(1)
```

### Credential 생성하기

embedding 생성을 위해 타사 provider를 선택하는 경우 사용자는 provider의 endpoint에 안전하게 액세스하기 위한 credential을 설정해야 합니다.

***중요:*** embedding 생성을 위해 'database' provider를 선택하는 경우 credential이 필요하지 않습니다. 그러나 사용자가 타사 provider를 사용하기로 결정하는 경우 선택한 provider에 특정한 credential을 생성해야 합니다.

다음은 예시입니다:

```python
try:
    cursor = conn.cursor()
    cursor.execute(
        """
       declare
           jo json_object_t;
       begin
           -- HuggingFace
           dbms_vector_chain.drop_credential(credential_name  => 'HF_CRED');
           jo := json_object_t();
           jo.put('access_token', '<access_token>');
           dbms_vector_chain.create_credential(
               credential_name   =>  'HF_CRED',
               params            => json(jo.to_string));

           -- OCIGENAI
           dbms_vector_chain.drop_credential(credential_name  => 'OCI_CRED');
           jo := json_object_t();
           jo.put('user_ocid','<user_ocid>');
           jo.put('tenancy_ocid','<tenancy_ocid>');
           jo.put('compartment_ocid','<compartment_ocid>');
           jo.put('private_key','<private_key>');
           jo.put('fingerprint','<fingerprint>');
           dbms_vector_chain.create_credential(
               credential_name   => 'OCI_CRED',
               params            => json(jo.to_string));
       end;
       """
    )
    cursor.close()
    print("Credentials created.")
except Exception as ex:
    cursor.close()
    raise
```

### Embedding 생성하기

Oracle AI Vector Search는 로컬에서 호스팅되는 ONNX model 또는 타사 API를 활용하여 embedding을 생성하는 여러 방법을 제공합니다. 이러한 대안 구성에 대한 포괄적인 지침은 [Oracle AI Vector Search 가이드](https://docs.oracle.com/en/database/oracle/oracle-database/23/arpls/dbms_vector_chain1.html#GUID-C6439E94-4E86-4ECD-954E-4B73D53579DE)를 참조하세요.

***참고:*** 사용자는 ONNX model을 사용하는 'database' provider를 제외하고 타사 embedding 생성 provider를 사용하기 위해 proxy를 구성해야 할 수 있습니다.

```python
# proxy to be used when we instantiate summary and embedder object
proxy = "<proxy>"
```

다음 샘플 코드는 embedding을 생성하는 방법을 보여줍니다:

```python
from langchain_community.embeddings.oracleai import OracleEmbeddings
from langchain_core.documents import Document

"""
# using ocigenai
embedder_params = {
    "provider": "ocigenai",
    "credential_name": "OCI_CRED",
    "url": "https://inference.generativeai.us-chicago-1.oci.oraclecloud.com/20231130/actions/embedText",
    "model": "cohere.embed-english-light-v3.0",
}

# using huggingface
embedder_params = {
    "provider": "huggingface",
    "credential_name": "HF_CRED",
    "url": "https://api-inference.huggingface.co/pipeline/feature-extraction/",
    "model": "sentence-transformers/all-MiniLM-L6-v2",
    "wait_for_model": "true"
}
"""

# using ONNX model loaded to Oracle Database
embedder_params = {"provider": "database", "model": "demo_model"}

# If a proxy is not required for your environment, you can omit the 'proxy' parameter below
embedder = OracleEmbeddings(conn=conn, params=embedder_params, proxy=proxy)
embed = embedder.embed_query("Hello World!")

""" verify """
print(f"Embedding generated by OracleEmbeddings: {embed}")
```

### 엔드 투 엔드 데모

Oracle AI Vector Search의 도움으로 엔드 투 엔드 RAG pipeline을 구축하려면 전체 데모 가이드 [Oracle AI Vector Search 엔드 투 엔드 데모 가이드](https://github.com/langchain-ai/langchain/blob/v0.3/cookbook/oracleai_demo.ipynb)를 참조하세요.