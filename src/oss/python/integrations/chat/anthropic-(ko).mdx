---
title: ChatAnthropic
---

이 가이드는 Anthropic (Claude) [chat models](/oss/langchain/models) 시작하기에 대한 간단한 개요를 제공합니다.

Anthropic의 최신 모델, 비용, context window, 지원되는 입력 타입에 대한 정보는 [Claude](https://docs.claude.com/en/docs/about-claude/models/overview) 문서에서 확인할 수 있습니다.

<Tip>
    **API Reference**

    모든 기능과 구성 옵션에 대한 자세한 문서는 @[`ChatAnthropic`] API reference를 참조하세요.
</Tip>

<Info>
    **AWS Bedrock과 Google VertexAI**

    특정 Anthropic 모델은 AWS Bedrock과 Google VertexAI를 통해서도 액세스할 수 있습니다. 이러한 서비스를 통해 Anthropic 모델을 사용하려면 [`ChatBedrock`](/oss/integrations/chat/bedrock/) 및 [`ChatVertexAI`](/oss/integrations/chat/google_vertex_ai_palm/) integration을 참조하세요.
</Info>

## Overview

### Integration details

| Class | Package | <Tooltip tip="로컬 하드웨어에서 실행 가능" cta="자세히 알아보기" href="/oss/langchain/models#local-models">Local</Tooltip> | Serializable | JS/TS Support | Downloads | Latest Version |
| :--- | :--- | :---: | :---: |  :---: | :---: | :---: |
| @[`ChatAnthropic`] | @[`langchain-anthropic`] | ❌ | beta | ✅ [(npm)](https://js.langchain.com/docs/integrations/chat/anthropic) | <a href="https://pypi.org/project/langchain-anthropic/" target="_blank"><img src="https://static.pepy.tech/badge/langchain-anthropic/month" alt="Downloads per month" noZoom height="100" class="rounded" /></a> | <a href="https://pypi.org/project/langchain-anthropic/" target="_blank"><img src="https://img.shields.io/pypi/v/langchain-anthropic?style=flat-square&label=%20&color=orange" alt="PyPI - Latest version" noZoom height="100" class="rounded" /></a> |

### Model features

| [Tool calling](/oss/langchain/tools) | [Structured output](/oss/langchain/structured-output) | JSON mode | [Image input](/oss/langchain/messages#multimodal) | Audio input | Video input | [Token-level streaming](/oss/langchain/streaming/) | Native async | [Token usage](/oss/langchain/models#token-usage) | [Logprobs](/oss/langchain/models#log-probabilities) |
| :---: | :---: | :---: | :---: |  :---: | :---: | :---: | :---: | :---: | :---: |
| ✅ | ✅ | ❌ | ✅ | ❌ | ❌ | ✅ | ✅ | ✅ | ❌ |

## Setup

Anthropic (Claude) 모델에 액세스하려면 `langchain-anthropic` integration package를 설치하고 [Claude](https://docs.claude.com/en/docs/get-started#prerequisites) API key를 획득해야 합니다.

### Installation

<CodeGroup>
    ```bash pip
    pip install -U langchain-anthropic
    ```
    ```bash uv
    uv add langchain-anthropic
    ```
</CodeGroup>

### Credentials

[console.anthropic.com/](https://console.anthropic.com/)으로 이동하여 Anthropic에 가입하고 API key를 생성하세요. 완료되면 `ANTHROPIC_API_KEY` environment variable을 설정하세요:

```python
import getpass
import os

if "ANTHROPIC_API_KEY" not in os.environ:
    os.environ["ANTHROPIC_API_KEY"] = getpass.getpass("Enter your Anthropic API key: ")
```

모델 호출의 자동 추적을 활성화하려면 [LangSmith](https://docs.smith.langchain.com/) API key를 설정하세요:

```python
os.environ["LANGSMITH_API_KEY"] = getpass.getpass("Enter your LangSmith API key: ")
os.environ["LANGSMITH_TRACING"] = "true"
```

## Instantiation

이제 model object를 인스턴스화하고 chat completion을 생성할 수 있습니다:

```python
from langchain_anthropic import ChatAnthropic

model = ChatAnthropic(
    model="claude-3-5-haiku-latest",
    temperature=0,
    max_tokens=1024,
    timeout=None,
    max_retries=2,
    # other params...
)
```

## Invocation

```python
messages = [
    (
        "system",
        "You are a helpful assistant that translates English to French. Translate the user sentence.",
    ),
    ("human", "I love programming."),
]
ai_msg = model.invoke(messages)
ai_msg
```

```output
AIMessage(content="J'adore la programmation.", response_metadata={'id': 'msg_018Nnu76krRPq8HvgKLW4F8T', 'model': 'claude-3-5-sonnet-20240620', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'input_tokens': 29, 'output_tokens': 11}}, id='run-57e9295f-db8a-48dc-9619-babd2bedd891-0', usage_metadata={'input_tokens': 29, 'output_tokens': 11, 'total_tokens': 40})
```

```python
print(ai_msg.text)
```

```output
J'adore la programmation.
```

## Content blocks

tool, [extended thinking](#extended-thinking) 및 기타 기능을 사용할 때, 단일 Anthropic @[`AIMessage`]의 content는 단일 문자열이거나 content block 목록일 수 있습니다. 예를 들어, Anthropic 모델이 tool을 호출할 때, tool invocation은 message content의 일부입니다(표준화된 `AIMessage.tool_calls`에도 노출됨):

```python
from langchain_anthropic import ChatAnthropic
from typing_extensions import Annotated

model = ChatAnthropic(model="claude-3-5-haiku-latest")


def get_weather(
    location: Annotated[str, ..., "Location as city and state."]
) -> str:
    """Get the weather at a location."""
    return "It's sunny."


model_with_tools = model.bind_tools([get_weather])
response = model_with_tools.invoke("Which city is hotter today: LA or NY?")
response.content
```

```output
[{'text': "I'll help you compare the temperatures of Los Angeles and New York by checking their current weather. I'll retrieve the weather for both cities.",
  'type': 'text'},
 {'id': 'toolu_01CkMaXrgmsNjTso7so94RJq',
  'input': {'location': 'Los Angeles, CA'},
  'name': 'get_weather',
  'type': 'tool_use'},
 {'id': 'toolu_01SKaTBk9wHjsBTw5mrPVSQf',
  'input': {'location': 'New York, NY'},
  'name': 'get_weather',
  'type': 'tool_use'}]
```

`content_blocks`를 사용하면 provider 간에 일관된 표준 형식으로 content가 렌더링됩니다:

```python
response.content_blocks
```

```output
[{'type': 'text',
  'text': "I'll help you compare the temperatures of Los Angeles and New York by checking their current weather. I'll retrieve the weather for both cities."},
 {'type': 'tool_call',
  'name': 'get_weather',
  'args': {'location': 'Los Angeles, CA'},
  'id': 'toolu_01CkMaXrgmsNjTso7so94RJq'},
 {'type': 'tool_call',
  'name': 'get_weather',
  'args': {'location': 'New York, NY'},
  'id': 'toolu_01SKaTBk9wHjsBTw5mrPVSQf'}]
```

`.tool_calls` attribute를 사용하여 표준 형식으로 tool call에 특별히 액세스할 수도 있습니다:

```python
ai_msg.tool_calls
```

```output
[{'name': 'GetWeather',
  'args': {'location': 'Los Angeles, CA'},
  'id': 'toolu_01Ddzj5PkuZkrjF4tafzu54A'},
 {'name': 'GetWeather',
  'args': {'location': 'New York, NY'},
  'id': 'toolu_012kz4qHZQqD4qg8sFPeKqpP'}]
```

## Multimodal

Claude는 Anthropic의 native format([vision](https://docs.claude.com/en/docs/build-with-claude/vision#base64-encoded-image-example) 및 [PDF support](https://docs.claude.com/en/docs/build-with-claude/pdf-support) 문서 참조)과 LangChain의 [표준 형식](/oss/langchain/messages#multimodal) 모두에서 image 및 PDF 입력을 content block으로 지원합니다.

### Files API

Claude는 관리되는 [Files API](https://docs.claude.com/en/docs/build-with-claude/files)를 통한 파일 상호작용도 지원합니다. 아래 예제를 참조하세요.

Files API는 Claude의 내장 code-execution tool과 함께 사용할 container에 파일을 업로드하는 데에도 사용할 수 있습니다. 자세한 내용은 아래 [code execution](#code-execution) 섹션을 참조하세요.

<Accordion title="Images">

```python
# Upload image

import anthropic

client = anthropic.Anthropic()
file = client.beta.files.upload(
    # Supports image/jpeg, image/png, image/gif, image/webp
    file=("image.png", open("/path/to/image.png", "rb"), "image/png"),
)
image_file_id = file.id


# Run inference
from langchain_anthropic import ChatAnthropic

model = ChatAnthropic(
    model="claude-sonnet-4-20250514",
    betas=["files-api-2025-04-14"],
)

input_message = {
    "role": "user",
    "content": [
        {
            "type": "text",
            "text": "Describe this image.",
        },
        {
            "type": "image",
            "file_id": image_file_id,
        },
    ],
}
model.invoke([input_message])
```

</Accordion>

<Accordion title="PDFs">

```python
# Upload document

import anthropic

client = anthropic.Anthropic()
file = client.beta.files.upload(
    file=("document.pdf", open("/path/to/document.pdf", "rb"), "application/pdf"),
)
pdf_file_id = file.id


# Run inference
from langchain_anthropic import ChatAnthropic

model = ChatAnthropic(
    model="claude-sonnet-4-20250514",
    betas=["files-api-2025-04-14"],
)

input_message = {
    "role": "user",
    "content": [
        {"type": "text", "text": "Describe this document."},
        {"type": "file", "file_id": pdf_file_id}
    ],
}
model.invoke([input_message])
```

</Accordion>

## Extended thinking

일부 Claude 모델은 [extended thinking](https://docs.claude.com/en/docs/build-with-claude/extended-thinking) 기능을 지원하며, 최종 답변에 도달한 단계별 추론 과정을 출력합니다.

적용 가능한 모델은 Anthropic 가이드 [여기](https://docs.claude.com/en/docs/build-with-claude/extended-thinking)를 참조하세요.

extended thinking을 사용하려면 @[`ChatAnthropic`]을 초기화할 때 `thinking` parameter를 지정하세요. invocation 중에 `kwarg`로 전달할 수도 있습니다.

이 기능을 사용하려면 token budget을 지정해야 합니다. 아래 사용 예제를 참조하세요:

```python
import json

from langchain_anthropic import ChatAnthropic

model = ChatAnthropic(
    model="claude-sonnet-4-5",
    max_tokens=5000,
    thinking={"type": "enabled", "budget_tokens": 2000},
)

response = model.invoke("What is the cube root of 50.653?")
print(json.dumps(response.content_blocks, indent=2))
```

```output
[
  {
    "type": "reasoning",
    "reasoning": "To find the cube root of 50.653, I need to find the value of $x$ such that $x^3 = 50.653$.\n\nI can try to estimate this first. \n$3^3 = 27$\n$4^3 = 64$\n\nSo the cube root of 50.653 will be somewhere between 3 and 4, but closer to 4.\n\nLet me try to compute this more precisely. I can use the cube root function:\n\ncube root of 50.653 = 50.653^(1/3)\n\nLet me calculate this:\n50.653^(1/3) \u2248 3.6998\n\nLet me verify:\n3.6998^3 \u2248 50.6533\n\nThat's very close to 50.653, so I'm confident that the cube root of 50.653 is approximately 3.6998.\n\nActually, let me compute this more precisely:\n50.653^(1/3) \u2248 3.69981\n\nLet me verify once more:\n3.69981^3 \u2248 50.652998\n\nThat's extremely close to 50.653, so I'll say that the cube root of 50.653 is approximately 3.69981.",
    "extras": {"signature": "ErUBCkYIBxgCIkB0UjV..."}
  },
  {
    "text": "The cube root of 50.653 is approximately 3.6998.\n\nTo verify: 3.6998\u00b3 = 50.6530, which is very close to our original number.",
    "type": "text"
  }
]
```

## Prompt caching

Anthropic은 message, tool definition, tool result, image 및 document를 포함한 [prompt의 요소](https://docs.claude.com/en/docs/build-with-claude/prompt-caching#what-can-be-cached)의 [caching](https://docs.claude.com/en/docs/build-with-claude/prompt-caching)을 지원합니다. 이를 통해 대용량 문서, instruction, [few-shot document](/langsmith/create-few-shot-evaluators) 및 기타 데이터를 재사용하여 지연 시간과 비용을 줄일 수 있습니다.

prompt의 요소에 caching을 활성화하려면 `cache_control` key를 사용하여 관련 content block을 표시하세요. 아래 예제를 참조하세요:

### Messages

```python
import requests
from langchain_anthropic import ChatAnthropic

model = ChatAnthropic(model="claude-3-7-sonnet-20250219")

# Pull LangChain readme
get_response = requests.get(
    "https://raw.githubusercontent.com/langchain-ai/langchain/master/README.md"
)
readme = get_response.text

messages = [
    {
        "role": "system",
        "content": [
            {
                "type": "text",
                "text": "You are a technology expert.",
            },
            {
                "type": "text",
                "text": f"{readme}",
                "cache_control": {"type": "ephemeral"},  # [!code highlight]
            },
        ],
    },
    {
        "role": "user",
        "content": "What's LangChain, according to its README?",
    },
]

response_1 = model.invoke(messages)
response_2 = model.invoke(messages)

usage_1 = response_1.usage_metadata["input_token_details"]
usage_2 = response_2.usage_metadata["input_token_details"]

print(f"First invocation:\n{usage_1}")
print(f"\nSecond:\n{usage_2}")
```

```output
First invocation:
{'cache_read': 0, 'cache_creation': 1458}

Second:
{'cache_read': 1458, 'cache_creation': 0}
```

<Tip>
**Extended caching**

    cache lifetime은 기본적으로 5분입니다. 이것이 너무 짧으면 `"extended-cache-ttl-2025-04-11"` beta header를 활성화하여 1시간 caching을 적용할 수 있습니다:

    ```python
    model = ChatAnthropic(
        model="claude-3-7-sonnet-20250219",
        betas=["extended-cache-ttl-2025-04-11"],  # [!code highlight]
    )
    ```
    그리고 `"cache_control": {"type": "ephemeral", "ttl": "1h"}`를 지정하세요.

    cached token count의 세부 정보는 response의 `usage_metadata`의 `InputTokenDetails`에 포함됩니다:

    ```python
    response = model.invoke(messages)
    response.usage_metadata
    ```
    ```
    {
        "input_tokens": 1500,
        "output_tokens": 200,
        "total_tokens": 1700,
        "input_token_details": {
            "cache_read": 0,
            "cache_creation": 1000,
            "ephemeral_1h_input_tokens": 750,
            "ephemeral_5m_input_tokens": 250,
        }
    }
    ```

</Tip>

### Tools

```python
from langchain_anthropic import convert_to_anthropic_tool
from langchain.tools import tool

# For demonstration purposes, we artificially expand the
# tool description.
description = (
    f"Get the weather at a location. By the way, check out this readme: {readme}"
)


@tool(description=description)
def get_weather(location: str) -> str:
    return "It's sunny."


# Enable caching on the tool
weather_tool = convert_to_anthropic_tool(get_weather)  # [!code highlight]
weather_tool["cache_control"] = {"type": "ephemeral"}  # [!code highlight]

model = ChatAnthropic(model="claude-3-7-sonnet-20250219")
model_with_tools = model.bind_tools([weather_tool])
query = "What's the weather in San Francisco?"

response_1 = model_with_tools.invoke(query)
response_2 = model_with_tools.invoke(query)

usage_1 = response_1.usage_metadata["input_token_details"]
usage_2 = response_2.usage_metadata["input_token_details"]

print(f"First invocation:\n{usage_1}")
print(f"\nSecond:\n{usage_2}")
```

```output
First invocation:
{'cache_read': 0, 'cache_creation': 1809}

Second:
{'cache_read': 1809, 'cache_creation': 0}
```

### Incremental caching in conversational applications

Prompt caching은 [multi-turn conversation](https://docs.claude.com/en/docs/build-with-claude/prompt-caching#continuing-a-multi-turn-conversation)에서 중복 처리 없이 이전 message의 context를 유지하는 데 사용할 수 있습니다.

최종 message를 `cache_control`로 표시하여 incremental caching을 활성화할 수 있습니다. Claude는 후속 message에 대해 가장 긴 이전 캐시된 prefix를 자동으로 사용합니다.

아래에서는 이 기능을 통합한 간단한 chatbot을 구현합니다. LangChain [chatbot tutorial](/oss/langchain/quickstart)을 따르지만, 각 user message의 마지막 content block을 `cache_control`로 자동으로 표시하는 custom [reducer](/oss/langgraph/graph-api#reducers)를 추가합니다. 아래를 참조하세요:

```python
import requests
from langchain_anthropic import ChatAnthropic
from langgraph.checkpoint.memory import MemorySaver
from langgraph.graph import START, StateGraph, add_messages
from typing_extensions import Annotated, TypedDict

model = ChatAnthropic(model="claude-3-7-sonnet-20250219")

# Pull LangChain readme
get_response = requests.get(
    "https://raw.githubusercontent.com/langchain-ai/langchain/master/README.md"
)
readme = get_response.text


def messages_reducer(left: list, right: list) -> list:
    # Update last user message
    for i in range(len(right) - 1, -1, -1):
        if right[i].type == "human":
            right[i].content[-1]["cache_control"] = {"type": "ephemeral"}
            break

    return add_messages(left, right)


class State(TypedDict):
    messages: Annotated[list, messages_reducer]


workflow = StateGraph(state_schema=State)


# Define the function that calls the model
def call_model(state: State):
    response = model.invoke(state["messages"])
    return {"messages": [response]}


# Define the (single) node in the graph
workflow.add_edge(START, "model")
workflow.add_node("model", call_model)

# Add memory
memory = MemorySaver()
app = workflow.compile(checkpointer=memory)
```

```python
from langchain.messages import HumanMessage

config = {"configurable": {"thread_id": "abc123"}}

query = "Hi! I'm Bob."

input_message = HumanMessage([{"type": "text", "text": query}])
output = app.invoke({"messages": [input_message]}, config)
output["messages"][-1].pretty_print()
print(f"\n{output['messages'][-1].usage_metadata['input_token_details']}")
```

```output
================================== Ai Message ==================================

Hello, Bob! It's nice to meet you. How are you doing today? Is there something I can help you with?

{'cache_read': 0, 'cache_creation': 0}
```

```python
query = f"Check out this readme: {readme}"

input_message = HumanMessage([{"type": "text", "text": query}])
output = app.invoke({"messages": [input_message]}, config)
output["messages"][-1].pretty_print()
print(f"\n{output['messages'][-1].usage_metadata['input_token_details']}")
```

```output
================================== Ai Message ==================================

I can see you've shared the README from the LangChain GitHub repository. This is the documentation for LangChain, which is a popular framework for building applications powered by Large Language Models (LLMs). Here's a summary of what the README contains:

LangChain is:
- A framework for developing LLM-powered applications
- Helps chain together components and integrations to simplify AI application development
- Provides a standard interface for models, embeddings, vector stores, etc.

Key features/benefits:
- Real-time data augmentation (connect LLMs to diverse data sources)
- Model interoperability (swap models easily as needed)
- Large ecosystem of integrations

The LangChain ecosystem includes:
- LangSmith - For evaluations and observability
- LangGraph - For building complex agents with customizable architecture
- LangSmith - For deployment and scaling of agents

The README also mentions installation instructions (`pip install -U langchain`) and links to various resources including tutorials, how-to guides, conceptual guides, and API references.

Is there anything specific about LangChain you'd like to know more about, Bob?

{'cache_read': 0, 'cache_creation': 1498}
```

```python
query = "What was my name again?"

input_message = HumanMessage([{"type": "text", "text": query}])
output = app.invoke({"messages": [input_message]}, config)
output["messages"][-1].pretty_print()
print(f"\n{output['messages'][-1].usage_metadata['input_token_details']}")
```

```output
================================== Ai Message ==================================

Your name is Bob. You introduced yourself at the beginning of our conversation.

{'cache_read': 1498, 'cache_creation': 269}
```

[LangSmith trace](https://smith.langchain.com/public/4d0584d8-5f9e-4b91-8704-93ba2ccf416a/r)에서 "raw output"을 토글하면 `cache_control` key를 포함하여 chat model에 전송되는 정확한 message가 표시됩니다.

## Token-efficient tool use

Anthropic은 (beta) [token-efficient tool use](https://docs.claude.com/en/docs/agents-and-tools/tool-use/token-efficient-tool-use) 기능을 지원합니다. 이를 사용하려면 model을 인스턴스화할 때 관련 beta-header를 지정하세요.

```python
from langchain_anthropic import ChatAnthropic
from langchain.tools import tool

model = ChatAnthropic(
    model="claude-3-7-sonnet-20250219",
    betas=["token-efficient-tools-2025-02-19"],  # [!code highlight]
)


@tool
def get_weather(location: str) -> str:
    """Get the weather at a location."""
    return "It's sunny."


model_with_tools = model.bind_tools([get_weather])
response = model_with_tools.invoke("What's the weather in San Francisco?")
print(response.tool_calls)
print(f"\nTotal tokens: {response.usage_metadata['total_tokens']}")
```

```output
[{'name': 'get_weather', 'args': {'location': 'San Francisco'}, 'id': 'toolu_01EoeE1qYaePcmNbUvMsWtmA', 'type': 'tool_call'}]

Total tokens: 408
```

## Citations

Anthropic은 Claude가 사용자가 제공한 source document를 기반으로 답변에 context를 첨부할 수 있는 [citations](https://docs.claude.com/en/docs/build-with-claude/citations) 기능을 지원합니다. `"citations": {"enabled": True}`가 포함된 [document](https://docs.claude.com/en/docs/build-with-claude/citations#document-types) 또는 `search result` content block이 query에 포함되면 Claude는 response에서 citation을 생성할 수 있습니다.

### Simple example

이 예제에서는 [plain text document](https://docs.claude.com/en/docs/build-with-claude/citations#plain-text-documents)를 전달합니다. 백그라운드에서 Claude는 입력 텍스트를 문장으로 [자동으로 chunk](https://docs.claude.com/en/docs/build-with-claude/citations#plain-text-documents)하며, 이는 citation을 생성할 때 사용됩니다.

```python
from langchain_anthropic import ChatAnthropic

model = ChatAnthropic(model="claude-3-5-haiku-latest")

messages = [
    {
        "role": "user",
        "content": [
            {
                "type": "document",
                "source": {
                    "type": "text",
                    "media_type": "text/plain",
                    "data": "The grass is green. The sky is blue.",
                },
                "title": "My Document",
                "context": "This is a trustworthy document.",
                "citations": {"enabled": True},
            },
            {"type": "text", "text": "What color is the grass and sky?"},
        ],
    }
]
response = model.invoke(messages)
response.content
```

```output
[{'text': 'Based on the document, ', 'type': 'text'},
 {'text': 'the grass is green',
  'type': 'text',
  'citations': [{'type': 'char_location',
    'cited_text': 'The grass is green. ',
    'document_index': 0,
    'document_title': 'My Document',
    'start_char_index': 0,
    'end_char_index': 20}]},
 {'text': ', and ', 'type': 'text'},
 {'text': 'the sky is blue',
  'type': 'text',
  'citations': [{'type': 'char_location',
    'cited_text': 'The sky is blue.',
    'document_index': 0,
    'document_title': 'My Document',
    'start_char_index': 20,
    'end_char_index': 36}]},
 {'text': '.', 'type': 'text'}]
```

### In tool results (agentic RAG)

<Info>
    **`langchain-anthropic>=0.3.17` 필요**
</Info>

Claude는 knowledge base 또는 기타 custom source에 대한 query의 인용 가능한 결과를 나타내는 [search_result](https://docs.claude.com/en/docs/build-with-claude/search-results) content block을 지원합니다. 이러한 content block은 claude에 top-line(위 예제와 같이)과 tool result 내에서 모두 전달될 수 있습니다. 이를 통해 Claude는 tool call의 결과를 사용하여 response의 요소를 인용할 수 있습니다.

tool call에 대한 응답으로 search result를 전달하려면 Anthropic의 native format으로 `search_result` content block 목록을 반환하는 tool을 정의하세요. 예를 들어:

```python
def retrieval_tool(query: str) -> list[dict]:
    """Access my knowledge base."""

    # Run a search (e.g., with a LangChain vector store)
    results = vector_store.similarity_search(query=query, k=2)

    # Package results into search_result blocks
    return [
        {
            "type": "search_result",
            # Customize fields as desired, using document metadata or otherwise
            "title": "My Document Title",
            "source": "Source description or provenance",
            "citations": {"enabled": True},
            "content": [{"type": "text", "text": doc.page_content}],
        }
        for doc in results
    ]
```

<Accordion title="LangGraph를 사용한 end to end 예제">

여기서는 샘플 문서로 LangChain [vector store](/oss/integrations/vectorstores/)를 채우고 해당 문서를 query하는 tool을 Claude에 장착하는 end-to-end 예제를 보여줍니다.
여기서 tool은 search query와 `category` string literal을 받지만, 유효한 모든 tool signature를 사용할 수 있습니다.

```python
from typing import Literal

from langchain.chat_models import init_chat_model
from langchain.embeddings import init_embeddings
from langchain_core.documents import Document
from langchain_core.vectorstores import InMemoryVectorStore
from langgraph.checkpoint.memory import InMemorySaver
from langchain.agents import create_agent


# Set up vector store
embeddings = init_embeddings("openai:text-embedding-3-small")
vector_store = InMemoryVectorStore(embeddings)

document_1 = Document(
    id="1",
    page_content=(
        "To request vacation days, submit a leave request form through the "
        "HR portal. Approval will be sent by email."
    ),
    metadata={
        "category": "HR Policy",
        "doc_title": "Leave Policy",
        "provenance": "Leave Policy - page 1",
    },
)
document_2 = Document(
    id="2",
    page_content="Managers will review vacation requests within 3 business days.",
    metadata={
        "category": "HR Policy",
        "doc_title": "Leave Policy",
        "provenance": "Leave Policy - page 2",
    },
)
document_3 = Document(
    id="3",
    page_content=(
        "Employees with over 6 months tenure are eligible for 20 paid vacation days "
        "per year."
    ),
    metadata={
        "category": "Benefits Policy",
        "doc_title": "Benefits Guide 2025",
        "provenance": "Benefits Policy - page 1",
    },
)

documents = [document_1, document_2, document_3]
vector_store.add_documents(documents=documents)


# Define tool
async def retrieval_tool(
    query: str, category: Literal["HR Policy", "Benefits Policy"]
) -> list[dict]:
    """Access my knowledge base."""

    def _filter_function(doc: Document) -> bool:
        return doc.metadata.get("category") == category

    results = vector_store.similarity_search(
        query=query, k=2, filter=_filter_function
    )

    return [
        {
            "type": "search_result",
            "title": doc.metadata["doc_title"],
            "source": doc.metadata["provenance"],
            "citations": {"enabled": True},
            "content": [{"type": "text", "text": doc.page_content}],
        }
        for doc in results
    ]



# Create agent
model = init_chat_model("anthropic:claude-3-5-haiku-latest")

checkpointer = InMemorySaver()
agent = create_agent(model, [retrieval_tool], checkpointer=checkpointer)


# Invoke on a query
config = {"configurable": {"thread_id": "session_1"}}

input_message = {
    "role": "user",
    "content": "How do I request vacation days?",
}
async for step in agent.astream(
    {"messages": [input_message]},
    config,
    stream_mode="values",
):
    step["messages"][-1].pretty_print()
```

</Accordion>

### Using with text splitters

Anthropic은 [custom document](https://docs.claude.com/en/docs/build-with-claude/citations#custom-content-documents) type을 사용하여 자체 split을 지정할 수도 있습니다. LangChain [text splitter](/oss/integrations/splitters/)를 사용하여 이 목적을 위한 의미 있는 split을 생성할 수 있습니다. 아래 예제를 참조하세요. 여기서는 LangChain README(markdown 문서)를 split하고 context로 Claude에 전달합니다:

```python
import requests
from langchain_anthropic import ChatAnthropic
from langchain_text_splitters import MarkdownTextSplitter


def format_to_anthropic_documents(documents: list[str]):
    return {
        "type": "document",
        "source": {
            "type": "content",
            "content": [{"type": "text", "text": document} for document in documents],
        },
        "citations": {"enabled": True},
    }


# Pull readme
get_response = requests.get(
    "https://raw.githubusercontent.com/langchain-ai/langchain/master/README.md"
)
readme = get_response.text

# Split into chunks
splitter = MarkdownTextSplitter(
    chunk_overlap=0,
    chunk_size=50,
)
documents = splitter.split_text(readme)

# Construct message
message = {
    "role": "user",
    "content": [
        format_to_anthropic_documents(documents),
        {"type": "text", "text": "Give me a link to LangChain's tutorials."},
    ],
}

# Query model
model = ChatAnthropic(model="claude-3-5-haiku-latest")
response = model.invoke([message])
```

## Context management

Anthropic은 모델의 context window를 자동으로 관리하는(예: tool result 지우기) context editing 기능을 지원합니다.

자세한 내용과 구성 옵션은 [Anthropic documentation](https://docs.claude.com/en/docs/build-with-claude/context-editing)을 참조하세요.

<Info>
    **Context management는 `langchain-anthropic>=0.3.21`부터 지원됩니다**
</Info>

```python
from langchain_anthropic import ChatAnthropic

model = ChatAnthropic(
    model="claude-sonnet-4-5",
    betas=["context-management-2025-06-27"],
    context_management={"edits": [{"type": "clear_tool_uses_20250919"}]},
)
model_with_tools = model.bind_tools([{"type": "web_search_20250305", "name": "web_search"}])
response = model_with_tools.invoke("Search for recent developments in AI")
```

## Built-in tools

Anthropic은 다양한 [built-in tool](https://docs.claude.com/en/docs/agents-and-tools/tool-use/text-editor-tool)을 지원하며, [일반적인 방법](/oss/langchain/tools/)으로 model에 bind할 수 있습니다. Claude는 tool에 대한 내부 schema를 준수하는 tool call을 생성합니다:

### Web search

Claude는 [web search tool](https://docs.claude.com/en/docs/agents-and-tools/tool-use/web-search-tool)을 사용하여 검색을 실행하고 citation으로 response를 근거할 수 있습니다.

<Info>
    **Web search tool은 `langchain-anthropic>=0.3.13`부터 지원됩니다**
</Info>

```python
from langchain_anthropic import ChatAnthropic

model = ChatAnthropic(model="claude-sonnet-4-5")

tool = {"type": "web_search_20250305", "name": "web_search", "max_uses": 3}
model_with_tools = model.bind_tools([tool])

response = model_with_tools.invoke("How do I update a web app to TypeScript 5.5?")
```

### Web fetching

Claude는 [web fetching tool](https://docs.claude.com/en/docs/agents-and-tools/tool-use/web-fetch-tool)을 사용하여 검색을 실행하고 citation으로 response를 근거할 수 있습니다.

from langchain_anthropic import ChatAnthropic

```python
model = ChatAnthropic(
    model="claude-3-5-haiku-latest",
    betas=["web-fetch-2025-09-10"],  # Enable web fetch beta
)

tool = {"type": "web_fetch_20250910", "name": "web_fetch", "max_uses": 3}
model_with_tools = model.bind_tools([tool])

response = model_with_tools.invoke(
    "Please analyze the content at https://example.com/article"
)
```

<Warning>
    web fetching을 사용하려면 `'web-fetch-2025-09-10'` beta header를 추가해야 합니다.
</Warning>

### Code execution

Claude는 [code execution tool](https://docs.claude.com/en/docs/agents-and-tools/tool-use/code-execution-tool)을 사용하여 sandboxed environment에서 Python code를 실행할 수 있습니다.

<Info>
    **Code execution은 `langchain-anthropic>=0.3.14`부터 지원됩니다**
</Info>

```python
from langchain_anthropic import ChatAnthropic

model = ChatAnthropic(
    model="claude-sonnet-4-20250514",
    betas=["code-execution-2025-05-22"],
)

tool = {"type": "code_execution_20250522", "name": "code_execution"}
model_with_tools = model.bind_tools([tool])

response = model_with_tools.invoke(
    "Calculate the mean and standard deviation of [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
)
```

<Accordion title="Files API와 함께 사용">

Files API를 사용하여 Claude는 데이터 분석 및 기타 목적으로 파일에 액세스하는 code를 작성할 수 있습니다. 아래 예제를 참조하세요:

```python
# Upload file

import anthropic

client = anthropic.Anthropic()
file = client.beta.files.upload(
    file=open("/path/to/sample_data.csv", "rb")
)
file_id = file.id


# Run inference
from langchain_anthropic import ChatAnthropic

model = ChatAnthropic(
    model="claude-sonnet-4-20250514",
    betas=["code-execution-2025-05-22"],
)

tool = {"type": "code_execution_20250522", "name": "code_execution"}
model_with_tools = model.bind_tools([tool])

input_message = {
    "role": "user",
    "content": [
        {
            "type": "text",
            "text": "Please plot these data and tell me what you see.",
        },
        {
            "type": "container_upload",
            "file_id": file_id,
        },
    ]
}
model_with_tools.invoke([input_message])
```

Claude는 code execution의 일부로 파일을 생성할 수 있습니다. Files API를 사용하여 이러한 파일에 액세스할 수 있습니다:

```python
# Take all file outputs for demonstration purposes
file_ids = []
for block in response.content:
    if block["type"] == "code_execution_tool_result":
        file_ids.extend(
            content["file_id"]
            for content in block.get("content", {}).get("content", [])
            if "file_id" in content
        )

for i, file_id in enumerate(file_ids):
    file_content = client.beta.files.download(file_id)
    file_content.write_to_file(f"/path/to/file_{i}.png")
```

</Accordion>

### Memory tool

Claude는 conversational thread 간에 context의 client-side storage 및 retrieval을 위한 memory tool을 지원합니다. 자세한 내용은 [여기](https://docs.claude.com/en/docs/agents-and-tools/tool-use/memory-tool) 문서를 참조하세요.

<Info>
    **Anthropic의 built-in memory tool은 `langchain-anthropic>=0.3.21`부터 지원됩니다**
</Info>

```python
from langchain_anthropic import ChatAnthropic

model = ChatAnthropic(
    model="claude-sonnet-4-5",
    betas=["context-management-2025-06-27"],
)
model_with_tools = model.bind_tools([{"type": "memory_20250818", "name": "memory"}])

response = model_with_tools.invoke("What are my interests?")
```

### Remote MCP

Claude는 remote MCP server에 대한 model-generated call을 위해 [MCP connector tool](https://docs.claude.com/en/docs/agents-and-tools/mcp-connector)을 사용할 수 있습니다.

<Info>
    **Remote MCP는 `langchain-anthropic>=0.3.14`부터 지원됩니다**
</Info>

```python
from langchain_anthropic import ChatAnthropic

mcp_servers = [
    {
        "type": "url",
        "url": "https://mcp.deepwiki.com/mcp",
        "name": "deepwiki",
        "tool_configuration": {  # optional configuration
            "enabled": True,
            "allowed_tools": ["ask_question"],
        },
        "authorization_token": "PLACEHOLDER",  # optional authorization
    }
]

model = ChatAnthropic(
    model="claude-sonnet-4-20250514",
    betas=["mcp-client-2025-04-04"],
    mcp_servers=mcp_servers,
)

response = model.invoke(
    "What transport protocols does the 2025-03-26 version of the MCP "
    "spec (modelcontextprotocol/modelcontextprotocol) support?"
)
```

### Text editor

text editor tool은 텍스트 파일을 보고 수정하는 데 사용할 수 있습니다. 자세한 내용은 [여기](https://docs.claude.com/en/docs/agents-and-tools/tool-use/text-editor-tool) 문서를 참조하세요.

```python
from langchain_anthropic import ChatAnthropic

model = ChatAnthropic(model="claude-3-7-sonnet-20250219")

tool = {"type": "text_editor_20250124", "name": "str_replace_editor"}
model_with_tools = model.bind_tools([tool])

response = model_with_tools.invoke(
    "There's a syntax error in my primes.py file. Can you help me fix it?"
)
print(response.text)
response.tool_calls
```

```output
I'd be happy to help you fix the syntax error in your primes.py file. First, let's look at the current content of the file to identify the error.
```

```output
[{'name': 'str_replace_editor',
  'args': {'command': 'view', 'path': '/repo/primes.py'},
  'id': 'toolu_01VdNgt1YV7kGfj9LFLm6HyQ',
  'type': 'tool_call'}]
```

## API reference

모든 기능과 구성 옵션에 대한 자세한 문서는 @[`ChatAnthropic`] API reference를 참조하세요.