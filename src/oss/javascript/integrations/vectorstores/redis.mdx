---
title: RedisVectorStore
---

<Tip>
**호환성**: Node.js에서만 사용 가능합니다.
</Tip>

[Redis](https://redis.io/)는 빠른 오픈 소스 인메모리 데이터 저장소입니다. [Redis Stack](https://redis.io/docs/latest/operate/oss_and_stack/install/install-stack/)의 일부인 [RediSearch](https://redis.io/docs/latest/develop/interact/search-and-query/)는 벡터 유사도 의미 검색뿐만 아니라 다양한 유형의 검색을 가능하게 하는 모듈입니다.

이 가이드는 Redis [vector stores](/oss/integrations/vectorstores) 시작하기에 대한 간단한 개요를 제공합니다. 모든 `RedisVectorStore` 기능 및 구성에 대한 자세한 문서는 [API reference](https://api.js.langchain.com/classes/langchain_redis.RedisVectorStore.html)를 참조하세요.

## 개요

### Integration 세부 정보

| Class                                                                                            | Package                                                   | [PY support](https://python.langchain.com/docs/integrations/vectorstores/redis/) |                                           Version                                            |
| :----------------------------------------------------------------------------------------------- | :-------------------------------------------------------- | :------------------------------------------------------------------------------: | :------------------------------------------------------------------------------------------: |
| [`RedisVectorStore`](https://api.js.langchain.com/classes/langchain_redis.RedisVectorStore.html) | [`@langchain/redis`](https://npmjs.com/@langchain/redis/) |                                        ✅                                        | ![NPM - Version](https://img.shields.io/npm/v/@langchain/redis?style=flat-square&label=%20&) |

## 설정

Redis vector store를 사용하려면 Redis 인스턴스를 설정하고 `@langchain/redis` integration package를 설치해야 합니다. 특정 client 인스턴스로 vector store를 초기화하기 위해 [`node-redis`](https://github.com/redis/node-redis) package도 설치할 수 있습니다.

이 가이드는 [OpenAI embeddings](/oss/integrations/text_embedding/openai)도 사용하며, 이를 위해 `@langchain/openai` integration package를 설치해야 합니다. 원하는 경우 [다른 지원되는 embeddings models](/oss/integrations/text_embedding)도 사용할 수 있습니다.

<CodeGroup>
```bash npm
npm install @langchain/redis @langchain/core redis @langchain/openai
```
```bash yarn
yarn add @langchain/redis @langchain/core redis @langchain/openai
```
```bash pnpm
pnpm add @langchain/redis @langchain/core redis @langchain/openai
```
</CodeGroup>

[이 지침](https://redis.io/docs/latest/operate/oss_and_stack/install/install-stack/docker/#redisredis-stack)을 따라 Docker로 로컬에서 Redis 인스턴스를 설정할 수 있습니다.

### 자격 증명

인스턴스를 설정한 후 `REDIS_URL` 환경 변수를 설정하세요:

```typescript
process.env.REDIS_URL = "your-redis-url";
```

이 가이드에서 OpenAI embeddings를 사용하는 경우 OpenAI key도 설정해야 합니다:

```typescript
process.env.OPENAI_API_KEY = "YOUR_API_KEY";
```

모델 호출에 대한 자동 추적을 원하는 경우 아래 주석을 해제하여 [LangSmith](https://docs.smith.langchain.com/) API key를 설정할 수도 있습니다:

```typescript
// process.env.LANGSMITH_TRACING="true"
// process.env.LANGSMITH_API_KEY="your-api-key"
```

## 인스턴스화

```typescript
import { RedisVectorStore } from "@langchain/redis";
import { OpenAIEmbeddings } from "@langchain/openai";

import { createClient } from "redis";

const embeddings = new OpenAIEmbeddings({
  model: "text-embedding-3-small",
});

const client = createClient({
  url: process.env.REDIS_URL ?? "redis://localhost:6379",
});
await client.connect();

const vectorStore = new RedisVectorStore(embeddings, {
  redisClient: client,
  indexName: "langchainjs-testing",
});
```

## Vector store 관리

### Vector store에 항목 추가

```typescript
import type { Document } from "@langchain/core/documents";

const document1: Document = {
  pageContent: "The powerhouse of the cell is the mitochondria",
  metadata: { type: "example" },
};

const document2: Document = {
  pageContent: "Buildings are made out of brick",
  metadata: { type: "example" },
};

const document3: Document = {
  pageContent: "Mitochondria are made out of lipids",
  metadata: { type: "example" },
};

const document4: Document = {
  pageContent: "The 2024 Olympics are in Paris",
  metadata: { type: "example" },
};

const documents = [document1, document2, document3, document4];

await vectorStore.addDocuments(documents);
```

최상위 document id는 현재 지원되지 않지만, ID를 vector store에 직접 제공하여 문서를 삭제할 수 있습니다.

## Vector store 쿼리

Vector store가 생성되고 관련 문서가 추가되면 chain 또는 agent를 실행하는 동안 쿼리하고 싶을 것입니다.

### 직접 쿼리

간단한 유사도 검색은 다음과 같이 수행할 수 있습니다:

```typescript
const similaritySearchResults = await vectorStore.similaritySearch(
  "biology",
  2
);

for (const doc of similaritySearchResults) {
  console.log(`* ${doc.pageContent} [${JSON.stringify(doc.metadata, null)}]`);
}
```

필터링은 현재 제공된 문자열을 포함하는 모든 metadata key를 찾습니다.

유사도 검색을 실행하고 해당 점수를 받으려면 다음을 실행할 수 있습니다:

```typescript
const similaritySearchWithScoreResults =
  await vectorStore.similaritySearchWithScore("biology", 2);

for (const [doc, score] of similaritySearchWithScoreResults) {
  console.log(
    `* [SIM=${score.toFixed(3)}] ${doc.pageContent} [${JSON.stringify(
      doc.metadata
    )}]`
  );
}
```

```output
* [SIM=0.835] The powerhouse of the cell is the mitochondria [{"type":"example"}]
* [SIM=0.852] Mitochondria are made out of lipids [{"type":"example"}]
```

### Retriever로 변환하여 쿼리

Vector store를 [retriever](/oss/langchain/retrieval)로 변환하여 chain에서 더 쉽게 사용할 수도 있습니다.

```typescript
const retriever = vectorStore.asRetriever({
  k: 2,
});
await retriever.invoke("biology");
```

```output
[
  Document {
    pageContent: 'The powerhouse of the cell is the mitochondria',
    metadata: { type: 'example' },
    id: undefined
  },
  Document {
    pageContent: 'Mitochondria are made out of lipids',
    metadata: { type: 'example' },
    id: undefined
  }
]
```

### Retrieval-augmented generation 사용

이 vector store를 retrieval-augmented generation (RAG)에 사용하는 방법에 대한 가이드는 다음 섹션을 참조하세요:

- [LangChain으로 RAG 앱 만들기](/oss/langchain/rag)
- [Agentic RAG](/oss/langgraph/agentic-rag)
- [Retrieval 문서](/oss/langchain/retrieval)

## 문서 삭제

두 가지 방법으로 vector store에서 문서를 삭제할 수 있습니다:

### 모든 문서 삭제

다음 명령으로 전체 index와 모든 문서를 삭제할 수 있습니다:

```typescript
await vectorStore.delete({ deleteAll: true });
```

### ID로 특정 문서 삭제

ID를 제공하여 특정 문서를 삭제할 수도 있습니다. 구성된 key prefix가 제공한 ID에 자동으로 추가됩니다:

```typescript
// The key prefix will be automatically added to each ID
await vectorStore.delete({ ids: ["doc1", "doc2", "doc3"] });
```

## 연결 종료

과도한 리소스 소비를 방지하기 위해 작업이 완료되면 client 연결을 종료해야 합니다:

```typescript
await client.disconnect();
```

## 고급 기능

### 사용자 정의 Schema 및 Metadata 필터링

Redis vector store는 metadata 필드에 대한 사용자 정의 schema 정의를 지원하여 더 효율적인 필터링 및 검색을 가능하게 합니다. 이 기능을 사용하면 metadata에 대한 특정 필드 타입과 유효성 검사 규칙을 정의할 수 있습니다.

#### 사용자 정의 Schema 정의

Vector store를 생성할 때 사용자 정의 schema를 정의하여 필드 타입, 유효성 검사 규칙 및 인덱싱 옵션을 지정할 수 있습니다:

```typescript
import { RedisVectorStore } from "@langchain/redis";
import { OpenAIEmbeddings } from "@langchain/openai";
import { SchemaFieldTypes } from "redis";
import { createClient } from "redis";

const embeddings = new OpenAIEmbeddings({
  model: "text-embedding-3-small",
});

const client = createClient({
  url: process.env.REDIS_URL ?? "redis://localhost:6379",
});
await client.connect();

// Define custom schema for metadata fields
const customSchema:RedisVectorStoreConfig["customSchema"] = {
  userId: {
    type: SchemaFieldTypes.TEXT,
    required: true,
    SORTABLE: true,
  },
  category: {
    type: SchemaFieldTypes.TAG,
    SORTABLE: true,
    SEPARATOR: ",",
  },
  score: {
    type: SchemaFieldTypes.NUMERIC,
    SORTABLE: true,
  },
  tags: {
    type: SchemaFieldTypes.TAG,
    SEPARATOR: ",",
    CASESENSITIVE: true,
  },
  description: {
    type: SchemaFieldTypes.TEXT,
    NOSTEM: true,
    WEIGHT: 2.0,
  },
};

const vectorStoreWithSchema = new RedisVectorStore(embeddings, {
  redisClient: client,
  indexName: "langchainjs-custom-schema",
  customSchema,
});
```

#### Schema 필드 타입

사용자 정의 schema는 세 가지 주요 필드 타입을 지원합니다:

- **TEXT**: 선택적 stemming, weighting 및 sorting이 가능한 전체 텍스트 검색 가능 필드
- **TAG**: 여러 값과 사용자 정의 separator를 지원하는 정확한 일치를 위한 범주형 필드
- **NUMERIC**: 범위 쿼리 및 sorting을 지원하는 숫자 필드

#### 필드 구성 옵션

각 필드는 다양한 옵션으로 구성할 수 있습니다:

- `required`: metadata에 필드가 반드시 있어야 하는지 여부 (기본값: false)
- `SORTABLE`: 이 필드에서 sorting 활성화 (기본값: undefined)
- `SEPARATOR`: TAG 필드의 경우 여러 값에 대한 separator 지정 (기본값: ",")
- `CASESENSITIVE`: TAG 필드의 경우 대소문자 구분 일치 활성화 (Redis는 boolean이 아닌 `true`를 예상)
- `NOSTEM`: TEXT 필드의 경우 stemming 비활성화 (Redis는 boolean이 아닌 `true`를 예상)
- `WEIGHT`: TEXT 필드의 경우 검색 가중치 지정 (기본값: 1.0)

#### Schema 유효성 검사로 문서 추가

사용자 정의 schema를 사용할 때 문서는 정의된 schema에 대해 자동으로 유효성이 검사됩니다:

```typescript
import type { Document } from "@langchain/core/documents";

const documentsWithMetadata: Document[] = [
  {
    pageContent: "Advanced JavaScript techniques for modern web development",
    metadata: {
      userId: "user123",
      category: "programming",
      score: 95,
      tags: ["javascript", "web-development", "frontend"],
      description: "Comprehensive guide to JavaScript best practices",
    },
  },
  {
    pageContent: "Machine learning fundamentals and applications",
    metadata: {
      userId: "user456",
      category: "ai",
      score: 88,
      tags: ["machine-learning", "python", "data-science"],
      description: "Introduction to ML concepts and practical applications",
    },
  },
  {
    pageContent: "Database optimization strategies for high performance",
    metadata: {
      userId: "user789",
      category: "database",
      score: 92,
      tags: ["database", "optimization", "performance"],
      description: "Advanced techniques for database performance tuning",
    },
  },
];

// This will validate each document's metadata against the custom schema
await vectorStoreWithSchema.addDocuments(documentsWithMetadata);
```

#### Metadata 필터링을 사용한 고급 유사도 검색

사용자 정의 schema는 `similaritySearchVectorWithScoreAndMetadata` method를 사용하여 강력한 metadata 필터링 기능을 제공합니다:

```typescript
// Search with TAG filtering
const tagFilterResults =
  await vectorStoreWithSchema.similaritySearchVectorWithScoreAndMetadata(
    await embeddings.embedQuery("programming tutorial"),
    3,
    {
      category: "programming", // Exact tag match
      tags: ["javascript", "frontend"], // Multiple tag OR search
    }
  );

console.log("Tag filter results:");
for (const [doc, score] of tagFilterResults) {
  console.log(`* [SIM=${score.toFixed(3)}] ${doc.pageContent}`);
  console.log(`  Metadata: ${JSON.stringify(doc.metadata)}`);
}
```

```typescript
// Search with NUMERIC range filtering
const numericFilterResults =
  await vectorStoreWithSchema.similaritySearchVectorWithScoreAndMetadata(
    await embeddings.embedQuery("high quality content"),
    5,
    {
      score: { min: 90, max: 100 }, // Score between 90 and 100
      category: ["programming", "ai"], // Multiple categories
    }
  );

console.log("Numeric filter results:");
for (const [doc, score] of numericFilterResults) {
  console.log(`* [SIM=${score.toFixed(3)}] ${doc.pageContent}`);
  console.log(
    `  Score: ${doc.metadata.score}, Category: ${doc.metadata.category}`
  );
}
```

```typescript
// Search with TEXT field filtering
const textFilterResults =
  await vectorStoreWithSchema.similaritySearchVectorWithScoreAndMetadata(
    await embeddings.embedQuery("development guide"),
    3,
    {
      description: "comprehensive guide", // Text search in description field
      score: { min: 85 }, // Minimum score of 85
    }
  );

console.log("Text filter results:");
for (const [doc, score] of textFilterResults) {
  console.log(`* [SIM=${score.toFixed(3)}] ${doc.pageContent}`);
  console.log(`  Description: ${doc.metadata.description}`);
}
```

#### 숫자 범위 쿼리 옵션

숫자 필드의 경우 다양한 범위 쿼리를 지정할 수 있습니다:

```typescript
// Exact value match
{ score: 95 }

// Range with both min and max
{ score: { min: 80, max: 100 } }

// Only minimum value
{ score: { min: 90 } }

// Only maximum value
{ score: { max: 95 } }
```

#### 오류 처리 및 유효성 검사

사용자 정의 schema는 유용한 오류 메시지와 함께 자동 유효성 검사를 제공합니다:

```typescript
try {
  // This will fail validation - missing required userId field
  const invalidDoc: Document = {
    pageContent: "Some content without required metadata",
    metadata: {
      category: "test",
      // Missing required userId field
    },
  };

  await vectorStoreWithSchema.addDocuments([invalidDoc]);
} catch (error) {
  console.log("Validation error:", error.message);
  // Output: "Required metadata field 'userId' is missing"
}

try {
  // This will fail validation - wrong type for score field
  const wrongTypeDoc: Document = {
    pageContent: "Content with wrong metadata type",
    metadata: {
      userId: "user123",
      score: "not-a-number", // Should be number, not string
    },
  };

  await vectorStoreWithSchema.addDocuments([wrongTypeDoc]);
} catch (error) {
  console.log("Type validation error:", error.message);
  // Output: "Metadata field 'score' must be a number, got string"
}
```

#### 성능 이점

사용자 정의 schema 사용은 여러 성능상의 이점을 제공합니다:

1. **인덱싱된 Metadata 필드**: 개별 metadata 필드가 별도로 인덱싱되어 빠른 필터링 가능
2. **타입 최적화 쿼리**: 숫자 및 tag 필드는 최적화된 쿼리 구조 사용
3. **데이터 전송 감소**: 검색 결과에서 관련 필드만 반환
4. **향상된 쿼리 계획**: Redis는 필드 타입과 index를 기반으로 쿼리를 최적화할 수 있음

#### 하위 호환성

사용자 정의 schema 기능은 완전히 하위 호환됩니다. 사용자 정의 schema가 없는 기존 Redis vector store는 이전과 정확히 동일하게 작동합니다. 새 index에 대해 또는 기존 index를 재구축할 때 사용자 정의 schema로 점진적으로 마이그레이션할 수 있습니다.

## API reference

모든 `RedisVectorSearch` 기능 및 구성에 대한 자세한 문서는 [API reference](https://api.js.langchain.com/classes/langchain_redis.RedisVectorStore.html)를 참조하세요.