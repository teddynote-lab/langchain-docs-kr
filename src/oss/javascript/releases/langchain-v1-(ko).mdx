---
title: v1의 새로운 기능
sidebarTitle: 릴리스 노트
---

**LangChain v1은 에이전트 구축을 위한 집중적이고 프로덕션 준비가 완료된 기반입니다.** 세 가지 핵심 개선 사항을 중심으로 프레임워크를 간소화했습니다:

<CardGroup cols={1}>
    <Card title="createAgent" icon="robot" href="#create-agent" arrow>
        LangChain에서 에이전트를 구축하는 새로운 표준 방식으로, LangGraph의 `createReactAgent`를 더 깔끔하고 강력한 API로 대체합니다.
    </Card>
    <Card title="표준 content block" icon="cube" href="#standard-content-blocks" arrow>
        모든 provider에서 최신 LLM 기능에 대한 통합 액세스를 제공하는 새로운 `contentBlocks` 속성입니다.
    </Card>
    <Card title="간소화된 패키지" icon="sitemap" href="#simplified-package" arrow>
        `langchain` 패키지는 에이전트를 위한 필수 구성 요소에 집중하도록 간소화되었으며, 레거시 기능은 `@langchain/classic`으로 이동되었습니다.
    </Card>
</CardGroup>

업그레이드하려면,

<CodeGroup>
```bash npm
npm install langchain @langchain/core
```
```bash pnpm
pnpm install langchain @langchain/core
```
```bash yarn
yarn add langchain @langchain/core
```
```bash bun
bun add langchain @langchain/core
```
</CodeGroup>

전체 변경 사항 목록은 [마이그레이션 가이드](/oss/migrate/langchain-v1)를 참조하세요.

## `createAgent`

`createAgent`는 LangChain 1.0에서 에이전트를 구축하는 표준 방식입니다. LangGraph에서 내보낸 사전 구축된 `createReactAgent`보다 더 간단한 인터페이스를 제공하면서 middleware를 사용하여 더 큰 커스터마이징 가능성을 제공합니다.

```ts
import { createAgent } from "langchain";

const agent = createAgent({
  model: "anthropic:claude-sonnet-4-5",
  tools: [getWeather],
  systemPrompt: "You are a helpful assistant.",
});

const result = await agent.invoke({
  messages: [
    { role: "user", content: "What is the weather in Tokyo?" },
  ],
});

console.log(result.content);
```

내부적으로 `createAgent`는 기본 에이전트 루프를 기반으로 구축됩니다 -- model을 호출하고, 실행할 tool을 선택하게 한 다음, 더 이상 tool을 호출하지 않으면 종료합니다:

<div style={{ display: "flex", justifyContent: "center" }}>
  <img
    src="/oss/images/core_agent_loop.png"
    alt="핵심 에이전트 루프 다이어그램"
    className="rounded-lg"
  />
</div>

자세한 내용은 [Agents](/oss/langchain/agents)를 참조하세요.

### Middleware

Middleware는 `createAgent`의 핵심 기능입니다. `createAgent`를 매우 커스터마이징 가능하게 만들어 구축할 수 있는 것의 한계를 높입니다.

훌륭한 에이전트는 [context engineering](/oss/langchain/context-engineering)이 필요합니다: 적절한 시기에 model에 올바른 정보를 제공하는 것입니다. Middleware는 구성 가능한 추상화를 통해 동적 prompt, 대화 요약, 선택적 tool 액세스, 상태 관리 및 guardrail을 제어하는 데 도움이 됩니다.

#### 사전 구축된 middleware

LangChain은 일반적인 패턴을 위한 몇 가지 [사전 구축된 middleware](/oss/langchain/middleware#built-in-middleware)를 제공합니다:

- `summarizationMiddleware`: 대화 기록이 너무 길어지면 압축
- `humanInTheLoopMiddleware`: 민감한 tool 호출에 대한 승인 요구
- `piiRedactionMiddleware`: model로 전송하기 전에 민감한 정보 삭제

```ts
import {
  createAgent,
  summarizationMiddleware,
  humanInTheLoopMiddleware,
  piiRedactionMiddleware,
} from "langchain";

const agent = createAgent({
  model: "anthropic:claude-sonnet-4-5",
  tools: [readEmail, sendEmail],
  middleware: [
    piiRedactionMiddleware({ patterns: ["email", "phone", "ssn"] }),
    summarizationMiddleware({
      model: "anthropic:claude-sonnet-4-5",
      maxTokensBeforeSummary: 500,
    }),
    humanInTheLoopMiddleware({
      interruptOn: {
        sendEmail: {
          allowedDecisions: ["approve", "edit", "reject"],
        },
      },
    }),
  ] as const,
});
```

#### 커스텀 middleware

특정 요구 사항에 맞게 커스텀 middleware를 구축할 수도 있습니다.

`createMiddleware` 함수를 사용하여 다음 hook 중 하나를 구현하여 커스텀 middleware를 구축하세요:

| Hook              | 실행 시점             | 사용 사례                               |
|-------------------|--------------------------|-----------------------------------------|
| `beforeAgent`     | 에이전트 호출 전 | 메모리 로드, 입력 검증             |
| `beforeModel`     | 각 LLM 호출 전     | prompt 업데이트, 메시지 정리           |
| `wrapModelCall`   | 각 LLM 호출 전후     | 요청/응답 가로채기 및 수정 |
| `wrapToolCall`    | 각 tool 호출 전후    | tool 실행 가로채기 및 수정     |
| `afterModel`      | 각 LLM 응답 후  | 출력 검증, guardrail 적용       |
| `afterAgent`      | 에이전트 완료 후    | 결과 저장, 정리                   |


<div style={{ display: "flex", justifyContent: "center" }}>
  <img
    src="/oss/images/middleware_final.png"
    alt="Middleware 흐름 다이어그램"
    className="rounded-lg"
  />
</div>


커스텀 middleware 예제:

```ts
import { createMiddleware } from "langchain";

const contextSchema = z.object({
  userExpertise: z.enum(["beginner", "expert"]).default("beginner"),
})

const expertiseBasedToolMiddleware = createMiddleware({
  wrapModelCall: async (request, handler) => {
    const userLevel = request.runtime.context.userExpertise;
    if (userLevel === "expert") {
      const tools = [advancedSearch, dataAnalysis];
      return handler(
        request.replace("openai:gpt-5", tools)
      );
    }
    const tools = [simpleSearch, basicCalculator];
    return handler(
      request.replace("openai:gpt-5-nano", tools)
    );
  },
});

const agent = createAgent({
  model: "anthropic:claude-sonnet-4-5",
  tools: [simpleSearch, advancedSearch, basicCalculator, dataAnalysis],
  middleware: [expertiseBasedToolMiddleware],
  contextSchema,
});
```

자세한 내용은 [전체 middleware 가이드](/oss/langchain/middleware)를 참조하세요.

### LangGraph 기반

`createAgent`는 LangGraph를 기반으로 구축되었기 때문에 다음을 통해 장기 실행 및 안정적인 에이전트에 대한 기본 지원을 자동으로 받습니다:

<CardGroup cols={2}>
    <Card title="Persistence" icon="database">
        내장된 checkpointing으로 세션 간에 대화가 자동으로 유지됩니다
    </Card>
    <Card title="Streaming" icon="water">
        실시간으로 token, tool 호출 및 추론 trace를 스트리밍합니다
    </Card>
    <Card title="Human-in-the-loop" icon="hand">
        민감한 작업 전에 사람의 승인을 위해 에이전트 실행을 일시 중지합니다
    </Card>
    <Card title="Time travel" icon="clock-rotate-left">
        대화를 임의의 시점으로 되돌리고 대체 경로와 prompt를 탐색합니다
    </Card>
</CardGroup>

이러한 기능을 사용하기 위해 LangGraph를 배울 필요가 없습니다—기본적으로 작동합니다.

### Structured output

`createAgent`는 structured output 생성을 개선했습니다:

- **Main loop 통합**: Structured output은 이제 추가 LLM 호출이 필요하지 않고 main loop에서 생성됩니다
- **Structured output 전략**: Model은 tool 호출과 provider 측 structured output 생성 중에서 선택할 수 있습니다
- **비용 절감**: 추가 LLM 호출로 인한 추가 비용을 제거합니다

```ts
import { createAgent } from "langchain";
import * as z from "zod";

const weatherSchema = z.object({
  temperature: z.number(),
  condition: z.string(),
});

const agent = createAgent({
  model: "openai:gpt-4o-mini",
  tools: [getWeather],
  responseFormat: weatherSchema,
});

const result = await agent.invoke({
  messages: [
    { role: "user", content: "What is the weather in Tokyo?" },
  ],
});

console.log(result.structuredResponse);
```

**오류 처리**: `ToolStrategy`의 `handleErrors` 매개변수를 통해 오류 처리를 제어합니다:
- **파싱 오류**: Model이 원하는 구조와 일치하지 않는 데이터를 생성
- **다중 tool 호출**: Model이 structured output schema에 대해 2개 이상의 tool 호출을 생성

---

## 표준 content block

<Note>
    1.0 릴리스는 대부분의 패키지에서 사용할 수 있습니다. 현재 새로운 content block을 지원하는 패키지는 다음과 같습니다:

    - `langchain`
    - `@langchain/core`
    - `@langchain/anthropic`
    - `@langchain/openai`

    content block에 대한 더 광범위한 지원이 계획되어 있습니다.
</Note>

### 이점

- **Provider 독립적**: provider에 관계없이 동일한 API를 사용하여 추론 trace, 인용, 내장 tool(웹 검색, 코드 인터프리터 등) 및 기타 기능에 액세스합니다
- **Type safe**: 모든 content block 유형에 대한 전체 type hint
- **하위 호환성**: 표준 content는 [지연 로드](/oss/langchain/messages#standard-content-blocks)될 수 있으므로 관련된 breaking change가 없습니다

자세한 내용은 [content block](/oss/langchain/messages#message-content)에 대한 가이드를 참조하세요

---

## 간소화된 패키지

LangChain v1은 에이전트를 위한 필수 구성 요소에 집중하도록 `langchain` 패키지 namespace를 간소화합니다. 패키지는 가장 유용하고 관련성 높은 기능만 노출합니다:

이들 대부분은 편의를 위해 `@langchain/core`에서 재내보내기되어 에이전트 구축을 위한 집중된 API 표면을 제공합니다.


### `@langchain/classic`

레거시 기능은 핵심 패키지를 간결하고 집중적으로 유지하기 위해 [`@langchain/classic`](https://www.npmjs.com/package/@langchain/classic)으로 이동되었습니다.

#### `@langchain/classic`에 포함된 내용

- 레거시 chain 및 chain 구현
- Retriever
- indexing API
- [`@langchain/community`](https://www.npmjs.com/package/@langchain/community) export
- 기타 deprecated 기능

이러한 기능을 사용하는 경우 [`@langchain/classic`](https://www.npmjs.com/package/@langchain/classic)을 설치하세요:

<CodeGroup>
```bash npm
npm install @langchain/classic
```
```bash pnpm
pnpm install @langchain/classic
```
```bash yarn
yarn add @langchain/classic
```
```bash bun
bun add @langchain/classic
```
</CodeGroup>

그런 다음 import를 업데이트하세요:

```typescript
import { ... } from "langchain"; // [!code --]
import { ... } from "@langchain/classic"; // [!code ++]

import { ... } from "langchain/chains"; // [!code --]
import { ... } from "@langchain/classic/chains"; // [!code ++]
```

## 이슈 보고

1.0에서 발견된 이슈는 [`'v1'` label](https://github.com/langchain-ai/langchainjs/issues?q=state%3Aopen%20label%3Av1)을 사용하여 [GitHub](https://github.com/langchain-ai/langchainjs/issues)에 보고해 주세요.

## 추가 리소스

<CardGroup cols={3}>
    <Card title="LangChain 1.0" icon="rocket" href="https://blog.langchain.com/langchain-langchain-1-0-alpha-releases/">
        공지사항 읽기
    </Card>
    <Card title="Middleware 가이드" icon="puzzle-piece" href="https://blog.langchain.com/agent-middleware/">
        middleware 심층 분석
    </Card>
    <Card title="Agents 문서" icon="book" href="/oss/langchain/agents" arrow>
        전체 에이전트 문서
    </Card>
    <Card title="Message Content" icon="message" href="/oss/langchain/messages#message-content" arrow>
        새로운 content block API
    </Card>
    <Card title="마이그레이션 가이드" icon="arrow-right-arrow-left" href="/oss/migrate/langchain-v1" arrow>
        LangChain v1으로 마이그레이션하는 방법
    </Card>
    <Card title="GitHub" icon="github" href="https://github.com/langchain-ai/langchainjs">
        이슈 보고 또는 기여
    </Card>
</CardGroup>

## 참고

- [Versioning](/oss/versioning) - 버전 번호 이해하기
- [Release policy](/oss/release-policy) - 상세한 릴리스 정책