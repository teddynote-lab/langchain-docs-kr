---
title: Interrupts
---



InterruptëŠ” graph ì‹¤í–‰ì„ íŠ¹ì • ì§€ì ì—ì„œ ì¼ì‹œ ì¤‘ì§€í•˜ê³  ê³„ì†í•˜ê¸° ì „ì— ì™¸ë¶€ ì…ë ¥ì„ ê¸°ë‹¤ë¦´ ìˆ˜ ìˆê²Œ í•´ì¤ë‹ˆë‹¤. ì´ë¥¼ í†µí•´ ì™¸ë¶€ ì…ë ¥ì´ í•„ìš”í•œ human-in-the-loop íŒ¨í„´ì„ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. Interruptê°€ íŠ¸ë¦¬ê±°ë˜ë©´ LangGraphëŠ” [persistence](/oss/langgraph/persistence) ë ˆì´ì–´ë¥¼ ì‚¬ìš©í•˜ì—¬ graph ìƒíƒœë¥¼ ì €ì¥í•˜ê³  ì‹¤í–‰ì„ ì¬ê°œí•  ë•Œê¹Œì§€ ë¬´ê¸°í•œ ëŒ€ê¸°í•©ë‹ˆë‹¤.

InterruptëŠ” graph nodeì˜ ì–´ëŠ ì§€ì ì—ì„œë“  `interrupt()` í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ ì‘ë™í•©ë‹ˆë‹¤. ì´ í•¨ìˆ˜ëŠ” JSON ì§ë ¬í™” ê°€ëŠ¥í•œ ëª¨ë“  ê°’ì„ ë°›ì•„ í˜¸ì¶œìì—ê²Œ ì „ë‹¬í•©ë‹ˆë‹¤. ê³„ì†í•  ì¤€ë¹„ê°€ ë˜ë©´ `Command`ë¥¼ ì‚¬ìš©í•˜ì—¬ graphë¥¼ ë‹¤ì‹œ í˜¸ì¶œí•˜ì—¬ ì‹¤í–‰ì„ ì¬ê°œí•˜ë©°, ì´ëŠ” node ë‚´ë¶€ì˜ `interrupt()` í˜¸ì¶œì˜ ë°˜í™˜ ê°’ì´ ë©ë‹ˆë‹¤.

ì •ì  breakpoint(íŠ¹ì • node ì „í›„ì— ì¼ì‹œ ì¤‘ì§€)ì™€ ë‹¬ë¦¬, interruptëŠ” **ë™ì **ì…ë‹ˆë‹¤â€”ì½”ë“œì˜ ì–´ëŠ ê³³ì—ë‚˜ ë°°ì¹˜í•  ìˆ˜ ìˆìœ¼ë©° ì• í”Œë¦¬ì¼€ì´ì…˜ ë¡œì§ì— ë”°ë¼ ì¡°ê±´ë¶€ë¡œ ì‹¤í–‰ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

:::python
- **Checkpointingì´ ìœ„ì¹˜ë¥¼ ìœ ì§€í•©ë‹ˆë‹¤:** checkpointerëŠ” ì •í™•í•œ graph ìƒíƒœë¥¼ ê¸°ë¡í•˜ì—¬ ì˜¤ë¥˜ ìƒíƒœì—ì„œë„ ë‚˜ì¤‘ì— ì¬ê°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- **`thread_id`ëŠ” í¬ì¸í„°ì…ë‹ˆë‹¤:** `config={"configurable": {"thread_id": ...}}`ë¥¼ ì„¤ì •í•˜ì—¬ checkpointerì—ê²Œ ì–´ë–¤ ìƒíƒœë¥¼ ë¡œë“œí• ì§€ ì•Œë ¤ì¤ë‹ˆë‹¤.
- **Interrupt payloadëŠ” `__interrupt__`ë¡œ í‘œì‹œë©ë‹ˆë‹¤:** `interrupt()`ì— ì „ë‹¬í•œ ê°’ì€ `__interrupt__` í•„ë“œì—ì„œ í˜¸ì¶œìì—ê²Œ ë°˜í™˜ë˜ë¯€ë¡œ graphê°€ ë¬´ì—‡ì„ ê¸°ë‹¤ë¦¬ê³  ìˆëŠ”ì§€ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
:::
:::js
- **Checkpointingì´ ìœ„ì¹˜ë¥¼ ìœ ì§€í•©ë‹ˆë‹¤:** checkpointerëŠ” ì •í™•í•œ graph ìƒíƒœë¥¼ ê¸°ë¡í•˜ì—¬ ì˜¤ë¥˜ ìƒíƒœì—ì„œë„ ë‚˜ì¤‘ì— ì¬ê°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- **`thread_id`ëŠ” í¬ì¸í„°ì…ë‹ˆë‹¤:** `invoke` ë©”ì„œë“œì˜ ì˜µì…˜ìœ¼ë¡œ `{ configurable: { thread_id: ... } }`ë¥¼ ì‚¬ìš©í•˜ì—¬ checkpointerì—ê²Œ ì–´ë–¤ ìƒíƒœë¥¼ ë¡œë“œí• ì§€ ì•Œë ¤ì¤ë‹ˆë‹¤.
- **Interrupt payloadëŠ” `__interrupt__`ë¡œ í‘œì‹œë©ë‹ˆë‹¤:** `interrupt()`ì— ì „ë‹¬í•œ ê°’ì€ `__interrupt__` í•„ë“œì—ì„œ í˜¸ì¶œìì—ê²Œ ë°˜í™˜ë˜ë¯€ë¡œ graphê°€ ë¬´ì—‡ì„ ê¸°ë‹¤ë¦¬ê³  ìˆëŠ”ì§€ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
:::

ì„ íƒí•œ `thread_id`ëŠ” ì‚¬ì‹¤ìƒ ì˜êµ¬ì ì¸ ì»¤ì„œì…ë‹ˆë‹¤. ì´ë¥¼ ì¬ì‚¬ìš©í•˜ë©´ ë™ì¼í•œ checkpointë¥¼ ì¬ê°œí•˜ê³ , ìƒˆ ê°’ì„ ì‚¬ìš©í•˜ë©´ ë¹ˆ ìƒíƒœë¡œ ìƒˆë¡œìš´ threadë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.

## `interrupt`ë¥¼ ì‚¬ìš©í•˜ì—¬ ì¼ì‹œ ì¤‘ì§€

@[`interrupt`] í•¨ìˆ˜ëŠ” graph ì‹¤í–‰ì„ ì¼ì‹œ ì¤‘ì§€í•˜ê³  í˜¸ì¶œìì—ê²Œ ê°’ì„ ë°˜í™˜í•©ë‹ˆë‹¤. node ë‚´ì—ì„œ @[`interrupt`]ë¥¼ í˜¸ì¶œí•˜ë©´ LangGraphëŠ” í˜„ì¬ graph ìƒíƒœë¥¼ ì €ì¥í•˜ê³  ì…ë ¥ê³¼ í•¨ê»˜ ì‹¤í–‰ì„ ì¬ê°œí•  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦½ë‹ˆë‹¤.

@[`interrupt`]ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ ë‹¤ìŒì´ í•„ìš”í•©ë‹ˆë‹¤:
1. graph ìƒíƒœë¥¼ ìœ ì§€í•˜ê¸° ìœ„í•œ **checkpointer** (í”„ë¡œë•ì…˜ì—ì„œëŠ” ì˜êµ¬ checkpointer ì‚¬ìš©)
2. runtimeì´ ì–´ë–¤ ìƒíƒœë¥¼ ì¬ê°œí• ì§€ ì•Œ ìˆ˜ ìˆë„ë¡ configì— **thread ID**
3. ì¼ì‹œ ì¤‘ì§€í•˜ë ¤ëŠ” ìœ„ì¹˜ì—ì„œ `interrupt()` í˜¸ì¶œ (payloadëŠ” JSON ì§ë ¬í™” ê°€ëŠ¥í•´ì•¼ í•¨)

:::python
```python
from langgraph.types import interrupt

def approval_node(state: State):
    # Pause and ask for approval
    approved = interrupt("Do you approve this action?")

    # When you resume, Command(resume=...) returns that value here
    return {"approved": approved}
```
:::

:::js
```typescript
import { interrupt } from "@langchain/langgraph";

async function approvalNode(state: State) {
    // Pause and ask for approval
    const approved = interrupt("Do you approve this action?");

    // Command({ resume: ... }) provides the value returned into this variable
    return { approved };
}
```
:::

@[`interrupt`]ë¥¼ í˜¸ì¶œí•˜ë©´ ë‹¤ìŒê³¼ ê°™ì€ ì¼ì´ ë°œìƒí•©ë‹ˆë‹¤:

1. **Graph ì‹¤í–‰ì´ ì¤‘ë‹¨ë©ë‹ˆë‹¤** @[`interrupt`]ê°€ í˜¸ì¶œëœ ì •í™•í•œ ì§€ì ì—ì„œ
2. **ìƒíƒœê°€ ì €ì¥ë©ë‹ˆë‹¤** checkpointerë¥¼ ì‚¬ìš©í•˜ì—¬ ë‚˜ì¤‘ì— ì‹¤í–‰ì„ ì¬ê°œí•  ìˆ˜ ìˆë„ë¡, í”„ë¡œë•ì…˜ì—ì„œëŠ” ì˜êµ¬ checkpointer(ì˜ˆ: ë°ì´í„°ë² ì´ìŠ¤ ê¸°ë°˜)ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤
3. **ê°’ì´ ë°˜í™˜ë©ë‹ˆë‹¤** `__interrupt__` ì•„ë˜ì—ì„œ í˜¸ì¶œìì—ê²Œ; JSON ì§ë ¬í™” ê°€ëŠ¥í•œ ëª¨ë“  ê°’(ë¬¸ìì—´, ê°ì²´, ë°°ì—´ ë“±)ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤
4. **Graphê°€ ë¬´ê¸°í•œ ëŒ€ê¸°í•©ë‹ˆë‹¤** ì‘ë‹µê³¼ í•¨ê»˜ ì‹¤í–‰ì„ ì¬ê°œí•  ë•Œê¹Œì§€
5. **ì‘ë‹µì´ ë‹¤ì‹œ ì „ë‹¬ë©ë‹ˆë‹¤** ì¬ê°œí•  ë•Œ nodeë¡œ, `interrupt()` í˜¸ì¶œì˜ ë°˜í™˜ ê°’ì´ ë©ë‹ˆë‹¤

## Interrupt ì¬ê°œí•˜ê¸°

Interruptê°€ ì‹¤í–‰ì„ ì¼ì‹œ ì¤‘ì§€í•œ í›„, resume ê°’ì„ í¬í•¨í•˜ëŠ” `Command`ë¡œ graphë¥¼ ë‹¤ì‹œ í˜¸ì¶œí•˜ì—¬ ì¬ê°œí•©ë‹ˆë‹¤. Resume ê°’ì€ `interrupt` í˜¸ì¶œë¡œ ë‹¤ì‹œ ì „ë‹¬ë˜ì–´ nodeê°€ ì™¸ë¶€ ì…ë ¥ìœ¼ë¡œ ì‹¤í–‰ì„ ê³„ì†í•  ìˆ˜ ìˆê²Œ í•©ë‹ˆë‹¤.

:::python
```python
from langgraph.types import Command

# Initial run - hits the interrupt and pauses
# thread_id is the persistent pointer (stores a stable ID in production)
config = {"configurable": {"thread_id": "thread-1"}}
result = graph.invoke({"input": "data"}, config=config)

# Check what was interrupted
# __interrupt__ contains the payload that was passed to interrupt()
print(result["__interrupt__"])
# > [Interrupt(value='Do you approve this action?')]

# Resume with the human's response
# The resume payload becomes the return value of interrupt() inside the node
graph.invoke(Command(resume=True), config=config)
```
:::

:::js
```typescript
import { Command } from "@langchain/langgraph";

// Initial run - hits the interrupt and pauses
// thread_id is the durable pointer back to the saved checkpoint
const config = { configurable: { thread_id: "thread-1" } };
const result = await graph.invoke({ input: "data" }, config);

// Check what was interrupted
// __interrupt__ mirrors every payload you passed to interrupt()
console.log(result.__interrupt__);
// [{ value: 'Do you approve this action?', ... }]

// Resume with the human's response
// Command({ resume }) returns that value from interrupt() in the node
await graph.invoke(new Command({ resume: true }), config);
```
:::

**ì¬ê°œì— ëŒ€í•œ ì£¼ìš” ì‚¬í•­:**

- Interruptê°€ ë°œìƒí–ˆì„ ë•Œ ì‚¬ìš©ëœ ê²ƒê³¼ **ë™ì¼í•œ thread ID**ë¥¼ ì¬ê°œí•  ë•Œ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤
- `Command(resume=...)`ì— ì „ë‹¬ëœ ê°’ì´ @[`interrupt`] í˜¸ì¶œì˜ ë°˜í™˜ ê°’ì´ ë©ë‹ˆë‹¤
- NodeëŠ” ì¬ê°œë  ë•Œ @[`interrupt`]ê°€ í˜¸ì¶œëœ nodeì˜ ì‹œì‘ ë¶€ë¶„ë¶€í„° ë‹¤ì‹œ ì‹œì‘ë˜ë¯€ë¡œ @[`interrupt`] ì´ì „ì˜ ëª¨ë“  ì½”ë“œê°€ ë‹¤ì‹œ ì‹¤í–‰ë©ë‹ˆë‹¤
- Resume ê°’ìœ¼ë¡œ JSON ì§ë ¬í™” ê°€ëŠ¥í•œ ëª¨ë“  ê°’ì„ ì „ë‹¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤

## ì¼ë°˜ì ì¸ íŒ¨í„´

Interruptê°€ ê°€ëŠ¥í•˜ê²Œ í•˜ëŠ” í•µì‹¬ì€ ì‹¤í–‰ì„ ì¼ì‹œ ì¤‘ì§€í•˜ê³  ì™¸ë¶€ ì…ë ¥ì„ ê¸°ë‹¤ë¦¬ëŠ” ëŠ¥ë ¥ì…ë‹ˆë‹¤. ì´ëŠ” ë‹¤ìŒì„ í¬í•¨í•œ ë‹¤ì–‘í•œ ì‚¬ìš© ì‚¬ë¡€ì— ìœ ìš©í•©ë‹ˆë‹¤:

- <Icon icon="check-circle" /> [ìŠ¹ì¸ ì›Œí¬í”Œë¡œìš°](#approve-or-reject): ì¤‘ìš”í•œ ì‘ì—…(API í˜¸ì¶œ, ë°ì´í„°ë² ì´ìŠ¤ ë³€ê²½, ê¸ˆìœµ ê±°ë˜) ì‹¤í–‰ ì „ì— ì¼ì‹œ ì¤‘ì§€
- <Icon icon="pencil" /> [ê²€í†  ë° í¸ì§‘](#review-and-edit-state): ê³„ì†í•˜ê¸° ì „ì— ì‚¬ëŒì´ LLM ì¶œë ¥ì´ë‚˜ tool í˜¸ì¶œì„ ê²€í† í•˜ê³  ìˆ˜ì •í•˜ë„ë¡ í—ˆìš©
- <Icon icon="wrench" /> [Tool í˜¸ì¶œ ì¤‘ë‹¨](#interrupts-in-tools): Tool í˜¸ì¶œ ì‹¤í–‰ ì „ì— ì¼ì‹œ ì¤‘ì§€í•˜ì—¬ ì‹¤í–‰ ì „ì— tool í˜¸ì¶œì„ ê²€í† í•˜ê³  í¸ì§‘
- <Icon icon="shield-check" /> [ì‚¬ìš©ì ì…ë ¥ ê²€ì¦](#validating-human-input): ë‹¤ìŒ ë‹¨ê³„ë¡œ ì§„í–‰í•˜ê¸° ì „ì— ì¼ì‹œ ì¤‘ì§€í•˜ì—¬ ì‚¬ìš©ì ì…ë ¥ ê²€ì¦

### ìŠ¹ì¸ ë˜ëŠ” ê±°ë¶€

Interruptì˜ ê°€ì¥ ì¼ë°˜ì ì¸ ì‚¬ìš© ì‚¬ë¡€ ì¤‘ í•˜ë‚˜ëŠ” ì¤‘ìš”í•œ ì‘ì—… ì „ì— ì¼ì‹œ ì¤‘ì§€í•˜ê³  ìŠ¹ì¸ì„ ìš”ì²­í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, API í˜¸ì¶œ, ë°ì´í„°ë² ì´ìŠ¤ ë³€ê²½ ë˜ëŠ” ê¸°íƒ€ ì¤‘ìš”í•œ ê²°ì •ì„ ìŠ¹ì¸í•˜ë„ë¡ ì‚¬ëŒì—ê²Œ ìš”ì²­í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

:::python
```python
from typing import Literal
from langgraph.types import interrupt, Command

def approval_node(state: State) -> Command[Literal["proceed", "cancel"]]:
    # Pause execution; payload shows up under result["__interrupt__"]
    is_approved = interrupt({
        "question": "Do you want to proceed with this action?",
        "details": state["action_details"]
    })

    # Route based on the response
    if is_approved:
        return Command(goto="proceed")  # Runs after the resume payload is provided
    else:
        return Command(goto="cancel")
```
:::

:::js
```typescript
import { interrupt, Command } from "@langchain/langgraph";

function approvalNode(state: State): Command {
  // Pause execution; payload surfaces in result.__interrupt__
  const isApproved = interrupt({
    question: "Do you want to proceed?",
    details: state.actionDetails
  });

  // Route based on the response
  if (isApproved) {
    return new Command({ goto: "proceed" }); // Runs after the resume payload is provided
  } else {
    return new Command({ goto: "cancel" });
  }
}
```
:::

Graphë¥¼ ì¬ê°œí•  ë•Œ ìŠ¹ì¸í•˜ë ¤ë©´ `true`ë¥¼, ê±°ë¶€í•˜ë ¤ë©´ `false`ë¥¼ ì „ë‹¬í•©ë‹ˆë‹¤:

:::python
```python
# To approve
graph.invoke(Command(resume=True), config=config)

# To reject
graph.invoke(Command(resume=False), config=config)
```
:::

:::js
```typescript
// To approve
await graph.invoke(new Command({ resume: true }), config);

// To reject
await graph.invoke(new Command({ resume: false }), config);
```
:::

<Accordion title="ì „ì²´ ì˜ˆì œ">
    :::python

    ```python
    import sqlite3
    from typing import Literal, Optional, TypedDict

    from langgraph.checkpoint.memory import MemorySaver
    from langgraph.graph import StateGraph, START, END
    from langgraph.types import Command, interrupt


    class ApprovalState(TypedDict):
        action_details: str
        status: Optional[Literal["pending", "approved", "rejected"]]


    def approval_node(state: ApprovalState) -> Command[Literal["proceed", "cancel"]]:
        # Expose details so the caller can render them in a UI
        decision = interrupt({
            "question": "Approve this action?",
            "details": state["action_details"],
        })

        # Route to the appropriate node after resume
        return Command(goto="proceed" if decision else "cancel")


    def proceed_node(state: ApprovalState):
        return {"status": "approved"}


    def cancel_node(state: ApprovalState):
        return {"status": "rejected"}


    builder = StateGraph(ApprovalState)
    builder.add_node("approval", approval_node)
    builder.add_node("proceed", proceed_node)
    builder.add_node("cancel", cancel_node)
    builder.add_edge(START, "approval")
    builder.add_edge("approval", "proceed")
    builder.add_edge("approval", "cancel")
    builder.add_edge("proceed", END)
    builder.add_edge("cancel", END)

    # Use a more durable checkpointer in production
    checkpointer = MemorySaver()
    graph = builder.compile(checkpointer=checkpointer)

    config = {"configurable": {"thread_id": "approval-123"}}
    initial = graph.invoke(
        {"action_details": "Transfer $500", "status": "pending"},
        config=config,
    )
    print(initial["__interrupt__"])  # -> [Interrupt(value={'question': ..., 'details': ...})]

    # Resume with the decision; True routes to proceed, False to cancel
    resumed = graph.invoke(Command(resume=True), config=config)
    print(resumed["status"])  # -> "approved"
    ```
    :::

    :::js

    ```typescript
    import {
      Command,
      MemorySaver,
      START,
      END,
      StateGraph,
      interrupt,
    } from "@langchain/langgraph";
    import * as z from "zod";

    const State = z.object({
      actionDetails: z.string(),
      status: z.enum(["pending", "approved", "rejected"]).nullable(),
    });

    const graphBuilder = new StateGraph(State)
      .addNode("approval", async (state) => {
        // Expose details so the caller can render them in a UI
        const decision = interrupt({
          question: "Approve this action?",
          details: state.actionDetails,
        });
        return new Command({ goto: decision ? "proceed" : "cancel" });
      }, { ends: ['proceed', 'cancel'] })
      .addNode("proceed", () => ({ status: "approved" }))
      .addNode("cancel", () => ({ status: "rejected" }))
      .addEdge(START, "approval")
      .addEdge("proceed", END)
      .addEdge("cancel", END);

    // Use a more durable checkpointer in production
    const checkpointer = new MemorySaver();
    const graph = graphBuilder.compile({ checkpointer });

    const config = { configurable: { thread_id: "approval-123" } };
    const initial = await graph.invoke(
      { actionDetails: "Transfer $500", status: "pending" },
      config,
    );
    console.log(initial.__interrupt__);
    // [{ value: { question: ..., details: ... } }]

    // Resume with the decision; true routes to proceed, false to cancel
    const resumed = await graph.invoke(new Command({ resume: true }), config);
    console.log(resumed.status); // -> "approved"
    ```
    :::

</Accordion>

### ìƒíƒœ ê²€í†  ë° í¸ì§‘

ë•Œë¡œëŠ” ê³„ì†í•˜ê¸° ì „ì— ì‚¬ëŒì´ graph ìƒíƒœì˜ ì¼ë¶€ë¥¼ ê²€í† í•˜ê³  í¸ì§‘í•˜ë„ë¡ í•˜ê³  ì‹¶ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” LLMì„ ìˆ˜ì •í•˜ê±°ë‚˜, ëˆ„ë½ëœ ì •ë³´ë¥¼ ì¶”ê°€í•˜ê±°ë‚˜, ì¡°ì •ì„ í•˜ëŠ” ë° ìœ ìš©í•©ë‹ˆë‹¤.

:::python
```python
from langgraph.types import interrupt

def review_node(state: State):
    # Pause and show the current content for review (surfaces in result["__interrupt__"])
    edited_content = interrupt({
        "instruction": "Review and edit this content",
        "content": state["generated_text"]
    })

    # Update the state with the edited version
    return {"generated_text": edited_content}
```
:::

:::js
```typescript
import { interrupt } from "@langchain/langgraph";

function reviewNode(state: State) {
  // Pause and show the current content for review (surfaces in result.__interrupt__)
  const editedContent = interrupt({
    instruction: "Review and edit this content",
    content: state.generatedText
  });

  // Update the state with the edited version
  return { generatedText: editedContent };
}
```
:::

ì¬ê°œí•  ë•Œ í¸ì§‘ëœ ë‚´ìš©ì„ ì œê³µí•©ë‹ˆë‹¤:

:::python
```python
graph.invoke(
    Command(resume="The edited and improved text"),  # Value becomes the return from interrupt()
    config=config
)
```
:::

:::js
```typescript
await graph.invoke(
  new Command({ resume: "The edited and improved text" }), // Value becomes the return from interrupt()
  config
);
```
:::

<Accordion title="ì „ì²´ ì˜ˆì œ">
    :::python

    ```python
    import sqlite3
    from typing import TypedDict

    from langgraph.checkpoint.memory import MemorySaver
    from langgraph.graph import StateGraph, START, END
    from langgraph.types import Command, interrupt


    class ReviewState(TypedDict):
        generated_text: str


    def review_node(state: ReviewState):
        # Ask a reviewer to edit the generated content
        updated = interrupt({
            "instruction": "Review and edit this content",
            "content": state["generated_text"],
        })
        return {"generated_text": updated}


    builder = StateGraph(ReviewState)
    builder.add_node("review", review_node)
    builder.add_edge(START, "review")
    builder.add_edge("review", END)

    checkpointer = MemorySaver()
    graph = builder.compile(checkpointer=checkpointer)

    config = {"configurable": {"thread_id": "review-42"}}
    initial = graph.invoke({"generated_text": "Initial draft"}, config=config)
    print(initial["__interrupt__"])  # -> [Interrupt(value={'instruction': ..., 'content': ...})]

    # Resume with the edited text from the reviewer
    final_state = graph.invoke(
        Command(resume="Improved draft after review"),
        config=config,
    )
    print(final_state["generated_text"])  # -> "Improved draft after review"
    ```
    :::

    :::js

    ```typescript
    import {
      Command,
      MemorySaver,
      START,
      END,
      StateGraph,
      interrupt,
    } from "@langchain/langgraph";
    import * as z from "zod";

    const State = z.object({
      generatedText: z.string(),
    });

    const builder = new StateGraph(State)
      .addNode("review", async (state) => {
        // Ask a reviewer to edit the generated content
        const updated = interrupt({
          instruction: "Review and edit this content",
          content: state.generatedText,
        });
        return { generatedText: updated };
      })
      .addEdge(START, "review")
      .addEdge("review", END);

    const checkpointer = new MemorySaver();
    const graph = builder.compile({ checkpointer });

    const config = { configurable: { thread_id: "review-42" } };
    const initial = await graph.invoke({ generatedText: "Initial draft" }, config);
    console.log(initial.__interrupt__);
    // [{ value: { instruction: ..., content: ... } }]

    // Resume with the edited text from the reviewer
    const finalState = await graph.invoke(
      new Command({ resume: "Improved draft after review" }),
      config,
    );
    console.log(finalState.generatedText); // -> "Improved draft after review"
    ```
    :::

</Accordion>

### Toolì—ì„œì˜ Interrupt

Tool í•¨ìˆ˜ ë‚´ë¶€ì— ì§ì ‘ interruptë¥¼ ë°°ì¹˜í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ toolì´ í˜¸ì¶œë  ë•Œë§ˆë‹¤ tool ìì²´ê°€ ìŠ¹ì¸ì„ ìœ„í•´ ì¼ì‹œ ì¤‘ì§€ë˜ë©°, ì‹¤í–‰ ì „ì— tool í˜¸ì¶œì„ ì‚¬ëŒì´ ê²€í† í•˜ê³  í¸ì§‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë¨¼ì € @[`interrupt`]ë¥¼ ì‚¬ìš©í•˜ëŠ” toolì„ ì •ì˜í•©ë‹ˆë‹¤:

:::python
```python
from langchain.tools import tool
from langgraph.types import interrupt

@tool
def send_email(to: str, subject: str, body: str):
    """Send an email to a recipient."""

    # Pause before sending; payload surfaces in result["__interrupt__"]
    response = interrupt({
        "action": "send_email",
        "to": to,
        "subject": subject,
        "body": body,
        "message": "Approve sending this email?"
    })

    if response.get("action") == "approve":
        # Resume value can override inputs before executing
        final_to = response.get("to", to)
        final_subject = response.get("subject", subject)
        final_body = response.get("body", body)
        return f"Email sent to {final_to} with subject '{final_subject}'"
    return "Email cancelled by user"
```
:::

:::js
```typescript
import { tool } from "@langchain/core/tools";
import { interrupt } from "@langchain/langgraph";
import * as z from "zod";

const sendEmailTool = tool(
  async ({ to, subject, body }) => {
    // Pause before sending; payload surfaces in result.__interrupt__
    const response = interrupt({
      action: "send_email",
      to,
      subject,
      body,
      message: "Approve sending this email?",
    });

    if (response?.action === "approve") {
      // Resume value can override inputs before executing
      const finalTo = response.to ?? to;
      const finalSubject = response.subject ?? subject;
      const finalBody = response.body ?? body;
      return `Email sent to ${finalTo} with subject '${finalSubject}'`;
    }
    return "Email cancelled by user";
  },
  {
    name: "send_email",
    description: "Send an email to a recipient",
    schema: z.object({
      to: z.string(),
      subject: z.string(),
      body: z.string(),
    }),
  },
);
```
:::

ì´ ì ‘ê·¼ ë°©ì‹ì€ ìŠ¹ì¸ ë¡œì§ì´ tool ìì²´ì— ìˆì–´ graphì˜ ë‹¤ë¥¸ ë¶€ë¶„ì—ì„œ ì¬ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ í•˜ë ¤ëŠ” ê²½ìš°ì— ìœ ìš©í•©ë‹ˆë‹¤. LLMì€ toolì„ ìì—°ìŠ¤ëŸ½ê²Œ í˜¸ì¶œí•  ìˆ˜ ìˆìœ¼ë©°, toolì´ í˜¸ì¶œë  ë•Œë§ˆë‹¤ interruptê°€ ì‹¤í–‰ì„ ì¼ì‹œ ì¤‘ì§€í•˜ì—¬ ì‘ì—…ì„ ìŠ¹ì¸, í¸ì§‘ ë˜ëŠ” ì·¨ì†Œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

<Accordion title="ì „ì²´ ì˜ˆì œ">
    :::python

    ```python
    import sqlite3
    from typing import TypedDict

    from langchain.tools import tool
    from langchain_anthropic import ChatAnthropic
    from langgraph.checkpoint.sqlite import SqliteSaver
    from langgraph.graph import StateGraph, START, END
    from langgraph.types import Command, interrupt


    class AgentState(TypedDict):
        messages: list[dict]


    @tool
    def send_email(to: str, subject: str, body: str):
        """Send an email to a recipient."""

        # Pause before sending; payload surfaces in result["__interrupt__"]
        response = interrupt({
            "action": "send_email",
            "to": to,
            "subject": subject,
            "body": body,
            "message": "Approve sending this email?",
        })

        if response.get("action") == "approve":
            final_to = response.get("to", to)
            final_subject = response.get("subject", subject)
            final_body = response.get("body", body)

            # Actually send the email (your implementation here)
            print(f"[send_email] to={final_to} subject={final_subject} body={final_body}")
            return f"Email sent to {final_to}"

        return "Email cancelled by user"


    model = ChatAnthropic(model="claude-sonnet-4-5").bind_tools([send_email])


    def agent_node(state: AgentState):
        # LLM may decide to call the tool; interrupt pauses before sending
        result = model.invoke(state["messages"])
        return {"messages": state["messages"] + [result]}


    builder = StateGraph(AgentState)
    builder.add_node("agent", agent_node)
    builder.add_edge(START, "agent")
    builder.add_edge("agent", END)

    checkpointer = SqliteSaver(sqlite3.connect("tool-approval.db"))
    graph = builder.compile(checkpointer=checkpointer)

    config = {"configurable": {"thread_id": "email-workflow"}}
    initial = graph.invoke(
        {
            "messages": [
                {"role": "user", "content": "Send an email to alice@example.com about the meeting"}
            ]
        },
        config=config,
    )
    print(initial["__interrupt__"])  # -> [Interrupt(value={'action': 'send_email', ...})]

    # Resume with approval and optionally edited arguments
    resumed = graph.invoke(
        Command(resume={"action": "approve", "subject": "Updated subject"}),
        config=config,
    )
    print(resumed["messages"][-1])  # -> Tool result returned by send_email
    ```
    :::

    :::js

    ```typescript
    import { tool } from "@langchain/core/tools";
    import { ChatAnthropic } from "@langchain/anthropic";
    import {
      Command,
      MemorySaver,
      START,
      END,
      StateGraph,
      interrupt,
    } from "@langchain/langgraph";
    import * as z from "zod";

    const sendEmailTool = tool(
      async ({ to, subject, body }) => {
        // Pause before sending; payload surfaces in result.__interrupt__
        const response = interrupt({
          action: "send_email",
          to,
          subject,
          body,
          message: "Approve sending this email?",
        });

        if (response?.action === "approve") {
          const finalTo = response.to ?? to;
          const finalSubject = response.subject ?? subject;
          const finalBody = response.body ?? body;
          console.log("[sendEmailTool]", finalTo, finalSubject, finalBody);
          return `Email sent to ${finalTo}`;
        }
        return "Email cancelled by user";
      },
      {
        name: "send_email",
        description: "Send an email to a recipient",
        schema: z.object({
          to: z.string(),
          subject: z.string(),
          body: z.string(),
        }),
      },
    );

    const model = new ChatAnthropic({ model: "claude-sonnet-4-5" }).bindTools([sendEmailTool]);

    const Message = z.object({
      role: z.enum(["user", "assistant", "tool"]),
      content: z.string(),
    });

    const State = z.object({
      messages: z.array(Message),
    });

    const graphBuilder = new StateGraph(State)
      .addNode("agent", async (state) => {
        // LLM may decide to call the tool; interrupt pauses before sending
        const response = await model.invoke(state.messages);
        return { messages: [...state.messages, response] };
      })
      .addEdge(START, "agent")
      .addEdge("agent", END);

    const checkpointer = new MemorySaver();
    const graph = graphBuilder.compile({ checkpointer });

    const config = { configurable: { thread_id: "email-workflow" } };
    const initial = await graph.invoke(
      {
        messages: [
          { role: "user", content: "Send an email to alice@example.com about the meeting" },
        ],
      },
      config,
    );
    console.log(initial.__interrupt__); // -> [{ value: { action: 'send_email', ... } }]

    // Resume with approval and optionally edited arguments
    const resumed = await graph.invoke(
      new Command({
        resume: { action: "approve", subject: "Updated subject" },
      }),
      config,
    );
    console.log(resumed.messages.at(-1)); // -> Tool result returned by send_email
    ```
    :::

</Accordion>

### ì‚¬ìš©ì ì…ë ¥ ê²€ì¦

ë•Œë¡œëŠ” ì‚¬ëŒì˜ ì…ë ¥ì„ ê²€ì¦í•˜ê³  ìœ íš¨í•˜ì§€ ì•Šìœ¼ë©´ ë‹¤ì‹œ ìš”ì²­í•´ì•¼ í•©ë‹ˆë‹¤. ë£¨í”„ì—ì„œ ì—¬ëŸ¬ @[`interrupt`] í˜¸ì¶œì„ ì‚¬ìš©í•˜ì—¬ ì´ë¥¼ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

:::python
```python
from langgraph.types import interrupt

def get_age_node(state: State):
    prompt = "What is your age?"

    while True:
        answer = interrupt(prompt)  # payload surfaces in result["__interrupt__"]

        # Validate the input
        if isinstance(answer, int) and answer > 0:
            # Valid input - continue
            break
        else:
            # Invalid input - ask again with a more specific prompt
            prompt = f"'{answer}' is not a valid age. Please enter a positive number."

    return {"age": answer}
```
:::

:::js
```typescript
import { interrupt } from "@langchain/langgraph";

function getAgeNode(state: State) {
  let prompt = "What is your age?";

  while (true) {
    const answer = interrupt(prompt); // payload surfaces in result.__interrupt__

    // Validate the input
    if (typeof answer === "number" && answer > 0) {
      // Valid input - continue
      return { age: answer };
    } else {
      // Invalid input - ask again with a more specific prompt
      prompt = `'${answer}' is not a valid age. Please enter a positive number.`;
    }
  }
}
```
:::

ìœ íš¨í•˜ì§€ ì•Šì€ ì…ë ¥ìœ¼ë¡œ graphë¥¼ ì¬ê°œí•  ë•Œë§ˆë‹¤ ë” ëª…í™•í•œ ë©”ì‹œì§€ì™€ í•¨ê»˜ ë‹¤ì‹œ ìš”ì²­í•©ë‹ˆë‹¤. ìœ íš¨í•œ ì…ë ¥ì´ ì œê³µë˜ë©´ nodeê°€ ì™„ë£Œë˜ê³  graphê°€ ê³„ì†ë©ë‹ˆë‹¤.

<Accordion title="ì „ì²´ ì˜ˆì œ">
    :::python

    ```python
    import sqlite3
    from typing import TypedDict

    from langgraph.checkpoint.sqlite import SqliteSaver
    from langgraph.graph import StateGraph, START, END
    from langgraph.types import Command, interrupt


    class FormState(TypedDict):
        age: int | None


    def get_age_node(state: FormState):
        prompt = "What is your age?"

        while True:
            answer = interrupt(prompt)  # payload surfaces in result["__interrupt__"]

            if isinstance(answer, int) and answer > 0:
                return {"age": answer}

            prompt = f"'{answer}' is not a valid age. Please enter a positive number."


    builder = StateGraph(FormState)
    builder.add_node("collect_age", get_age_node)
    builder.add_edge(START, "collect_age")
    builder.add_edge("collect_age", END)

    checkpointer = SqliteSaver(sqlite3.connect("forms.db"))
    graph = builder.compile(checkpointer=checkpointer)

    config = {"configurable": {"thread_id": "form-1"}}
    first = graph.invoke({"age": None}, config=config)
    print(first["__interrupt__"])  # -> [Interrupt(value='What is your age?', ...)]

    # Provide invalid data; the node re-prompts
    retry = graph.invoke(Command(resume="thirty"), config=config)
    print(retry["__interrupt__"])  # -> [Interrupt(value="'thirty' is not a valid age...", ...)]

    # Provide valid data; loop exits and state updates
    final = graph.invoke(Command(resume=30), config=config)
    print(final["age"])  # -> 30
    ```
    :::

    :::js

    ```typescript
    import {
      Command,
      MemorySaver,
      START,
      END,
      StateGraph,
      interrupt,
    } from "@langchain/langgraph";
    import * as z from "zod";

    const State = z.object({
      age: z.number().nullable(),
    });

    const builder = new StateGraph(State)
      .addNode("collectAge", (state) => {
        let prompt = "What is your age?";

        while (true) {
          const answer = interrupt(prompt); // payload surfaces in result.__interrupt__

          if (typeof answer === "number" && answer > 0) {
            return { age: answer };
          }

          prompt = `'${answer}' is not a valid age. Please enter a positive number.`;
        }
      })
      .addEdge(START, "collectAge")
      .addEdge("collectAge", END);

    const checkpointer = new MemorySaver();
    const graph = builder.compile({ checkpointer });

    const config = { configurable: { thread_id: "form-1" } };
    const first = await graph.invoke({ age: null }, config);
    console.log(first.__interrupt__); // -> [{ value: "What is your age?", ... }]

    // Provide invalid data; the node re-prompts
    const retry = await graph.invoke(new Command({ resume: "thirty" }), config);
    console.log(retry.__interrupt__); // -> [{ value: "'thirty' is not a valid age...", ... }]

    // Provide valid data; loop exits and state updates
    const final = await graph.invoke(new Command({ resume: 30 }), config);
    console.log(final.age); // -> 30
    ```
    :::

</Accordion>

## Interrupt ê·œì¹™

Node ë‚´ì—ì„œ @[`interrupt`]ë¥¼ í˜¸ì¶œí•˜ë©´ LangGraphëŠ” runtimeì— ì¼ì‹œ ì¤‘ì§€í•˜ë¼ëŠ” ì‹ í˜¸ë¥¼ ë³´ë‚´ëŠ” ì˜ˆì™¸ë¥¼ ë°œìƒì‹œì¼œ ì‹¤í–‰ì„ ì¤‘ë‹¨í•©ë‹ˆë‹¤. ì´ ì˜ˆì™¸ëŠ” í˜¸ì¶œ ìŠ¤íƒì„ í†µí•´ ì „íŒŒë˜ê³  runtimeì— ì˜í•´ í¬ì°©ë˜ì–´ graphì— í˜„ì¬ ìƒíƒœë¥¼ ì €ì¥í•˜ê³  ì™¸ë¶€ ì…ë ¥ì„ ê¸°ë‹¤ë¦¬ë„ë¡ ì•Œë¦½ë‹ˆë‹¤.

ì‹¤í–‰ì´ ì¬ê°œë˜ë©´(ìš”ì²­ëœ ì…ë ¥ì„ ì œê³µí•œ í›„), runtimeì€ ì „ì²´ nodeë¥¼ ì²˜ìŒë¶€í„° ë‹¤ì‹œ ì‹œì‘í•©ë‹ˆë‹¤â€”@[`interrupt`]ê°€ í˜¸ì¶œëœ ì •í™•í•œ ì¤„ì—ì„œ ì¬ê°œí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì¦‰, @[`interrupt`] ì´ì „ì— ì‹¤í–‰ëœ ëª¨ë“  ì½”ë“œê°€ ë‹¤ì‹œ ì‹¤í–‰ë©ë‹ˆë‹¤. ë”°ë¼ì„œ interruptê°€ ì˜ˆìƒëŒ€ë¡œ ì‘ë™í•˜ë„ë¡ í•˜ë ¤ë©´ ë”°ë¼ì•¼ í•  ëª‡ ê°€ì§€ ì¤‘ìš”í•œ ê·œì¹™ì´ ìˆìŠµë‹ˆë‹¤.

:::python
### `interrupt` í˜¸ì¶œì„ try/exceptë¡œ ê°ì‹¸ì§€ ë§ˆì„¸ìš”

@[`interrupt`]ê°€ í˜¸ì¶œ ì§€ì ì—ì„œ ì‹¤í–‰ì„ ì¼ì‹œ ì¤‘ì§€í•˜ëŠ” ë°©ì‹ì€ íŠ¹ìˆ˜ ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚¤ëŠ” ê²ƒì…ë‹ˆë‹¤. @[`interrupt`] í˜¸ì¶œì„ try/except ë¸”ë¡ìœ¼ë¡œ ê°ì‹¸ë©´ ì´ ì˜ˆì™¸ë¥¼ í¬ì°©í•˜ê²Œ ë˜ì–´ interruptê°€ graphë¡œ ë‹¤ì‹œ ì „ë‹¬ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

* âœ… @[`interrupt`] í˜¸ì¶œì„ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ê¸° ì‰¬ìš´ ì½”ë“œì™€ ë¶„ë¦¬í•˜ì„¸ìš”
* âœ… try/except ë¸”ë¡ì—ì„œ íŠ¹ì • ì˜ˆì™¸ íƒ€ì…ì„ ì‚¬ìš©í•˜ì„¸ìš”

<CodeGroup>
```python Separating logic
def node_a(state: State):
    # âœ… Good: interrupting first, then handling
    # error conditions separately
    interrupt("What's your name?")
    try:
        fetch_data()  # This can fail
    except Exception as e:
        print(e)
    return state
```
```python Explicit exception handling
def node_a(state: State):
    # âœ… Good: catching specific exception types
    # will not catch the interrupt exception
    try:
        name = interrupt("What's your name?")
        fetch_data()  # This can fail
    except NetworkException as e:
        print(e)
    return state
```
</CodeGroup>

* ğŸ”´ @[`interrupt`] í˜¸ì¶œì„ ì¼ë°˜ try/except ë¸”ë¡ìœ¼ë¡œ ê°ì‹¸ì§€ ë§ˆì„¸ìš”

```python
def node_a(state: State):
    # âŒ Bad: wrapping interrupt in bare try/except
    # will catch the interrupt exception
    try:
        interrupt("What's your name?")
    except Exception as e:
        print(e)
    return state
```
:::

:::js
### `interrupt` í˜¸ì¶œì„ try/catchë¡œ ê°ì‹¸ì§€ ë§ˆì„¸ìš”

@[`interrupt`]ê°€ í˜¸ì¶œ ì§€ì ì—ì„œ ì‹¤í–‰ì„ ì¼ì‹œ ì¤‘ì§€í•˜ëŠ” ë°©ì‹ì€ íŠ¹ìˆ˜ ì˜ˆì™¸ë¥¼ ë°œìƒì‹œí‚¤ëŠ” ê²ƒì…ë‹ˆë‹¤. @[`interrupt`] í˜¸ì¶œì„ try/catch ë¸”ë¡ìœ¼ë¡œ ê°ì‹¸ë©´ ì´ ì˜ˆì™¸ë¥¼ í¬ì°©í•˜ê²Œ ë˜ì–´ interruptê°€ graphë¡œ ë‹¤ì‹œ ì „ë‹¬ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

* âœ… @[`interrupt`] í˜¸ì¶œì„ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ê¸° ì‰¬ìš´ ì½”ë“œì™€ ë¶„ë¦¬í•˜ì„¸ìš”
* âœ… í•„ìš”í•œ ê²½ìš° ì¡°ê±´ë¶€ë¡œ ì˜¤ë¥˜ë¥¼ í¬ì°©í•˜ì„¸ìš”

<CodeGroup>
```typescript Separating logic
async function nodeA(state: State) {
    // âœ… Good: interrupting first, then handling error conditions separately
    const name = interrupt("What's your name?");
    try {
        await fetchData(); // This can fail
    } catch (err) {
        console.error(error);
    }
    return state;
}
```
```typescript Conditionally handling errors
async function nodeA(state: State) {
    // âœ… Good: re-throwing the exception will
    // allow the interrupt to be passed back to
    // the graph
    try {
        const name = interrupt("What's your name?");
        await fetchData(); // This can fail
    } catch (err) {
        if (error instanceof NetworkError) {
            console.error(error);
        }
        throw error;
    }
    return state;
}
```
</CodeGroup>

* ğŸ”´ @[`interrupt`] í˜¸ì¶œì„ ì¼ë°˜ try/catch ë¸”ë¡ìœ¼ë¡œ ê°ì‹¸ì§€ ë§ˆì„¸ìš”

```typescript
async function nodeA(state: State) {
    // âŒ Bad: wrapping interrupt in bare try/catch will catch the interrupt exception
    try {
        const name = interrupt("What's your name?");
    } catch (err) {
        console.error(error);
    }
    return state;
}
```
:::

### Node ë‚´ì—ì„œ `interrupt` í˜¸ì¶œ ìˆœì„œë¥¼ ë³€ê²½í•˜ì§€ ë§ˆì„¸ìš”

ë‹¨ì¼ nodeì—ì„œ ì—¬ëŸ¬ interruptë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì€ ì¼ë°˜ì ì´ì§€ë§Œ, ì£¼ì˜í•˜ì§€ ì•Šìœ¼ë©´ ì˜ˆìƒì¹˜ ëª»í•œ ë™ì‘ì´ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

Nodeì— ì—¬ëŸ¬ interrupt í˜¸ì¶œì´ í¬í•¨ë˜ì–´ ìˆìœ¼ë©´ LangGraphëŠ” nodeë¥¼ ì‹¤í–‰í•˜ëŠ” taskì— íŠ¹ì •í•œ resume ê°’ ëª©ë¡ì„ ìœ ì§€í•©ë‹ˆë‹¤. ì‹¤í–‰ì´ ì¬ê°œë  ë•Œë§ˆë‹¤ nodeì˜ ì‹œì‘ ë¶€ë¶„ì—ì„œ ì‹œì‘ë©ë‹ˆë‹¤. ê° interruptê°€ ë°œìƒí•  ë•Œë§ˆë‹¤ LangGraphëŠ” taskì˜ resume ëª©ë¡ì— ì¼ì¹˜í•˜ëŠ” ê°’ì´ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤. ì¼ì¹˜ëŠ” **ì—„ê²©í•˜ê²Œ ì¸ë±ìŠ¤ ê¸°ë°˜**ì´ë¯€ë¡œ node ë‚´ interrupt í˜¸ì¶œì˜ ìˆœì„œê°€ ì¤‘ìš”í•©ë‹ˆë‹¤.

* âœ… Node ì‹¤í–‰ ì „ë°˜ì— ê±¸ì³ @[`interrupt`] í˜¸ì¶œì„ ì¼ê´€ë˜ê²Œ ìœ ì§€í•˜ì„¸ìš”

:::python
```python
def node_a(state: State):
    # âœ… Good: interrupt calls happen in the same order every time
    name = interrupt("What's your name?")
    age = interrupt("What's your age?")
    city = interrupt("What's your city?")

    return {
        "name": name,
        "age": age,
        "city": city
    }
```
:::
:::js
```typescript
async function nodeA(state: State) {
    // âœ… Good: interrupt calls happen in the same order every time
    const name = interrupt("What's your name?");
    const age = interrupt("What's your age?");
    const city = interrupt("What's your city?");

    return {
        name,
        age,
        city
    };
}
```
:::

* ğŸ”´ Node ë‚´ì—ì„œ ì¡°ê±´ë¶€ë¡œ @[`interrupt`] í˜¸ì¶œì„ ê±´ë„ˆë›°ì§€ ë§ˆì„¸ìš”
* ğŸ”´ ì‹¤í–‰ ì „ë°˜ì— ê±¸ì³ ê²°ì •ì ì´ì§€ ì•Šì€ ë¡œì§ì„ ì‚¬ìš©í•˜ì—¬ @[`interrupt`] í˜¸ì¶œì„ ë°˜ë³µí•˜ì§€ ë§ˆì„¸ìš”

:::python
<CodeGroup>
```python Skipping interrupts
def node_a(state: State):
    # âŒ Bad: conditionally skipping interrupts changes the order
    name = interrupt("What's your name?")

    # On first run, this might skip the interrupt
    # On resume, it might not skip it - causing index mismatch
    if state.get("needs_age"):
        age = interrupt("What's your age?")

    city = interrupt("What's your city?")

    return {"name": name, "city": city}
```
```python Looping interrupts
def node_a(state: State):
    # âŒ Bad: looping based on non-deterministic data
    # The number of interrupts changes between executions
    results = []
    for item in state.get("dynamic_list", []):  # List might change between runs
        result = interrupt(f"Approve {item}?")
        results.append(result)

    return {"results": results}
```
</CodeGroup>
:::
:::js
<CodeGroup>
```typescript Skipping interrupts
async function nodeA(state: State) {
    // âŒ Bad: conditionally skipping interrupts changes the order
    const name = interrupt("What's your name?");

    // On first run, this might skip the interrupt
    // On resume, it might not skip it - causing index mismatch
    if (state.needsAge) {
        const age = interrupt("What's your age?");
    }

    const city = interrupt("What's your city?");

    return { name, city };
}
```
```typescript Looping interrupts
async function nodeA(state: State) {
    // âŒ Bad: looping based on non-deterministic data
    // The number of interrupts changes between executions
    const results = [];
    for (const item of state.dynamicList || []) {  // List might change between runs
        const result = interrupt(`Approve ${item}?`);
        results.push(result);
    }

    return { results };
}
```
</CodeGroup>
:::

### `interrupt` í˜¸ì¶œì—ì„œ ë³µì¡í•œ ê°’ì„ ë°˜í™˜í•˜ì§€ ë§ˆì„¸ìš”

ì‚¬ìš©ë˜ëŠ” checkpointerì— ë”°ë¼ ë³µì¡í•œ ê°’ì€ ì§ë ¬í™”í•  ìˆ˜ ì—†ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤(ì˜ˆ: í•¨ìˆ˜ë¥¼ ì§ë ¬í™”í•  ìˆ˜ ì—†ìŒ). Graphë¥¼ ëª¨ë“  ë°°í¬ì— ì ì‘í•  ìˆ˜ ìˆë„ë¡ í•˜ë ¤ë©´ í•©ë¦¬ì ìœ¼ë¡œ ì§ë ¬í™”í•  ìˆ˜ ìˆëŠ” ê°’ë§Œ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.

* âœ… @[`interrupt`]ì— ê°„ë‹¨í•œ JSON ì§ë ¬í™” ê°€ëŠ¥í•œ íƒ€ì…ì„ ì „ë‹¬í•˜ì„¸ìš”
* âœ… ê°„ë‹¨í•œ ê°’ì„ ê°€ì§„ dictionary/objectë¥¼ ì „ë‹¬í•˜ì„¸ìš”

:::python
<CodeGroup>
```python Simple values
def node_a(state: State):
    # âœ… Good: passing simple types that are serializable
    name = interrupt("What's your name?")
    count = interrupt(42)
    approved = interrupt(True)

    return {"name": name, "count": count, "approved": approved}
```
```python Structured data
def node_a(state: State):
    # âœ… Good: passing dictionaries with simple values
    response = interrupt({
        "question": "Enter user details",
        "fields": ["name", "email", "age"],
        "current_values": state.get("user", {})
    })

    return {"user": response}
```
</CodeGroup>
:::

:::js
<CodeGroup>
```typescript Simple values
async function nodeA(state: State) {
    // âœ… Good: passing simple types that are serializable
    const name = interrupt("What's your name?");
    const count = interrupt(42);
    const approved = interrupt(true);

    return { name, count, approved };
}
```
```typescript Structured data
async function nodeA(state: State) {
    // âœ… Good: passing objects with simple values
    const response = interrupt({
        question: "Enter user details",
        fields: ["name", "email", "age"],
        currentValues: state.user || {}
    });

    return { user: response };
}
```
</CodeGroup>
:::

* ğŸ”´ @[`interrupt`]ì— í•¨ìˆ˜, í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ ë˜ëŠ” ê¸°íƒ€ ë³µì¡í•œ ê°ì²´ë¥¼ ì „ë‹¬í•˜ì§€ ë§ˆì„¸ìš”

:::python
<CodeGroup>
```python Functions
def validate_input(value):
    return len(value) > 0

def node_a(state: State):
    # âŒ Bad: passing a function to interrupt
    # The function cannot be serialized
    response = interrupt({
        "question": "What's your name?",
        "validator": validate_input  # This will fail
    })
    return {"name": response}
```
```python Class instances
class DataProcessor:
    def __init__(self, config):
        self.config = config

def node_a(state: State):
    processor = DataProcessor({"mode": "strict"})

    # âŒ Bad: passing a class instance to interrupt
    # The instance cannot be serialized
    response = interrupt({
        "question": "Enter data to process",
        "processor": processor  # This will fail
    })
    return {"result": response}
```
</CodeGroup>
:::

:::js
<CodeGroup>
```typescript Functions
function validateInput(value: string): boolean {
    return value.length > 0;
}

async function nodeA(state: State) {
    // âŒ Bad: passing a function to interrupt
    // The function cannot be serialized
    const response = interrupt({
        question: "What's your name?",
        validator: validateInput  // This will fail
    });
    return { name: response };
}
```
```typescript Class instances
class DataProcessor {
    constructor(private config: any) {}
}

async function nodeA(state: State) {
    const processor = new DataProcessor({ mode: "strict" });

    // âŒ Bad: passing a class instance to interrupt
    // The instance cannot be serialized
    const response = interrupt({
        question: "Enter data to process",
        processor: processor  // This will fail
    });
    return { result: response };
}
```
</CodeGroup>
:::

### `interrupt` ì´ì „ì— í˜¸ì¶œëœ ë¶€ì‘ìš©ì€ ë©±ë“±ì„±ì´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤

InterruptëŠ” í˜¸ì¶œëœ nodeë¥¼ ë‹¤ì‹œ ì‹¤í–‰í•˜ì—¬ ì‘ë™í•˜ë¯€ë¡œ @[`interrupt`] ì´ì „ì— í˜¸ì¶œëœ ë¶€ì‘ìš©ì€ (ì´ìƒì ìœ¼ë¡œ) ë©±ë“±ì„±ì´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤. ì°¸ê³ ë¡œ, ë©±ë“±ì„±ì€ ë™ì¼í•œ ì‘ì—…ì„ ì—¬ëŸ¬ ë²ˆ ì ìš©í•´ë„ ì´ˆê¸° ì‹¤í–‰ ì´í›„ ê²°ê³¼ê°€ ë³€ê²½ë˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.

ì˜ˆë¥¼ ë“¤ì–´, node ë‚´ë¶€ì— ë ˆì½”ë“œë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ” API í˜¸ì¶œì´ ìˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•´ë‹¹ í˜¸ì¶œì´ ì´ë£¨ì–´ì§„ í›„ @[`interrupt`]ê°€ í˜¸ì¶œë˜ë©´ nodeê°€ ì¬ê°œë  ë•Œ ì—¬ëŸ¬ ë²ˆ ë‹¤ì‹œ ì‹¤í–‰ë˜ì–´ ì´ˆê¸° ì—…ë°ì´íŠ¸ë¥¼ ë®ì–´ì“°ê±°ë‚˜ ì¤‘ë³µ ë ˆì½”ë“œë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

* âœ… @[`interrupt`] ì´ì „ì— ë©±ë“±ì„± ì‘ì—…ì„ ì‚¬ìš©í•˜ì„¸ìš”
* âœ… @[`interrupt`] í˜¸ì¶œ ì´í›„ì— ë¶€ì‘ìš©ì„ ë°°ì¹˜í•˜ì„¸ìš”
* âœ… ê°€ëŠ¥í•œ ê²½ìš° ë¶€ì‘ìš©ì„ ë³„ë„ì˜ nodeë¡œ ë¶„ë¦¬í•˜ì„¸ìš”

:::python
<CodeGroup>
```python Idempotent operations
def node_a(state: State):
    # âœ… Good: using upsert operation which is idempotent
    # Running this multiple times will have the same result
    db.upsert_user(
        user_id=state["user_id"],
        status="pending_approval"
    )

    approved = interrupt("Approve this change?")

    return {"approved": approved}
```
```python Side effects after interrupt
def node_a(state: State):
    # âœ… Good: placing side effect after the interrupt
    # This ensures it only runs once after approval is received
    approved = interrupt("Approve this change?")

    if approved:
        db.create_audit_log(
            user_id=state["user_id"],
            action="approved"
        )

    return {"approved": approved}
```
```python Separating into different nodes
def approval_node(state: State):
    # âœ… Good: only handling the interrupt in this node
    approved = interrupt("Approve this change?")

    return {"approved": approved}

def notification_node(state: State):
    # âœ… Good: side effect happens in a separate node
    # This runs after approval, so it only executes once
    if (state.approved):
        send_notification(
            user_id=state["user_id"],
            status="approved"
        )

    return state
```
</CodeGroup>
:::

:::js
<CodeGroup>
```typescript Idempotent operations
async function nodeA(state: State) {
    // âœ… Good: using upsert operation which is idempotent
    // Running this multiple times will have the same result
    await db.upsertUser({
        userId: state.userId,
        status: "pending_approval"
    });

    const approved = interrupt("Approve this change?");

    return { approved };
}
```
```typescript Side effects after interrupt
async function nodeA(state: State) {
    // âœ… Good: placing side effect after the interrupt
    // This ensures it only runs once after approval is received
    const approved = interrupt("Approve this change?");

    if (approved) {
        await db.createAuditLog({
            userId: state.userId,
            action: "approved"
        });
    }

    return { approved };
}
```
```typescript Separating into different nodes
async function approvalNode(state: State) {
    // âœ… Good: only handling the interrupt in this node
    const approved = interrupt("Approve this change?");

    return { approved };
}

async function notificationNode(state: State) {
    // âœ… Good: side effect happens in a separate node
    // This runs after approval, so it only executes once
    if (state.approved) {
        await sendNotification({
            userId: state.userId,
            status: "approved"
        });
    }

    return state;
}
```
</CodeGroup>
:::

* ğŸ”´ @[`interrupt`] ì´ì „ì— ë©±ë“±ì„±ì´ ì—†ëŠ” ì‘ì—…ì„ ìˆ˜í–‰í•˜ì§€ ë§ˆì„¸ìš”
* ğŸ”´ ì¡´ì¬ ì—¬ë¶€ë¥¼ í™•ì¸í•˜ì§€ ì•Šê³  ìƒˆ ë ˆì½”ë“œë¥¼ ìƒì„±í•˜ì§€ ë§ˆì„¸ìš”

:::python
<CodeGroup>
```python Creating records
def node_a(state: State):
    # âŒ Bad: creating a new record before interrupt
    # This will create duplicate records on each resume
    audit_id = db.create_audit_log({
        "user_id": state["user_id"],
        "action": "pending_approval",
        "timestamp": datetime.now()
    })

    approved = interrupt("Approve this change?")

    return {"approved": approved, "audit_id": audit_id}
```
```python Appending to lists
def node_a(state: State):
    # âŒ Bad: appending to a list before interrupt
    # This will add duplicate entries on each resume
    db.append_to_history(state["user_id"], "approval_requested")

    approved = interrupt("Approve this change?")

    return {"approved": approved}
```
</CodeGroup>
:::

:::js
<CodeGroup>
```typescript Creating records
async function nodeA(state: State) {
    // âŒ Bad: creating a new record before interrupt
    // This will create duplicate records on each resume
    const auditId = await db.createAuditLog({
        userId: state.userId,
        action: "pending_approval",
        timestamp: new Date()
    });

    const approved = interrupt("Approve this change?");

    return { approved, auditId };
}
```
```typescript Appending to arrays
async function nodeA(state: State) {
    // âŒ Bad: appending to an array before interrupt
    // This will add duplicate entries on each resume
    await db.appendToHistory(state.userId, "approval_requested");

    const approved = interrupt("Approve this change?");

    return { approved };
}
```
</CodeGroup>
:::

## í•¨ìˆ˜ë¡œ í˜¸ì¶œë˜ëŠ” subgraphì™€ í•¨ê»˜ ì‚¬ìš©

Node ë‚´ì—ì„œ subgraphë¥¼ í˜¸ì¶œí•  ë•Œ, ë¶€ëª¨ graphëŠ” subgraphê°€ í˜¸ì¶œë˜ê³  @[`interrupt`]ê°€ íŠ¸ë¦¬ê±°ëœ **nodeì˜ ì‹œì‘ ë¶€ë¶„**ë¶€í„° ì‹¤í–‰ì„ ì¬ê°œí•©ë‹ˆë‹¤. ë§ˆì°¬ê°€ì§€ë¡œ **subgraph**ë„ @[`interrupt`]ê°€ í˜¸ì¶œëœ nodeì˜ ì‹œì‘ ë¶€ë¶„ë¶€í„° ì¬ê°œë©ë‹ˆë‹¤.

:::python
```python
def node_in_parent_graph(state: State):
    some_code()  # <-- This will re-execute when resumed
    # Invoke a subgraph as a function.
    # The subgraph contains an `interrupt` call.
    subgraph_result = subgraph.invoke(some_input)

async function node_in_subgraph(state: State) {
    someOtherCode(); # <-- This will also re-execute when resumed
    result = interrupt("What's your name?")
    ...
}
```
:::
:::js
```typescript
async function nodeInParentGraph(state: State) {
    someCode(); // <-- This will re-execute when resumed
    // Invoke a subgraph as a function.
    // The subgraph contains an `interrupt` call.
    const subgraphResult = await subgraph.invoke(someInput);
    // ...
}

async function nodeInSubgraph(state: State) {
    someOtherCode(); // <-- This will also re-execute when resumed
    const result = interrupt("What's your name?");
    // ...
}
```
:::

## Interruptë¥¼ ì‚¬ìš©í•œ ë””ë²„ê¹…

:::python
Graphë¥¼ ë””ë²„ê·¸í•˜ê³  í…ŒìŠ¤íŠ¸í•˜ë ¤ë©´ ì •ì  interruptë¥¼ breakpointë¡œ ì‚¬ìš©í•˜ì—¬ í•œ ë²ˆì— í•œ nodeì”© graph ì‹¤í–‰ì„ ë‹¨ê³„ë³„ë¡œ ì§„í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì •ì  interruptëŠ” nodeê°€ ì‹¤í–‰ë˜ê¸° ì „ì´ë‚˜ í›„ì— ì •ì˜ëœ ì§€ì ì—ì„œ íŠ¸ë¦¬ê±°ë©ë‹ˆë‹¤. Graphë¥¼ ì»´íŒŒì¼í•  ë•Œ `interrupt_before`ì™€ `interrupt_after`ë¥¼ ì§€ì •í•˜ì—¬ ì´ë¥¼ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
:::
:::js
Graphë¥¼ ë””ë²„ê·¸í•˜ê³  í…ŒìŠ¤íŠ¸í•˜ë ¤ë©´ ì •ì  interruptë¥¼ breakpointë¡œ ì‚¬ìš©í•˜ì—¬ í•œ ë²ˆì— í•œ nodeì”© graph ì‹¤í–‰ì„ ë‹¨ê³„ë³„ë¡œ ì§„í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì •ì  interruptëŠ” nodeê°€ ì‹¤í–‰ë˜ê¸° ì „ì´ë‚˜ í›„ì— ì •ì˜ëœ ì§€ì ì—ì„œ íŠ¸ë¦¬ê±°ë©ë‹ˆë‹¤. Graphë¥¼ ì»´íŒŒì¼í•  ë•Œ `interruptBefore`ì™€ `interruptAfter`ë¥¼ ì§€ì •í•˜ì—¬ ì´ë¥¼ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
:::

<Note>
    ì •ì  interruptëŠ” human-in-the-loop ì›Œí¬í”Œë¡œìš°ì— **ê¶Œì¥ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤**. ëŒ€ì‹  @[`interrupt`] ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.
</Note>

<Tabs>
    <Tab title="ì»´íŒŒì¼ ì‹œ">
        :::python
        ```python
        graph = builder.compile(
            interrupt_before=["node_a"],  # [!code highlight]
            interrupt_after=["node_b", "node_c"],  # [!code highlight]
            checkpointer=checkpointer,
        )

        # Pass a thread ID to the graph
        config = {
            "configurable": {
                "thread_id": "some_thread"
            }
        }

        # Run the graph until the breakpoint
        graph.invoke(inputs, config=config)  # [!code highlight]

        # Resume the graph
        graph.invoke(None, config=config)  # [!code highlight]
        ```

        1. BreakpointëŠ” `compile` ì‹œì— ì„¤ì •ë©ë‹ˆë‹¤.
        2. `interrupt_before`ëŠ” nodeê°€ ì‹¤í–‰ë˜ê¸° ì „ì— ì‹¤í–‰ì„ ì¼ì‹œ ì¤‘ì§€í•´ì•¼ í•˜ëŠ” nodeë¥¼ ì§€ì •í•©ë‹ˆë‹¤.
        3. `interrupt_after`ëŠ” nodeê°€ ì‹¤í–‰ëœ í›„ì— ì‹¤í–‰ì„ ì¼ì‹œ ì¤‘ì§€í•´ì•¼ í•˜ëŠ” nodeë¥¼ ì§€ì •í•©ë‹ˆë‹¤.
        4. Breakpointë¥¼ í™œì„±í™”í•˜ë ¤ë©´ checkpointerê°€ í•„ìš”í•©ë‹ˆë‹¤.
        5. GraphëŠ” ì²« ë²ˆì§¸ breakpointì— ë„ë‹¬í•  ë•Œê¹Œì§€ ì‹¤í–‰ë©ë‹ˆë‹¤.
        6. ì…ë ¥ì— `None`ì„ ì „ë‹¬í•˜ì—¬ graphë¥¼ ì¬ê°œí•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ë‹¤ìŒ breakpointì— ë„ë‹¬í•  ë•Œê¹Œì§€ graphê°€ ì‹¤í–‰ë©ë‹ˆë‹¤.
        :::
        :::js
        ```typescript
        const graph = builder.compile({
            interruptBefore: ["node_a"],  // [!code highlight]
            interruptAfter: ["node_b", "node_c"],  // [!code highlight]
            checkpointer,
        });

        // Pass a thread ID to the graph
        const config = {
            configurable: {
                thread_id: "some_thread"
            }
        };

        // Run the graph until the breakpoint
        await graph.invoke(inputs, config);# [!code highlight]

        await graph.invoke(null, config);  # [!code highlight]
        ```

        1. BreakpointëŠ” `compile` ì‹œì— ì„¤ì •ë©ë‹ˆë‹¤.
        2. `interruptBefore`ëŠ” nodeê°€ ì‹¤í–‰ë˜ê¸° ì „ì— ì‹¤í–‰ì„ ì¼ì‹œ ì¤‘ì§€í•´ì•¼ í•˜ëŠ” nodeë¥¼ ì§€ì •í•©ë‹ˆë‹¤.
        3. `interruptAfter`ëŠ” nodeê°€ ì‹¤í–‰ëœ í›„ì— ì‹¤í–‰ì„ ì¼ì‹œ ì¤‘ì§€í•´ì•¼ í•˜ëŠ” nodeë¥¼ ì§€ì •í•©ë‹ˆë‹¤.
        4. Breakpointë¥¼ í™œì„±í™”í•˜ë ¤ë©´ checkpointerê°€ í•„ìš”í•©ë‹ˆë‹¤.
        5. GraphëŠ” ì²« ë²ˆì§¸ breakpointì— ë„ë‹¬í•  ë•Œê¹Œì§€ ì‹¤í–‰ë©ë‹ˆë‹¤.
        6. ì…ë ¥ì— `null`ì„ ì „ë‹¬í•˜ì—¬ graphë¥¼ ì¬ê°œí•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ë‹¤ìŒ breakpointì— ë„ë‹¬í•  ë•Œê¹Œì§€ graphê°€ ì‹¤í–‰ë©ë‹ˆë‹¤.
        :::
    </Tab>
    <Tab title="ëŸ°íƒ€ì„ ì‹œ">
        :::python
        ```python
        config = {
            "configurable": {
                "thread_id": "some_thread"
            }
        }

        # Run the graph until the breakpoint
        graph.invoke(
            inputs,
            interrupt_before=["node_a"],  # [!code highlight]
            interrupt_after=["node_b", "node_c"],  # [!code highlight]
            config=config,
        )

        # Resume the graph
        graph.invoke(None, config=config)  # [!code highlight]
        ```

        1. `graph.invoke`ëŠ” `interrupt_before`ì™€ `interrupt_after` ë§¤ê°œë³€ìˆ˜ì™€ í•¨ê»˜ í˜¸ì¶œë©ë‹ˆë‹¤. ì´ëŠ” ëŸ°íƒ€ì„ êµ¬ì„±ì´ë©° ëª¨ë“  í˜¸ì¶œë§ˆë‹¤ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        2. `interrupt_before`ëŠ” nodeê°€ ì‹¤í–‰ë˜ê¸° ì „ì— ì‹¤í–‰ì„ ì¼ì‹œ ì¤‘ì§€í•´ì•¼ í•˜ëŠ” nodeë¥¼ ì§€ì •í•©ë‹ˆë‹¤.
        3. `interrupt_after`ëŠ” nodeê°€ ì‹¤í–‰ëœ í›„ì— ì‹¤í–‰ì„ ì¼ì‹œ ì¤‘ì§€í•´ì•¼ í•˜ëŠ” nodeë¥¼ ì§€ì •í•©ë‹ˆë‹¤.
        4. GraphëŠ” ì²« ë²ˆì§¸ breakpointì— ë„ë‹¬í•  ë•Œê¹Œì§€ ì‹¤í–‰ë©ë‹ˆë‹¤.
        5. ì…ë ¥ì— `None`ì„ ì „ë‹¬í•˜ì—¬ graphë¥¼ ì¬ê°œí•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ë‹¤ìŒ breakpointì— ë„ë‹¬í•  ë•Œê¹Œì§€ graphê°€ ì‹¤í–‰ë©ë‹ˆë‹¤.
        :::
        :::js
        ```typescript
        // Run the graph until the breakpoint
        graph.invoke(inputs, {
            interruptBefore: ["node_a"],  // [!code highlight]
            interruptAfter: ["node_b", "node_c"],  // [!code highlight]
            configurable: {
                thread_id: "some_thread"
            }
        });

        // Resume the graph
        await graph.invoke(null, config);  // [!code highlight]
        ```

        1. `graph.invoke`ëŠ” `interruptBefore`ì™€ `interruptAfter` ë§¤ê°œë³€ìˆ˜ì™€ í•¨ê»˜ í˜¸ì¶œë©ë‹ˆë‹¤. ì´ëŠ” ëŸ°íƒ€ì„ êµ¬ì„±ì´ë©° ëª¨ë“  í˜¸ì¶œë§ˆë‹¤ ë³€ê²½í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        2. `interruptBefore`ëŠ” nodeê°€ ì‹¤í–‰ë˜ê¸° ì „ì— ì‹¤í–‰ì„ ì¼ì‹œ ì¤‘ì§€í•´ì•¼ í•˜ëŠ” nodeë¥¼ ì§€ì •í•©ë‹ˆë‹¤.
        3. `interruptAfter`ëŠ” nodeê°€ ì‹¤í–‰ëœ í›„ì— ì‹¤í–‰ì„ ì¼ì‹œ ì¤‘ì§€í•´ì•¼ í•˜ëŠ” nodeë¥¼ ì§€ì •í•©ë‹ˆë‹¤.
        4. GraphëŠ” ì²« ë²ˆì§¸ breakpointì— ë„ë‹¬í•  ë•Œê¹Œì§€ ì‹¤í–‰ë©ë‹ˆë‹¤.
        5. ì…ë ¥ì— `null`ì„ ì „ë‹¬í•˜ì—¬ graphë¥¼ ì¬ê°œí•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ ë‹¤ìŒ breakpointì— ë„ë‹¬í•  ë•Œê¹Œì§€ graphê°€ ì‹¤í–‰ë©ë‹ˆë‹¤.
        :::
    </Tab>
</Tabs>

### LangGraph Studio ì‚¬ìš©

[LangGraph Studio](/langsmith/studio)ë¥¼ ì‚¬ìš©í•˜ì—¬ graphë¥¼ ì‹¤í–‰í•˜ê¸° ì „ì— UIì—ì„œ graphì— ì •ì  interruptë¥¼ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë˜í•œ UIë¥¼ ì‚¬ìš©í•˜ì—¬ ì‹¤í–‰ì˜ ëª¨ë“  ì§€ì ì—ì„œ graph ìƒíƒœë¥¼ ê²€ì‚¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

![image](/oss/images/static-interrupt.png)