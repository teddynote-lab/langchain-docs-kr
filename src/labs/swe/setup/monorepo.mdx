---
title: "Monorepo"
description: "Open SWE monorepo가 어떻게 구성되어 있는지"
---

Open SWE는 Turbo 빌드 오케스트레이션을 사용하는 Yarn workspace monorepo로 구성되어 있으며, 여러 애플리케이션과 공유 코드를 효율적으로 관리하도록 설계되었습니다. 이 구조는 코드 재사용, 일관된 도구 사용, 그리고 간소화된 개발 워크플로우를 가능하게 합니다.

## Repository 구조

monorepo는 두 개의 주요 디렉토리로 구성되어 있습니다:

### Applications (`apps/`)

**`apps/open-swe`** - LangGraph Agent Application

- TypeScript로 작성된 핵심 LangGraph agent 구현을 포함합니다
- manager, planner, programmer의 세 가지 특화된 graph를 포함합니다
- GitHub webhook 통합 및 LLM 상호작용을 처리합니다

**`apps/web`** - Next.js Web Interface

- Next.js framework를 사용하는 React frontend
- Tailwind CSS와 함께 Shadcn UI component(Radix UI)를 사용합니다
- LangGraph agent와 상호작용하기 위한 사용자 인터페이스를 제공합니다
- 안전한 통신을 위한 인증 및 proxy route를 포함합니다

**`apps/docs`** - Mintlify Documentation

- Mintlify로 구축된 이 문서 사이트를 포함합니다
- 포괄적인 설정 및 사용 가이드를 제공합니다
- API 문서 및 개발 리소스를 포함합니다

### Packages (`packages/`)

**`packages/shared`** - Common Utilities Package

- 공유 type, constant, utility의 중앙 집중식 위치
- agent와 web application 모두에서 사용됩니다
- `@openswe/shared` namespace를 통해 module을 export합니다
- crypto utility, GraphState type, Open SWE 특정 module을 포함합니다

<Note>
  shared package는 다른 package가 import하기 전에 빌드되어야 합니다. agent와 web app 모두에서 사용되는 모든 코드는 중복을 피하기 위해 여기에 배치되어야 합니다.
</Note>

## Turbo Orchestration

monorepo는 효율적인 빌드 오케스트레이션과 작업 관리를 위해 [Turbo](https://turbo.build/)를 사용합니다:

### Task Dependencies

```json
{
  "build": {
    "dependsOn": ["^build"],
    "outputs": ["dist/**", ".next/**", "!.next/cache/**"]
  },
  "lint": {
    "dependsOn": ["^lint"]
  }
}
```

`^build` dependency는 shared package가 의존하는 package보다 먼저 빌드되도록 보장하여, monorepo 전체에서 적절한 빌드 순서를 유지합니다.

### 사용 가능한 Script

repository root에서 다음 명령어를 실행하세요:

- `yarn build` - 의존성 순서대로 모든 package 빌드
- `yarn lint` - 모든 package에 대해 linting 실행
- `yarn format` - Prettier를 사용하여 코드 포맷팅

## Dependency 관리 모범 사례

<Steps>
  <Step title="특정 package에 dependency 설치">
    resolution을 추가하는 경우가 아니라면, 항상 사용되는 특정 package에 dependency를 설치하고, root `package.json`에는 절대 설치하지 마세요.

    ```bash
    # Correct - install in specific package
    cd apps/web
    yarn add some-package

    # Incorrect - don't install in root
    yarn add some-package
    ```
  </Step>

  <Step title="공유 dependency에 대한 resolution 사용">
    여러 package가 동일한 dependency를 필요로 할 때, 버전 일관성을 보장하기 위해 root `package.json`에 resolution을 추가하세요.

    ```json
    {
      "resolutions": {
        "@langchain/langgraph-sdk": "^0.0.95",
        "@langchain/core": "^0.3.58"
      }
    }
    ```
  </Step>

  <Step title="변경 후 shared package 빌드">
    `packages/shared`를 변경한 후에는 root에서 `yarn build`를 실행하여 다른 package에서 사용할 수 있도록 하세요.

    ```bash
    # After modifying packages/shared
    yarn build
    ```
  </Step>
</Steps>

## Postinstall Hook 요구사항

`apps/open-swe` package는 중요한 `postinstall` hook을 포함합니다:

```json
{
  "scripts": {
    "postinstall": "turbo build"
  }
}
```

<Note>
  이 postinstall hook은 LangSmith 배포에 **필수**입니다. Open SWE는 monorepo이고 agent가 shared package의 빌드된 파일에 접근해야 하므로, LangGraph server를 시작하기 전에 빌드 프로세스를 실행해야 합니다.
</Note>

### 중요한 이유

1. **배포 호환성**: LangSmith는 모든 dependency가 빌드되고 사용 가능해야 합니다
2. **Shared Package 접근**: agent는 컴파일되어야 하는 `@openswe/shared`에서 utility를 import합니다
3. **빌드 순서**: agent가 사용을 시도하기 전에 shared package가 빌드되도록 보장합니다

<Tip>
  개발 중 shared package와 관련된 import 오류가 발생하면, root에서 `yarn build`를 실행하여 모든 package가 올바르게 빌드되고 링크되었는지 확인하세요.
</Tip>

## Workspace 구성

monorepo는 다음 구성으로 Yarn 3.5.1을 사용합니다:

- **Node Linker**: 호환성을 위한 `node-modules`
- **Workspaces**: `apps/*`와 `packages/*`에서 package를 자동으로 검색합니다
- **Package Manager**: `package.json`의 `packageManager` 필드를 통해 강제됩니다