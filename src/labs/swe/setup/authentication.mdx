---
title: "인증"
description: "Open SWE에서 인증이 작동하는 방식"
---

Open SWE는 클라이언트 측 상호작용과 서버 측 작업을 모두 보호하는 포괄적인 인증 시스템을 구현합니다. 인증 흐름은 사용자 인증을 위한 GitHub OAuth, 암호화된 토큰 처리, LangGraph 서버 요청을 위한 다층 보안을 포함합니다.

## GitHub OAuth 인증

Open SWE는 클라이언트 측 인증을 위해 GitHub OAuth를 사용하여 사용자 계정 및 저장소 권한에 대한 안전한 액세스를 제공합니다.

### 인증 흐름

- **인증되지 않은 사용자**는 자동으로 GitHub OAuth 로그인으로 리디렉션됩니다
- **인증된 사용자**는 채팅 인터페이스로 직접 리디렉션됩니다
- **설정 관리**는 GitHub 인증 업데이트를 위해 `/settings`에서 사용할 수 있습니다

<Note>
  GitHub OAuth는 모든 사용자 상호작용의 기반을 제공하여 Open SWE가 저장소에 액세스하고 인증된 사용자를 대신하여 작업을 수행할 수 있도록 합니다.
</Note>

## LangGraph 서버 인증

LangGraph 서버에 대한 모든 요청은 웹 인터페이스와 에이전트 백엔드 간의 안전한 통신을 보장하는 정교한 프록시 시스템을 통해 인증됩니다.

### 프록시 라우트 아키텍처

Next.js 애플리케이션에는 모든 LangGraph 서버 요청에 대한 중개자 역할을 하는 프록시 라우트(`apps/web/src/app/api/[..._path]/route.ts`)가 포함되어 있습니다. 이 프록시는 [`langgraph-nextjs-api-passthrough`](https://www.npmjs.com/package/langgraph-nextjs-api-passthrough) 패키지를 사용하여 향상된 보안으로 요청 전달을 처리합니다.

<Tip>
  프록시 라우트는 민감한 인증 토큰이 클라이언트에 직접 도달하지 않도록 보장하여 LangGraph 서버와의 원활한 통신을 가능하게 하면서 보안을 유지합니다.
</Tip>

## 간단한 API Key (Bearer) 인증

로컬 개발 및 스크립트 액세스를 위해 LangGraph 서버는 간단한 bearer token 방식도 지원합니다. 요청에 `Authorization: Bearer <token>` 헤더가 포함되어 있으면 이 경로가 사용되고 나머지 인증 흐름은 건너뜁니다.

### 설정 (개발)

- **토큰 생성** (32+ 바이트, URL-safe):
  - OpenSSL: `openssl rand -hex 32`
- **LangGraph 서버의 `.env`에 추가**:

```bash
API_BEARER_TOKEN=<your-generated-token>
```

- 여러 개/순환을 위해: 쉼표로 구분된 토큰 사용

```bash
API_BEARER_TOKENS=<token1>,<token2>,<token3>
```

환경 변수를 업데이트한 후 LangGraph 서버를 재시작하세요.

### 사용법

```typescript
import { Client } from "@langchain/langgraph-sdk";

const client = new Client({
  apiUrl: process.env.LANGGRAPH_API_URL,
  defaultHeaders: {
    authorization: `Bearer ${process.env.API_BEARER_TOKEN}`,
  },
});
```

### 참고사항

- **우선순위**: `Authorization` 헤더가 있으면 bearer 인증이 사용되고, 그렇지 않으면 기존 GitHub 기반 흐름이 적용됩니다.
- **순환**: `API_BEARER_TOKENS`에 새 토큰을 추가하고, 배포/재시작하고, 클라이언트를 마이그레이션한 다음, 이전 토큰을 제거하고 재배포하세요.
- **범위**: 모든 bearer 토큰은 현재 동일한 내부 ID 및 권한에 매핑됩니다. 토큰별 ID/할당량이 필요한 경우 구성 조정을 위해 문의하세요.

### 헤더 주입 시스템

프록시 라우트는 각 요청에 다음과 같은 암호화된 헤더를 자동으로 주입합니다:

#### 인증 헤더

- **`x-github-access-token`** - 사용자별 작업(이슈 생성, 댓글)을 위한 사용자의 GitHub 액세스 토큰
- **`x-github-installation-token`** - 앱 수준 작업(커밋, pull request)을 위한 GitHub App 설치 토큰
- **`x-github-installation-name`** - 설치 이름(사용자 이름 또는 조직 이름)

<Note>
  모든 헤더는 `x-` 접두사가 붙어 LangGraph run 구성에 포함되도록 보장하여 암호화를 통해 보안을 유지하면서 실행 중에 액세스할 수 있도록 합니다.
</Note>

### 토큰 암호화

Open SWE는 다음에서 노출을 방지하기 위해 LangGraph 서버로 전달되는 모든 비밀에 대해 AES-256-GCM 암호화를 구현합니다:

- LangSmith trace 메타데이터
- Run 구성
- 잠재적인 무단 액세스 시나리오

암호화 프로세스는 `SECRETS_ENCRYPTION_KEY` 환경 변수를 사용하며 다음을 포함합니다:

- 토큰당 고유한 암호화를 위한 **Initialization Vector (IV)**
- 데이터 무결성 검증을 위한 **Authentication Tag**
- 안전한 전송을 위한 **Base64 인코딩**

<Tip>
  적절한 토큰 복호화를 위해 웹 애플리케이션과 LangGraph 에이전트 모두에서 동일한 암호화 키를 구성해야 합니다.
</Tip>

## 인증 미들웨어

LangGraph 서버는 모든 수신 요청을 검증하는 포괄적인 인증 미들웨어(`apps/open-swe/src/security/auth.ts`)를 구현합니다.

### Webhook 인증

미들웨어는 먼저 `X-Hub-Signature-256` 헤더를 감지하여 GitHub webhook 요청을 확인합니다:

1. 구성된 webhook 비밀을 사용한 **서명 검증**
2. 유효한 webhook 서명에 대한 **자동 권한 부여**
3. 후속 run 생성 요청에서 **별도의 사용자 검증**

<Note>
  Webhook 인증은 보안을 유지하면서 자동화된 GitHub 이슈 처리를 가능하게 하기 위해 사용자 인증과 별도로 처리됩니다.
</Note>

### 표준 요청 인증

webhook이 아닌 요청의 경우 미들웨어는 다음을 검증합니다:

#### 필수 헤더

- **Installation name** (`x-github-installation-name`)
- **Installation token** (`x-github-installation-token`)

두 헤더 중 하나라도 누락되면 401 Unauthorized 오류가 발생합니다.

#### 사용자 검증 프로세스

미들웨어는 두 가지 인증 경로를 지원합니다:

**웹 애플리케이션 요청:**

- 암호화된 GitHub 액세스 토큰(`x-github-access-token`) 사용
- GitHub API를 통해 사용자 신원 검증
- 토큰에서 사용자 ID 및 로그인 추출

**Webhook 생성 요청:**

- 명시적 사용자 헤더(`x-github-user-id`, `x-github-user-login`) 사용
- installation token에 대해 사용자 ID 및 로그인 검증
- webhook으로 생성된 run이 적절하게 귀속되도록 보장

### ID 및 권한

인증 성공 시 미들웨어는 다음을 포함하는 identity 객체를 반환합니다:

- 리소스 소유권 검증을 위한 **User ID**
- **Display name** (GitHub 로그인)
- 저장소 컨텍스트를 위한 **Installation name**
- LangGraph 작업을 위한 **포괄적인 권한**

<Tip>
  사용자 ID는 리소스 액세스 제어의 기본 식별자로 사용되어 사용자가 자신의 thread, run 및 assistant에만 액세스할 수 있도록 보장합니다.
</Tip>

## 리소스 액세스 제어

Open SWE는 모든 LangGraph 리소스에 대해 세밀한 액세스 제어를 구현합니다:

### 메타데이터 기반 소유권

- **생성 작업**은 자동으로 리소스 메타데이터에 사용자 ID를 추가합니다
- **읽기/업데이트/삭제 작업**은 사용자 ID가 리소스 소유자와 일치하는지 확인합니다
- **검색 작업**은 사용자 소유권으로 결과를 필터링합니다

## 실행 중 토큰 액세스

LangGraph run 실행 중에 암호화된 토큰은 run의 configurable 필드를 통해 액세스할 수 있습니다:

1. run 구성에서 **토큰 추출**
2. 공유 암호화 키를 사용한 **복호화**
3. **작업 실행** (이슈 생성, 커밋 등)

<Note>
  이 설계는 토큰이 저장소 및 trace에서 암호화된 상태로 유지되면서 run 실행 중 필요한 GitHub 작업에 사용할 수 있도록 보장합니다.
</Note>

<Tip>
  웹 애플리케이션과 LangGraph 에이전트 배포 간에 `SECRETS_ENCRYPTION_KEY` 환경 변수가 동일한지 항상 확인하세요.
</Tip>