---
title: Composite evaluator
sidebarTitle: Composite evaluator
---

_Composite evaluator_는 여러 evaluator score를 단일 [score](/langsmith/evaluation-concepts#evaluator-outputs)로 결합하는 방법입니다. 이는 애플리케이션의 여러 측면을 평가하고 결과를 단일 결과로 결합하려는 경우에 유용합니다.

## UI를 사용하여 composite evaluator 생성하기

[tracing project](/langsmith/observability-concepts#projects)([온라인 평가](/langsmith/evaluation-concepts#online-evaluation)용) 또는 [dataset](/langsmith/evaluation-concepts#datasets)([오프라인 평가](/langsmith/evaluation-concepts#offline-evaluation)용)에서 composite evaluator를 생성할 수 있습니다. UI의 composite evaluator를 사용하면 구성 가능한 가중치로 여러 evaluator score의 가중 평균 또는 가중 합계를 계산할 수 있습니다.

<div style={{ textAlign: 'center' }}>
<img
    className="block dark:hidden"
    src="/langsmith/images/create_composite_evaluator-light.png"
    alt="시스템 및 사용자 입력과 AI 출력이 포함된 ChatOpenAI라는 LLM 호출 trace를 보여주는 LangSmith UI."
/>

<img
    className="hidden dark:block"
    src="/langsmith/images/create_composite_evaluator-dark.png"
    alt="시스템 및 사용자 입력과 AI 출력이 포함된 ChatOpenAI라는 LLM 호출 trace를 보여주는 LangSmith UI."
/>
</div>


### 1. tracing project 또는 dataset으로 이동

composite evaluator 구성을 시작하려면 **Tracing Projects** 또는 **Dataset & Experiments** 탭으로 이동하여 project 또는 dataset을 선택합니다.
- tracing project 내에서: **+ New** > **Evaluator** > **Composite score**
- dataset 내에서: **+ Evaluator** > **Composite score**

### 2. composite evaluator 구성

1. evaluator 이름을 지정합니다.
2. 집계 방법을 선택합니다. **Average** 또는 **Sum** 중 하나를 선택합니다.
    - **Average**: ∑(weight*score) / ∑(weight).
    - **Sum**: ∑(weight*score).
3. composite score에 포함할 feedback key를 추가합니다.
4. feedback key에 대한 가중치를 추가합니다. 기본적으로 각 feedback key에 대한 가중치는 동일합니다. 최종 score에서 특정 feedback key의 중요도를 높이거나 낮추려면 가중치를 조정합니다.
5. **Create**를 클릭하여 evaluator를 저장합니다.

<Tip> composite score의 가중치를 조정해야 하는 경우 evaluator가 생성된 후에 업데이트할 수 있습니다. 결과 score는 evaluator가 구성된 모든 run에 대해 업데이트됩니다. </Tip>

### 3. composite evaluator 결과 보기
Composite score는 단일 evaluator의 feedback과 유사하게 run에 **feedback**으로 첨부됩니다. 평가가 실행된 위치에 따라 보는 방법이 다릅니다:

**tracing project에서**:
- Composite score는 run에 대한 feedback으로 나타납니다.
- composite score가 있거나 composite score가 특정 임계값을 충족하는 [run 필터링](/langsmith/filter-traces-in-application)을 수행합니다.
- 시간 경과에 따른 composite score의 추세를 시각화하기 위해 [차트 생성](/langsmith/dashboards#custom-dashboards)을 수행합니다.

**dataset에서**:
- experiments 탭에서 composite score를 확인합니다. run의 평균 composite score를 기준으로 experiment를 필터링하고 정렬할 수도 있습니다.
- experiment를 클릭하여 각 run의 composite score를 확인합니다.

<Note> 구성 evaluator 중 하나라도 run에 구성되지 않은 경우 해당 run에 대한 composite score가 계산되지 않습니다. </Note>

## SDK를 사용하여 composite feedback 생성하기

이 가이드는 여러 evaluator를 사용하고 사용자 정의 집계 함수로 score를 결합하는 평가를 설정하는 방법을 설명합니다.

<Note> langsmith>=0.4.29 필요 </Note>

### 1. dataset에 evaluator 구성
먼저 evaluator를 구성합니다. 이 예제에서 애플리케이션은 블로그 소개에서 트윗을 생성하고 세 가지 evaluator(summary, tone, formatting)를 사용하여 출력을 평가합니다.

이미 evaluator가 구성된 자체 dataset이 있는 경우 이 단계를 건너뛸 수 있습니다.

<Accordion title="dataset에 evaluator를 구성합니다.">

```python
import os
from dotenv import load_dotenv
from openai import OpenAI
from langsmith import Client
from pydantic import BaseModel
import json

# Load environment variables from .env file
load_dotenv()

# Access environment variables
openai_api_key = os.getenv('OPENAI_API_KEY')
langsmith_api_key = os.getenv('LANGSMITH_API_KEY')
langsmith_project = os.getenv('LANGSMITH_PROJECT', 'default')


# Create a dataset. Only need to do this once.
client = Client()
oai_client = OpenAI()

examples = [
  {
    "inputs": {"blog_intro": "Today we’re excited to announce the general availability of LangSmith — our purpose-built infrastructure and management layer for deploying and scaling long-running, stateful agents. Since our beta last June, nearly 400 companies have used LangSmith to deploy their agents into production. Agent deployment is the next hard hurdle for shipping reliable agents, and LangSmith dramatically lowers this barrier with: 1-click deployment to go live in minutes, 30 API endpoints for designing custom user experiences that fit any interaction pattern, Horizontal scaling to handle bursty, long-running traffic, A persistence layer to support memory, conversational history, and async collaboration with human-in-the-loop or multi-agent workflows, Native Studio, the agent IDE, for easy debugging, visibility, and iteration "},
  },
  {
    "inputs": {"blog_intro": "Klarna has reshaped global commerce with its consumer-centric, AI-powered payment and shopping solutions. With over 85 million active users and 2.5 million daily transactions on its platform, Klarna is a fintech leader that simplifies shopping while empowering consumers with smarter, more flexible financial solutions. Klarna’s flagship AI Assistant is revolutionizing the shopping and payments experience. Built on LangGraph and powered by LangSmith, the AI Assistant handles tasks ranging from customer payments, to refunds, to other payment escalations. With 2.5 million conversations to date, the AI Assistant is more than just a chatbot; it’s a transformative agent that performs the work equivalent of 700 full-time staff, delivering results quickly and improving company efficiency."},
  },
]

dataset = client.create_dataset(dataset_name="Blog Intros")

client.create_examples(
  dataset_id=dataset.id,
  examples=examples,
)

# Define a target function. In this case, we're using a simple function that generates a tweet from a blog intro.
def generate_tweet(inputs: dict) -> dict:
    instructions = (
      "Given the blog introduction, please generate a catchy yet professional tweet that can be used to promote the blog post on social media. Summarize the key point of the blog post in the tweet. Use emojis in a tasteful manner."
    )
    messages = [
        {"role": "system", "content": instructions},
        {"role": "user", "content": inputs["blog_intro"]},
    ]
    result = oai_client.responses.create(
        input=messages, model="gpt-5-nano"
    )
    return {"tweet": result.output_text}

# Define evaluators. In this case, we're using three evaluators: summary, formatting, and tone.
def summary(inputs: dict, outputs: dict) -> bool:
    """Judge whether the tweet is a good summary of the blog intro."""
    instructions = "Given the following text and summary, determine if the summary is a good summary of the text."

    class Response(BaseModel):
        summary: bool

    msg = f"Question: {inputs['blog_intro']}\nAnswer: {outputs['tweet']}"
    response = oai_client.responses.parse(
        model="gpt-5-nano",
        input=[{"role": "system", "content": instructions,}, {"role": "user", "content": msg}],
        text_format=Response
    )

    parsed_response = json.loads(response.output_text)
    return parsed_response["summary"]

def formatting(inputs: dict, outputs: dict) -> bool:
    """Judge whether the tweet is formatted for easy human readability."""
    instructions = "Given the following text, determine if it is formatted well so that a human can easily read it. Pay particular attention to spacing and punctuation."

    class Response(BaseModel):
        formatting: bool

    msg = f"{outputs['tweet']}"
    response = oai_client.responses.parse(
        model="gpt-5-nano",
        input=[{"role": "system", "content": instructions,}, {"role": "user", "content": msg}],
        text_format=Response
    )

    parsed_response = json.loads(response.output_text)
    return parsed_response["formatting"]

def tone(inputs: dict, outputs: dict) -> bool:
    """Judge whether the tweet's tone is informative, friendly, and engaging."""
    instructions = "Given the following text, determine if the tweet is informative, yet friendly and engaging."

    class Response(BaseModel):
        tone: bool

    msg = f"{outputs['tweet']}"
    response = oai_client.responses.parse(
        model="gpt-5-nano",
        input=[{"role": "system", "content": instructions,}, {"role": "user", "content": msg}],
        text_format=Response
    )
    parsed_response = json.loads(response.output_text)
    return parsed_response["tone"]

# Calling evaluate() with the dataset, target function, and evaluators.
results = client.evaluate(
    generate_tweet,
    data=dataset.name,
    evaluators=[summary, tone, formatting],
    experiment_prefix="gpt-5-nano",
)

# Get the experiment name to be used in client.get_experiment_results() in the next section
experiment_name = results.experiment_name
```
</Accordion>

### 2. composite feedback 생성

사용자 정의 함수를 사용하여 개별 evaluator score를 집계하는 composite feedback을 생성합니다. 이 예제는 개별 evaluator score의 가중 평균을 사용합니다.

<Accordion title="composite feedback을 생성합니다.">

```python
from typing import Dict
import math
from langsmith import Client
from dotenv import load_dotenv

load_dotenv()

# TODO: Replace with your experiment name. Can be found in UI or from the above client.evaluate() result
YOUR_EXPERIMENT_NAME = "placeholder_experiment_name"

# Set weights for the individual evaluator scores
DEFAULT_WEIGHTS: Dict[str, float] = {
    "summary": 0.7,
    "tone": 0.2,
    "formatting": 0.1,
}
WEIGHTED_FEEDBACK_NAME = "weighted_summary"

# Pull experiment results
client = Client()
results = client.get_experiment_results(
    name=YOUR_EXPERIMENT_NAME,
)

# Calculate weighted score for each run
def calculate_weighted_score(feedback_stats: dict) -> float:
    if not feedback_stats:
        return float("nan")

    # Check if all required metrics are present and have data
    required_metrics = set(DEFAULT_WEIGHTS.keys())
    available_metrics = set(feedback_stats.keys())

    if not required_metrics.issubset(available_metrics):
        return float("nan")

    # Calculate weighted score
    total_score = 0.0
    for metric, weight in DEFAULT_WEIGHTS.items():
        metric_data = feedback_stats[metric]
        if metric_data.get("n", 0) > 0 and "avg" in metric_data:
            total_score += metric_data["avg"] * weight
        else:
            return float("nan")

    return total_score

# Process each run and write feedback
# Note that experiment results need to finish processing before this should be called.
for example_with_runs in results["examples_with_runs"]:
    for run in example_with_runs.runs:
        if run.feedback_stats:
            score = calculate_weighted_score(run.feedback_stats)
            if not math.isnan(score):
                client.create_feedback(
                    run_id=run.id,
                    key=WEIGHTED_FEEDBACK_NAME,
                    score=float(score)
                )
```
</Accordion>