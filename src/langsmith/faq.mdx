---
title: 자주 묻는 질문
sidebarTitle: FAQs
---

## Observability

### *UI에서 API key를 생성하거나 사용자를 관리할 수 없습니다. 무엇이 문제인가요?*

* SSO 설정 없이 LangSmith를 배포했을 가능성이 높습니다. LangSmith는 사용자 및 API key를 관리하기 위해 SSO가 필요합니다. SSO 설정에 대한 자세한 내용은 [구성 섹션](/langsmith/self-host-sso)에서 확인할 수 있습니다.

### *로드 밸런싱/ingress는 어떻게 작동하나요?*

* frontend container/service를 애플리케이션/사용자에게 노출해야 합니다. 이는 모든 다운스트림 서비스로의 라우팅을 처리합니다.
* ingress 레벨에서 SSL을 종료해야 합니다. AWS ALB, GCP Load Balancer 또는 Nginx와 같은 관리형 서비스를 사용하는 것을 권장합니다.

### *애플리케이션에 어떻게 인증하나요?*

* 현재 self-hosted 솔루션은 OAuth2.0 및 OIDC를 authn 솔루션으로 사용하는 SSO를 지원합니다. 참고로, no-auth 솔루션도 제공하지만 프로덕션으로 이동하기 전에 oauth를 설정하는 것을 강력히 권장합니다.

SSO 설정에 대한 자세한 내용은 [구성 섹션](/langsmith/self-host-sso)에서 확인할 수 있습니다.

### *외부 스토리지 서비스를 사용할 수 있나요?*

* 모든 스토리지 서비스의 외부 버전을 사용하도록 LangSmith를 구성할 수 있습니다. 프로덕션 환경에서는 외부 스토리지 서비스를 사용하는 것을 강력히 권장합니다. 자세한 내용은 [구성 섹션](/langsmith/self-hosted)을 확인하세요.

### *애플리케이션이 제대로 작동하려면 egress가 필요한가요?*

배포에는 몇 가지 경우에만 egress가 필요합니다 (대부분은 VPC 내에 있을 수 있습니다):

* 이미지 가져오기 (이미지를 미러링하는 경우 필요하지 않을 수 있습니다)

* LLM endpoint와 통신

* 구성한 외부 스토리지 서비스와 통신

* OAuth 정보 가져오기

* Subscription Metrics 및 Operational Metadata (오프라인 모드에서 실행하지 않는 경우)

  * `https://beacon.langchain.com`으로의 egress 필요
  * 자세한 내용은 [Egress](/langsmith/self-host-egress)를 참조하세요

VPC는 다른 모든 액세스를 제한하는 규칙을 설정할 수 있습니다. 참고: `X-Organization-Id` 및 `X-Tenant-Id` header가 backend service로 전달되도록 허용해야 합니다. 이는 요청이 어떤 organization 및 workspace(이전에는 "tenant"라고 불림)에 대한 것인지 결정하는 데 사용됩니다.

### *애플리케이션의 리소스 요구 사항은?*

* kubernetes에서는 [여기](https://github.com/langchain-ai/helm/blob/main/charts/langsmith/examples/medium_size.yaml)에서 찾을 수 있는 최소 helm 구성을 권장합니다. docker의 경우 최소 16GB RAM과 4 CPU를 권장합니다.
* Postgres의 경우 최소 8GB RAM과 2 CPU를 권장합니다.
* Redis의 경우 4GB RAM과 2 CPU를 권장합니다.
* Clickhouse의 경우 32GB RAM과 8 CPU를 권장합니다.

### SAML SSO FAQs

#### *SAML SSO 사용자의 이메일 주소를 어떻게 변경하나요?*

일부 identity provider는 이메일 변경 시 원래 `User ID`를 유지하지만 그렇지 않은 경우도 있으므로, LangSmith에서 중복 사용자를 방지하기 위해 다음 단계를 따르는 것을 권장합니다:

1. organization에서 사용자 제거 ([여기](/langsmith/set-up-a-workspace#manage-users) 참조)
2. IdP에서 이메일 주소 변경
3. SAML SSO를 통해 LangSmith에 다시 로그인하도록 함 - 이는 새 이메일 주소로 일반적인 [JIT provisioning](#just-in-time-jit-provisioning) 흐름을 트리거합니다

#### *"405 method not allowed"를 어떻게 수정하나요?*

올바른 ACS URL을 사용하고 있는지 확인하세요: [https://auth.langchain.com/auth/v1/sso/saml/acs](https://auth.langchain.com/auth/v1/sso/saml/acs)

### SCIM FAQs

#### *SAML SSO 없이 SCIM을 사용할 수 있나요?*

* **Cloud**: 아니요, cloud 배포에서는 SCIM에 SAML SSO가 필요합니다
* **Self-hosted**: 예, SCIM은 Client Secret 인증 모드를 사용하는 OAuth와 함께 작동합니다

#### *JIT provisioning과 SCIM이 모두 활성화되어 있으면 어떻게 되나요?*

JIT provisioning과 SCIM은 서로 충돌할 수 있습니다. 일관된 사용자 provisioning 동작을 보장하기 위해 SCIM을 활성화하기 전에 JIT provisioning을 비활성화하는 것을 권장합니다.

#### *사용자의 role 또는 workspace 액세스를 어떻게 변경하나요?*

IdP에서 사용자의 그룹 멤버십을 업데이트하세요. 변경 사항은 [role precedence rules](#role-precedence)에 따라 LangSmith에 동기화됩니다.

#### *사용자가 모든 그룹에서 제거되면 어떻게 되나요?*

사용자는 IdP의 deprovisioning 설정에 따라 LangSmith organization에서 deprovisioning됩니다.

#### *사용자 정의 그룹 이름을 사용할 수 있나요?*

예. identity provider가 `displayName` 그룹 속성에 대체 필드 동기화를 지원하는 경우, LangSmith에서 `displayName`으로 대체 속성(예: `description`)을 사용하고 identity provider 그룹 이름의 완전한 사용자 정의를 유지할 수 있습니다. 그렇지 않으면 그룹은 LangSmith role 및 workspace에 올바르게 매핑되기 위해 [Group Naming Convention](#group-naming-convention) 섹션에 설명된 특정 명명 규칙을 따라야 합니다.

##### _Okta 통합이 작동하지 않는 이유는 무엇인가요?_

Okta의 문제 해결 가이드를 참조하세요: https://help.okta.com/en-us/content/topics/users-groups-profiles/usgp-group-push-troubleshoot.htm.

## Deployment

### LangGraph를 사용하려면 LangChain을 사용해야 하나요? 차이점은 무엇인가요?

아니요. LangGraph는 복잡한 agentic 시스템을 위한 orchestration framework이며 LangChain agent보다 더 low-level이고 제어 가능합니다. LangChain은 model 및 기타 component와 상호 작용하기 위한 표준 인터페이스를 제공하며, 간단한 chain 및 retrieval flow에 유용합니다.

### LangGraph는 다른 agent framework와 어떻게 다른가요?

다른 agentic framework는 간단하고 일반적인 작업에는 작동할 수 있지만 회사의 요구 사항에 맞춤화된 복잡한 작업에는 부족합니다. LangGraph는 사용자를 단일 black-box cognitive architecture로 제한하지 않으면서 회사의 고유한 작업을 처리할 수 있는 더 표현력 있는 framework를 제공합니다.

### LangGraph가 앱의 성능에 영향을 미치나요?

LangGraph는 코드에 오버헤드를 추가하지 않으며 streaming workflow를 염두에 두고 특별히 설계되었습니다.

### LangGraph는 오픈 소스인가요? 무료인가요?

예. LangGraph는 MIT 라이선스 오픈 소스 라이브러리이며 무료로 사용할 수 있습니다.

### LangGraph와 LangSmith는 어떻게 다른가요?

LangGraph는 agent workflow에 추가 제어를 제공하는 stateful orchestration framework입니다. LangSmith는 agentic 애플리케이션을 배포하고 확장하기 위한 서비스로, agent UX를 구축하기 위한 opinionated API와 통합 개발자 UI를 제공합니다.

| Features            | LangGraph (open source)                                   | LangSmith                                                                                     |
|---------------------|-----------------------------------------------------------|--------------------------------------------------------------------------------------------------------|
| Description         | agentic 애플리케이션을 위한 stateful orchestration framework | LangGraph 애플리케이션 배포를 위한 확장 가능한 인프라                                           |
| SDKs                | Python 및 JavaScript                                     | Python 및 JavaScript                                                                                  |
| HTTP APIs           | 없음                                                      | 예 - state 또는 long-term memory 검색 및 업데이트, 또는 구성 가능한 assistant 생성에 유용 |
| Streaming           | 기본                                                     | token-by-token 메시지를 위한 전용 모드                                                             |
| Checkpointer        | 커뮤니티 기여                                              | 기본 제공 지원                                                                               |
| Persistence Layer   | 자체 관리                                              | 효율적인 스토리지를 갖춘 관리형 Postgres                                                                |
| Deployment          | 자체 관리                                              | • Cloud <br /> • 무료 self-hosted <br /> • Enterprise (유료 self-hosted)                      |
| Scalability         | 자체 관리                                              | task queue 및 server의 자동 확장                                                                |
| Fault-tolerance     | 자체 관리                                              | 자동 재시도                                                                                      |
| Concurrency Control | 간단한 threading                                          | double-texting 지원                                                                                |
| Scheduling          | 없음                                                      | Cron scheduling                                                                                        |
| Monitoring          | 없음                                                      | observability를 위한 LangSmith 통합                                                            |
| IDE integration     | Studio                                          | Studio                                                                                       |

### LangSmith는 오픈 소스인가요?

아니요. LangSmith는 독점 소프트웨어입니다.

기본 기능에 액세스할 수 있는 무료 self-hosted 버전의 LangSmith가 있습니다. Cloud 배포 옵션과 Self-Hosted 배포 옵션은 유료 서비스입니다. 자세한 내용은 [영업팀에 문의](https://www.langchain.com/contact-sales)하세요.

자세한 내용은 [LangSmith 가격 페이지](https://www.langchain.com/pricing)를 참조하세요.

### tool calling을 지원하지 않는 LLM에서 LangGraph가 작동하나요?

예! 모든 LLM과 함께 LangGraph를 사용할 수 있습니다. tool calling을 지원하는 LLM을 사용하는 주된 이유는 LLM이 무엇을 할지 결정하는 가장 편리한 방법이기 때문입니다. LLM이 tool calling을 지원하지 않는 경우에도 사용할 수 있습니다. 단지 원시 LLM 문자열 응답을 무엇을 할지에 대한 결정으로 변환하는 약간의 로직을 작성해야 합니다.

### LangGraph는 OSS LLM과 함께 작동하나요?

예! LangGraph는 내부적으로 사용되는 LLM에 대해 완전히 중립적입니다. 대부분의 튜토리얼에서 closed LLM을 사용하는 주된 이유는 tool calling을 원활하게 지원하는 반면 OSS LLM은 종종 그렇지 않기 때문입니다. 하지만 tool calling은 필수가 아니므로([이 섹션](#does-langgraph-work-with-llms-that-dont-support-tool-calling) 참조) OSS LLM과 함께 LangGraph를 완전히 사용할 수 있습니다.

### LangSmith에 로그인하지 않고 Studio를 사용할 수 있나요?

예! [LangGraph Server의 개발 버전](/langsmith/local-server)을 사용하여 backend를 로컬에서 실행할 수 있습니다.
이는 LangSmith의 일부로 호스팅되는 Studio frontend에 연결됩니다.
`LANGSMITH_TRACING=false` 환경 변수를 설정하면 LangSmith로 trace가 전송되지 않습니다.

### LangSmith 사용량에서 "nodes executed"는 무엇을 의미하나요?

**Nodes Executed**는 애플리케이션 호출 중에 호출되고 성공적으로 완료된 LangGraph 애플리케이션의 node 집계 수입니다. 실행 중에 graph의 node가 호출되지 않거나 오류 상태로 끝나는 경우 이러한 node는 계산되지 않습니다. node가 여러 번 호출되고 성공적으로 완료되면 각 발생이 계산됩니다.