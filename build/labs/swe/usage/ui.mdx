---
title: "UI에서 사용하기"
description: "UI에서 Open SWE를 사용하는 방법"
---

Open SWE는 채팅과 같은 경험을 통해 코딩 에이전트와 상호작용할 수 있는 강력한 웹 인터페이스를 제공합니다. UI는 자동 및 수동 워크플로우를 모두 지원하여 에이전트가 요청을 처리하는 방식을 제어할 수 있습니다.

## Auto vs Manual Mode

UI는 코딩 요청을 처리하기 위한 두 가지 모드를 제공합니다:

<Note>
  메인 입력 영역의 체크리스트 아이콘을 사용하여 auto 모드와 manual 모드를 전환할 수 있습니다.
</Note>

### Auto Mode

**Auto Mode**가 활성화되면 (체크리스트 아이콘이 강조 표시됨):

- 계획이 사용자 개입 없이 자동으로 승인되고 실행됩니다
- 에이전트가 계획에서 구현으로 직접 진행합니다
- 에이전트의 계획을 신뢰하는 간단한 요청에 이상적입니다

### Manual Mode

**Manual Mode**가 활성화되면 (체크리스트 아이콘이 강조 표시되지 않음):

- 실행 전에 제안된 계획을 수동으로 검토하고 승인해야 합니다
- 계획을 편집, 수정 또는 거부할 수 있는 기회를 제공합니다
- 구현 접근 방식에 대한 더 많은 제어를 허용합니다

<Tip>
  중요한 변경 사항의 경우 manual 모드로 시작하여 실행 전에 에이전트의 접근 방식을 검토하세요.
</Tip>

## Manager Agent 기능

Manager 에이전트는 중앙 조정자 역할을 하며, 메시지를 지능적으로 라우팅하고 전체 워크플로우를 관리합니다. Manager가 할 수 있는 것과 할 수 없는 것은 다음과 같습니다:

### Manager가 _할 수 있는_ 것

<Steps>
  <Step title="사용자 메시지에 응답">
    진행 중인 작업에 대한 컨텍스트 응답 및 상태 업데이트를 제공합니다.
    manager에게 무엇을 할 수 있는지, 다른 에이전트의 상태가 어떤지 등을 물어볼 수 있습니다.
  </Step>
  <Step title="새로운 Planning Run 생성">
    코딩 요청을 제출할 때 새로운 계획 세션을 시작합니다. 메시지에 코딩 요청이 포함되어 있으면 manager는 새로운 계획 세션 및 해당 GitHub issue를 생성합니다.
  </Step>
  <Step title="활성 Planning Run에 메시지 전송">
    실행 중인 planner 세션에 추가 컨텍스트 또는 요구 사항을 전달합니다. planner가 실행 중일 때 메시지를 보내면 manager는 흐름을 중단하지 않고 해당 메시지를 planner에게 전달할 수 있습니다.
  </Step>
  <Step title="중단된 Planner 재개">
    사용자가 계획을 승인하거나 거부하기 위해 일시 중지된 planner 세션을 재개합니다. planner가 계획 승인을 위해 일시 중지된 경우 계획에 대한 피드백과 함께 manager에게 메시지를 보낼 수 있습니다. 이는 planner에게 전달되며 피드백을 기반으로 흐름을 계속합니다.
  </Step>
  <Step title="활성 Programmer Run에 메시지 전송">
    실행 중인 구현 세션에 추가 컨텍스트 또는 지침을 제공합니다. programmer가 실행 중일 때 메시지를 보내면 manager는 흐름을 중단하지 않고 해당 메시지를 programmer에게 전달할 수 있습니다.
  </Step>
  <Step title="새로운 task 생성">
    현재 요청과 독립적인 새로운 task를 생성합니다. 현재 요청과 관련이 없거나 다른 세션을 통해 병렬로 구현할 수 있는 task 요청과 함께 manager에게 메시지를 보내면 manager는 새로운 GitHub issue를 생성하고 해당 issue에 대한 새로운 계획 세션을 시작합니다.
  </Step>
</Steps>

### Manager가 _할 수 없는_ 것

<Note>
  Manager는 적절한 워크플로우 제어를 보장하기 위해 몇 가지 중요한 제한 사항이 있습니다:
</Note>

- **새로운 Programmer run을 생성할 수 없음** - 이는 계획 승인 후 또는 auto 모드에서만 발생합니다.
- **실행 중인 Planner/Programmer 세션을 중지할 수 없음** - 세션을 중지하려면 UI에서 취소 버튼을 클릭해야 합니다.
- **Programmer가 실행 중일 때 재계획할 수 없음** - programmer 세션이 시작되면 planner로 돌아갈 수 없습니다. 그러나 programmer에게 전달될 수 있는 메시지를 manager에게 보낼 수 있습니다.
- **Pull Request를 직접 열 수 없음** - PR은 Programmer 완료 후 자동으로 생성됩니다 (파일이 수정될 때마다 변경 사항이 자동으로 커밋됩니다).
- **manual 모드에서 계획을 승인할 수 없음** - 계획 승인을 위해 수동으로 승인을 클릭해야 합니다.

## 메시지 처리 및 라우팅

Manager는 메시지를 지능적으로 분류하고 적절한 구성 요소로 라우팅합니다:

### 메시지 분류

메시지를 보낼 때 Manager는 다음을 분석합니다:

- Planner 및 Programmer graph의 현재 상태
- 메시지의 내용 및 의도
- 기존 대화 컨텍스트
- 활성 계획 및 task

### 라우팅 옵션

분석을 기반으로 메시지는 다음으로 라우팅됩니다:

- **Start Planner**: 계획이 필요한 새로운 코딩 요청
- **Update Planner**: 활성 계획 세션에 컨텍스트 추가
- **Resume Planner**: 새로운 정보로 중단된 계획 계속
- **Update Programmer**: 활성 구현 세션에 컨텍스트 제공
- **Create New Issue**: 별도의 GitHub issue가 되어야 하는 독립적인 요청
- **No Operation**: 특정 라우팅이 필요하지 않은 메시지

## Planning Run

Planning run은 요청에 대한 상세한 실행 계획을 생성하는 Planner graph에 의해 처리됩니다.

### 계획 프로세스

<Steps>
  <Step title="컨텍스트 수집">
    Planner는 리포지토리를 분석하고 코드베이스에 대한 관련 컨텍스트를 수집합니다
  </Step>
  <Step title="계획 생성">
    구체적이고 실행 가능한 단계가 포함된 구조화된 계획을 생성합니다
  </Step>
  <Step title="계획 제시">
    검토를 위해 제안된 계획을 제시합니다 (manual 모드) 또는 자동 승인 (auto 모드)
  </Step>
</Steps>

### 계획 중단

계획은 사용자 응답이 필요한 중단으로 제시됩니다:

- **Manual Mode**: 계획을 명시적으로 승인하거나 거부해야 합니다
- **Auto Mode**: 계획이 자동으로 승인되고 실행이 시작됩니다
- **계획 편집**: 승인 전에 제안된 계획을 수정할 수 있습니다
- **피드백**: 계획을 어떤 방식으로 변경하고 싶은지 manager에게 피드백을 제공할 수 있습니다

### 자동 승인

auto 모드가 활성화되면 계획이 자동으로 승인되고 계획 생성 직후 구현이 시작됩니다.

## Programmer Run

계획이 승인되면 Programmer graph가 구현을 실행합니다.

### 프로그래밍 프로세스

<Steps>
  <Step title="계획 실행">
    승인된 계획의 각 단계를 체계적으로 진행합니다
  </Step>
  <Step title="코드 구현">
    리포지토리의 파일에 실제 변경 사항을 적용합니다
  </Step>
  <Step title="진행 상황 추적">
    계획 상태를 업데이트하고 완료된 작업의 요약을 제공합니다
  </Step>
  <Step title="Pull Request 생성">
    구현이 완료되면 모든 변경 사항이 포함된 PR을 자동으로 엽니다
  </Step>
</Steps>

<Note>
  Programmer는 각 단계 후 자동으로 변경 사항을 커밋하여 세션이 중단되더라도 작업이 보존되도록 합니다.
</Note>

## LangGraph Engineer Toggle

UI에는 LangGraph 코드로 작업할 때 에이전트의 성능을 최적화하는 **LangGraph Engineer** 토글 버튼이 포함되어 있습니다:

<Note>
  LangGraph Engineer 토글은 메인 입력 영역에 있으며 Open SWE 아이콘으로 표시됩니다.
</Note>

### LangGraph Engineer를 활성화해야 하는 경우

LangGraph 에이전트 또는 워크플로우를 생성하거나 수정하는 요청이 포함된 경우 이 토글을 활성화하세요. 처음부터 LLM 앱을 구축하는 데 매우 유용합니다.

### LangGraph Engineer가 하는 일

활성화되면 토글은:

- **특정 prompt 제공**: 모든 에이전트 prompt에 LangGraph 관련 지침 및 모범 사례를 추가합니다
- **문서 액세스 포함**: 에이전트가 MCP 서버를 통해 계획 및 구현 중에 최신 LangGraph 문서를 자동으로 가져올 수 있습니다.
- **LangGraph 패턴 준수**: 에이전트가 적절한 LangGraph 구조, primitive 및 배포 방법을 사용하도록 보장합니다.

<Tip>
  `@langchain/langgraph` 또는 `langgraph`에서 import하는 모든 프로젝트에 대해 LangGraph Engineer를 활성화하여 최상의 결과를 얻으세요.
</Tip>

## 시작하기

Open SWE UI 사용을 시작하려면:

<Steps>
  <Step title="리포지토리 선택">
    리포지토리 선택기를 사용하여 GitHub 리포지토리 및 브랜치를 선택합니다
  </Step>
  <Step title="모드 선택">
    계획 승인에 대한 선호도에 따라 auto/manual 모드를 토글합니다
  </Step>
  <Step title="요청 제출">
    터미널 입력에 코딩 요청을 입력하고 Cmd+Enter를 눌러 전송합니다
  </Step>
  <Step title="진행 상황 모니터링">
    Manager가 요청을 라우팅하고 계획 및 구현을 조정하는 것을 지켜봅니다
  </Step>
</Steps>

<Note>
  UI를 사용하기 전에 GitHub App 및 인증을 올바르게 구성했는지 확인하세요. 자세한 내용은 [Development Setup](/labs/swe/setup/development) 가이드를 참조하세요.
</Note>

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/labs/swe/usage/ui.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for    real-time answers.
</Tip>
