---
title: LangChain으로 시맨틱 검색 엔진 만들기
sidebarTitle: 시맨틱 검색
---



import EmbeddingsTabsPy from '/snippets/embeddings-tabs-py.mdx';
import EmbeddingsTabsJS from '/snippets/embeddings-tabs-js.mdx';
import VectorstoreTabsPy from '/snippets/vectorstore-tabs-py.mdx';
import VectorstoreTabsJS from '/snippets/vectorstore-tabs-js.mdx';

## 개요

이 튜토리얼에서는 LangChain의 [document loader](/oss/javascript/langchain/retrieval#document-loaders), [embedding](/oss/javascript/langchain/retrieval#embedding-models), [vector store](/oss/javascript/langchain/retrieval#vector-store) 추상화에 대해 알아봅니다. 이러한 추상화는 (벡터) 데이터베이스 및 기타 소스에서 데이터를 검색하여 LLM 워크플로우와 통합하는 것을 지원하도록 설계되었습니다. 이는 검색 증강 생성(retrieval-augmented generation) 또는 [RAG](/oss/javascript/langchain/retrieval)의 경우처럼 모델 추론의 일부로 추론할 데이터를 가져오는 애플리케이션에 중요합니다.

여기서는 PDF 문서에 대한 검색 엔진을 구축합니다. 이를 통해 입력 쿼리와 유사한 PDF의 구절을 검색할 수 있습니다. 이 가이드에는 검색 엔진 위에 최소한의 RAG 구현도 포함되어 있습니다.

### 개념

이 가이드는 텍스트 데이터 검색에 중점을 둡니다. 다음 개념을 다룹니다:

- [Documents 및 document loaders](/oss/javascript/integrations/document_loaders);
- [Text splitters](/oss/javascript/integrations/splitters);
- [Embeddings](/oss/javascript/integrations/text_embedding);
- [Vector stores](/oss/javascript/integrations/vectorstores) 및 [retrievers](/oss/javascript/integrations/retrievers).

## 설정

### 설치



이 가이드에는 `@langchain/community` 및 `pdf-parse`가 필요합니다:

<CodeGroup>
```bash npm
npm i @langchain/community pdf-parse
```
```bash yarn
yarn add @langchain/community pdf-parse
```
```bash pnpm
pnpm add @langchain/community pdf-parse
```
</CodeGroup>



자세한 내용은 [설치 가이드](/oss/javascript/langchain/install)를 참조하세요.

### LangSmith

LangChain으로 구축하는 많은 애플리케이션에는 여러 LLM 호출이 포함된 여러 단계가 포함됩니다.
이러한 애플리케이션이 점점 더 복잡해짐에 따라 chain 또는 agent 내부에서 정확히 무슨 일이 일어나고 있는지 검사할 수 있는 것이 중요해집니다.
이를 수행하는 가장 좋은 방법은 [LangSmith](https://smith.langchain.com)를 사용하는 것입니다.

위 링크에서 가입한 후 추적 로깅을 시작하려면 환경 변수를 설정해야 합니다:

```shell
export LANGSMITH_TRACING="true"
export LANGSMITH_API_KEY="..."
```



## 1. Documents 및 Document Loaders

LangChain은 텍스트 단위와 관련 메타데이터를 나타내기 위한 [Document](https://v03.api.js.langchain.com/classes/_langchain_core.documents.Document.html) 추상화를 구현합니다. 세 가지 속성이 있습니다:


- `pageContent`: 콘텐츠를 나타내는 문자열;
- `metadata`: 임의의 메타데이터를 포함하는 dict;
- `id`: (선택 사항) 문서의 문자열 식별자.


`metadata` 속성은 문서의 소스, 다른 문서와의 관계 및 기타 정보에 대한 정보를 캡처할 수 있습니다. 개별 [`Document`](https://v03.api.js.langchain.com/classes/_langchain_core.documents.Document.html) 객체는 종종 더 큰 문서의 청크를 나타냅니다.

원하는 경우 샘플 문서를 생성할 수 있습니다:


```typescript
import { Document } from "@langchain/core/documents";

const documents = [
  new Document({
    pageContent:
      "Dogs are great companions, known for their loyalty and friendliness.",
    metadata: { source: "mammal-pets-doc" },
  }),
  new Document({
    pageContent: "Cats are independent pets that often enjoy their own space.",
    metadata: { source: "mammal-pets-doc" },
  }),
];
```


그러나 LangChain 생태계는 [수백 개의 일반적인 소스와 통합](/oss/javascript/integrations/document_loaders/)되는 [document loaders](/oss/javascript/langchain/retrieval#document-loaders)를 구현합니다. 이를 통해 이러한 소스의 데이터를 AI 애플리케이션에 쉽게 통합할 수 있습니다.

### 문서 로드하기

PDF를 [`Document`](https://v03.api.js.langchain.com/classes/_langchain_core.documents.Document.html) 객체의 시퀀스로 로드해 보겠습니다. [여기 샘플 PDF가 있습니다](https://github.com/langchain-ai/langchain/blob/v0.3/docs/docs/example_data/nke-10k-2023.pdf) -- 2023년 Nike의 10-k 제출 서류입니다. [사용 가능한 PDF document loaders](/oss/javascript/integrations/document_loaders/#pdfs)에 대한 LangChain 문서를 참조할 수 있습니다.


```typescript
import { PDFLoader } from "@langchain/community/document_loaders/fs/pdf";

const loader = new PDFLoader("../../data/nke-10k-2023.pdf");

const docs = await loader.load();
console.log(docs.length);
```
```output
107
```

`PDFLoader`는 PDF 페이지당 하나의 [`Document`](https://v03.api.js.langchain.com/classes/_langchain_core.documents.Document.html) 객체를 로드합니다. 각각에 대해 다음에 쉽게 액세스할 수 있습니다:

- 페이지의 문자열 콘텐츠;
- 파일 이름과 페이지 번호를 포함하는 메타데이터.



```typescript
console.log(docs[0].pageContent.slice(0, 200));
```
```output
Table of Contents
UNITED STATES
SECURITIES AND EXCHANGE COMMISSION
Washington, D.C. 20549
FORM 10-K
(Mark One)
☑ ANNUAL REPORT PURSUANT TO SECTION 13 OR 15(D) OF THE SECURITIES EXCHANGE ACT OF 1934
FO
```
```typescript
console.log(docs[0].metadata);
```
```output
{
  source: '../../data/nke-10k-2023.pdf',
  pdf: {
    version: '1.10.100',
    info: {
      PDFFormatVersion: '1.4',
      IsAcroFormPresent: false,
      IsXFAPresent: false,
      Title: '0000320187-23-000039',
      Author: 'EDGAR Online, a division of Donnelley Financial Solutions',
      Subject: 'Form 10-K filed on 2023-07-20 for the period ending 2023-05-31',
      Keywords: '0000320187-23-000039; ; 10-K',
      Creator: 'EDGAR Filing HTML Converter',
      Producer: 'EDGRpdf Service w/ EO.Pdf 22.0.40.0',
      CreationDate: "D:20230720162200-04'00'",
      ModDate: "D:20230720162208-04'00'"
    },
    metadata: null,
    totalPages: 107
  },
  loc: { pageNumber: 1 }
}
```


### 분할

정보 검색 및 다운스트림 질문 답변 목적 모두에서 페이지는 너무 거친 표현일 수 있습니다. 최종 목표는 입력 쿼리에 답하는 [`Document`](https://v03.api.js.langchain.com/classes/_langchain_core.documents.Document.html) 객체를 검색하는 것이며, PDF를 추가로 분할하면 문서의 관련 부분의 의미가 주변 텍스트에 의해 "희석"되지 않도록 하는 데 도움이 됩니다.

이를 위해 [text splitters](/oss/javascript/langchain/retrieval#text_splitters)를 사용할 수 있습니다. 여기서는 문자를 기반으로 분할하는 간단한 text splitter를 사용합니다. 문서를 1000자 청크로 분할하고
청크 간에 200자의 오버랩을 둡니다. 오버랩은
중요한 컨텍스트와 관련된 진술을 분리할 가능성을 완화하는 데 도움이 됩니다. 우리는
`RecursiveCharacterTextSplitter`를 사용하며,
이는 새 줄과 같은 일반적인 구분 기호를 사용하여 각 청크가 적절한 크기가 될 때까지 문서를 재귀적으로 분할합니다. 이것은
일반 텍스트 사용 사례에 권장되는 text splitter입니다.


```typescript
import { RecursiveCharacterTextSplitter } from "@langchain/textsplitters";

const textSplitter = new RecursiveCharacterTextSplitter({
  chunkSize: 1000,
  chunkOverlap: 200,
});

const allSplits = await textSplitter.splitDocuments(docs);

console.log(allSplits.length);
```


```output
514
```


## 2. Embeddings

벡터 검색은 비정형 데이터(예: 비정형 텍스트)를 저장하고 검색하는 일반적인 방법입니다. 아이디어는 텍스트와 연관된 숫자 벡터를 저장하는 것입니다. 쿼리가 주어지면 동일한 차원의 벡터로 [embed](/oss/javascript/langchain/retrieval#embedding_models)하고 벡터 유사도 메트릭(예: 코사인 유사도)을 사용하여 관련 텍스트를 식별할 수 있습니다.

LangChain은 [수십 개의 제공업체](/oss/javascript/integrations/text_embedding/)의 embeddings를 지원합니다. 이러한 모델은 텍스트를 숫자 벡터로 변환하는 방법을 지정합니다. 모델을 선택해 보겠습니다:


<EmbeddingsTabsJS />

```typescript
const vector1 = await embeddings.embedQuery(allSplits[0].pageContent);
const vector2 = await embeddings.embedQuery(allSplits[1].pageContent);

assert vector1.length === vector2.length;
console.log(`Generated vectors of length ${vector1.length}\n`);
console.log(vector1.slice(0, 10));
```


```output
Generated vectors of length 1536

[-0.008586574345827103, -0.03341241180896759, -0.008936782367527485, -0.0036674530711025, 0.010564599186182022, 0.009598285891115665, -0.028587326407432556, -0.015824200585484505, 0.0030416189692914486, -0.012899317778646946]
```
텍스트 embeddings를 생성하는 모델을 갖추었으므로 이제 효율적인 유사도 검색을 지원하는 특수 데이터 구조에 저장할 수 있습니다.

## 3. Vector stores

LangChain @[VectorStore] 객체에는 텍스트 및 [`Document`](https://v03.api.js.langchain.com/classes/_langchain_core.documents.Document.html) 객체를 저장소에 추가하고 다양한 유사도 메트릭을 사용하여 쿼리하는 메서드가 포함되어 있습니다. 이들은 종종 텍스트 데이터가 숫자 벡터로 변환되는 방법을 결정하는 [embedding](/oss/javascript/langchain/retrieval#embedding_models) 모델로 초기화됩니다.

LangChain에는 다양한 vector store 기술과의 [통합](/oss/javascript/integrations/vectorstores) 모음이 포함되어 있습니다. 일부 vector stores는 제공업체(예: 다양한 클라우드 제공업체)가 호스팅하며 사용하려면 특정 자격 증명이 필요합니다. 일부(예: [Postgres](/oss/javascript/integrations/vectorstores/pgvector))는 로컬 또는 타사를 통해 실행할 수 있는 별도의 인프라에서 실행됩니다. 다른 것들은 경량 워크로드를 위해 인메모리로 실행할 수 있습니다. vector store를 선택해 보겠습니다:


<VectorstoreTabsJS />


vector store를 인스턴스화했으므로 이제 문서를 인덱싱할 수 있습니다.


```typescript
await vectorStore.addDocuments(allSplits);
```


대부분의 vector store 구현에서는 기존 vector store에 연결할 수 있습니다. 예를 들어 클라이언트, 인덱스 이름 또는 기타 정보를 제공하여 연결할 수 있습니다. 자세한 내용은 특정 [통합](/oss/javascript/integrations/vectorstores)에 대한 문서를 참조하세요.

문서가 포함된 @[`VectorStore`]를 인스턴스화하면 쿼리할 수 있습니다. @[VectorStore]에는 쿼리를 위한 메서드가 포함되어 있습니다:
- 동기 및 비동기;
- 문자열 쿼리 및 벡터별;
- 유사도 점수 반환 여부;
- 유사도 및 @[maximum marginal relevance][VectorStore.max_marginal_relevance_search](쿼리와의 유사도와 검색된 결과의 다양성 간의 균형을 맞추기 위해).

메서드는 일반적으로 출력에 [Document](https://v03.api.js.langchain.com/classes/_langchain_core.documents.Document.html) 객체 목록을 포함합니다.

**사용법**

Embeddings는 일반적으로 텍스트를 "밀집" 벡터로 표현하여 유사한 의미를 가진 텍스트가 기하학적으로 가까워지도록 합니다. 이를 통해 문서에 사용된 특정 키워드에 대한 지식 없이 질문만 전달하여 관련 정보를 검색할 수 있습니다.

문자열 쿼리와의 유사도를 기반으로 문서 반환:


```typescript
const results1 = await vectorStore.similaritySearch(
  "When was Nike incorporated?"
);

console.log(results1[0]);
```
```output
Document {
    pageContent: 'direct to consumer operations sell products...',
    metadata: {'page': 4, 'source': '../example_data/nke-10k-2023.pdf', 'start_index': 3125}
}
```




점수 반환:


```typescript
const results2 = await vectorStore.similaritySearchWithScore(
  "What was Nike's revenue in 2023?"
);

console.log(results2[0]);
```
```output
Score: 0.23699893057346344

Document {
    pageContent: 'Table of Contents...',
    metadata: {'page': 35, 'source': '../example_data/nke-10k-2023.pdf', 'start_index': 0}
}
```


임베딩된 쿼리와의 유사도를 기반으로 문서 반환:


```typescript
const embedding = await embeddings.embedQuery(
  "How were Nike's margins impacted in 2023?"
);

const results3 = await vectorStore.similaritySearchVectorWithScore(
  embedding,
  1
);

console.log(results3[0]);
```
```output
Document {
    pageContent: 'FISCAL 2023 COMPARED TO FISCAL 2022...',
    metadata: {
        'page': 36,
        'source': '../example_data/nke-10k-2023.pdf',
        'start_index': 0
    }
}
```


자세히 알아보기:

- @[API Reference][VectorStore]
- [통합별 문서](/oss/javascript/integrations/vectorstores)

## 4. Retrievers

LangChain @[`VectorStore`] 객체는 @[Runnable]을 서브클래스하지 않습니다. LangChain @[Retrievers]는 Runnables이므로 표준 메서드 세트(예: 동기 및 비동기 `invoke` 및 `batch` 작업)를 구현합니다. vector stores에서 retrievers를 구성할 수 있지만, retrievers는 비벡터 저장소 데이터 소스(예: 외부 API)와도 인터페이스할 수 있습니다.



Vectorstores는 Retriever, 특히 [VectorStoreRetriever](https://python.langchain.com/api_reference/core/vectorstores/langchain_core.vectorstores.base.VectorStoreRetriever.html)를 생성하는 `as_retriever` 메서드를 구현합니다. 이러한 retrievers에는 기본 vector store의 어떤 메서드를 호출할지, 그리고 매개변수화하는 방법을 식별하는 특정 `search_type` 및 `search_kwargs` 속성이 포함됩니다. 예를 들어 다음과 같이 위의 내용을 복제할 수 있습니다:


```typescript
const retriever = vectorStore.asRetriever({
  searchType: "mmr",
  searchKwargs: {
    fetchK: 1,
  },
});

await retriever.batch([
  "When was Nike incorporated?",
  "What was Nike's revenue in 2023?",
]);
```
```output
[
    [Document {
        metadata: {'page': 4, 'source': '../example_data/nke-10k-2023.pdf', 'start_index': 3125},
        pageContent: 'direct to consumer operations sell products...',
    }],
    [Document {
        metadata: {'page': 3, 'source': '../example_data/nke-10k-2023.pdf', 'start_index': 0},
        pageContent: 'Table of Contents...',
    }],
]
```


Retrievers는 주어진 질문과 검색된 컨텍스트를 LLM의 프롬프트로 결합하는 [검색 증강 생성(RAG)](/oss/javascript/langchain/retrieval) 애플리케이션과 같은 더 복잡한 애플리케이션에 쉽게 통합될 수 있습니다. 이러한 애플리케이션 구축에 대해 자세히 알아보려면 [RAG 튜토리얼](/oss/javascript/langchain/rag) 튜토리얼을 확인하세요.


## 다음 단계

이제 PDF 문서에 대한 시맨틱 검색 엔진을 구축하는 방법을 살펴보았습니다.

document loaders에 대한 자세한 내용:

- [개요](/oss/javascript/langchain/retrieval#document_loaders)
- [사용 가능한 통합](/oss/javascript/integrations/document_loaders/)

embeddings에 대한 자세한 내용:

- [개요](/oss/javascript/langchain/retrieval#embedding_models/)
- [사용 가능한 통합](/oss/javascript/integrations/text_embedding/)

vector stores에 대한 자세한 내용:

- [개요](/oss/javascript/langchain/retrieval#vectorstores/)
- [사용 가능한 통합](/oss/javascript/integrations/vectorstores/)

RAG에 대한 자세한 내용:

- [검색 증강 생성(RAG) 앱 만들기](/oss/javascript/langchain/rag/)

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/langchain/knowledge-base.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for    real-time answers.
</Tip>
