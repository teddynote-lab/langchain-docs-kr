---
title: Agent에서의 context engineering
sidebarTitle: Context engineering
---



## 개요

Agent(또는 모든 LLM 애플리케이션)를 구축할 때 가장 어려운 부분은 충분히 신뢰할 수 있게 만드는 것입니다. 프로토타입에서는 작동할 수 있지만, 실제 사용 사례에서는 종종 실패합니다.

### Agent가 실패하는 이유는 무엇인가요?

Agent가 실패할 때, 일반적으로 agent 내부의 LLM 호출이 잘못된 작업을 수행하거나 예상한 대로 작동하지 않았기 때문입니다. LLM은 두 가지 이유 중 하나로 실패합니다:

1. 기본 LLM이 충분히 유능하지 않음
2. "올바른" context가 LLM에 전달되지 않음

대부분의 경우 - 실제로는 두 번째 이유가 agent를 신뢰할 수 없게 만드는 원인입니다.

**Context engineering**은 LLM이 작업을 수행할 수 있도록 올바른 정보와 도구를 올바른 형식으로 제공하는 것입니다. 이것은 AI Engineer의 가장 중요한 업무입니다. 이러한 "올바른" context의 부족은 더 신뢰할 수 있는 agent를 만드는 데 있어 가장 큰 장애물이며, LangChain의 agent 추상화는 context engineering을 용이하게 하도록 독특하게 설계되었습니다.

<Tip>
Context engineering이 처음이신가요? [개념 개요](/oss/javascript/concepts/context)에서 시작하여 다양한 유형의 context와 사용 시기를 이해하세요.
</Tip>

### Agent loop

일반적인 agent loop는 두 가지 주요 단계로 구성됩니다:

1. **Model call** - prompt와 사용 가능한 tool로 LLM을 호출하고, 응답 또는 tool 실행 요청을 반환합니다
2. **Tool execution** - LLM이 요청한 tool을 실행하고, tool 결과를 반환합니다

<div style={{ display: "flex", justifyContent: "center" }}>
  <img
    src="/oss/images/core_agent_loop.png"
    alt="Core agent loop diagram"
    className="rounded-lg"
  />
</div>

이 loop는 LLM이 종료하기로 결정할 때까지 계속됩니다.

### 제어할 수 있는 것

신뢰할 수 있는 agent를 구축하려면 agent loop의 각 단계에서 발생하는 일과 단계 사이에 발생하는 일을 제어해야 합니다.

| Context 유형 | 제어하는 것 | Transient 또는 Persistent |
|--------------|------------------|-------------------------|
| **[Model Context](#model-context)** | Model call에 들어가는 것 (지시사항, 메시지 기록, tool, 응답 형식) | Transient |
| **[Tool Context](#tool-context)** | Tool이 액세스하고 생성할 수 있는 것 (state, store, runtime context에 대한 읽기/쓰기) | Persistent |
| **[Life-cycle Context](#life-cycle-context)** | Model과 tool call 사이에 발생하는 것 (요약, guardrail, 로깅 등) | Persistent |

<CardGroup>
  <Card title="Transient context" icon="bolt" iconType="duotone">
    LLM이 단일 호출에서 보는 것입니다. State에 저장된 내용을 변경하지 않고 메시지, tool 또는 prompt를 수정할 수 있습니다.
  </Card>
  <Card title="Persistent context" icon="database" iconType="duotone">
    턴 전체에 걸쳐 state에 저장되는 것입니다. Life-cycle hook과 tool 쓰기는 이것을 영구적으로 수정합니다.
  </Card>
</CardGroup>

### 데이터 소스

이 과정 전반에 걸쳐 agent는 다양한 데이터 소스에 액세스(읽기/쓰기)합니다:

| 데이터 소스 | 다른 이름 | 범위 | 예시 |
|-------------|---------------|-------|----------|
| **Runtime Context** | 정적 구성 | 대화 범위 | 사용자 ID, API key, 데이터베이스 연결, 권한, 환경 설정 |
| **State** | 단기 메모리 | 대화 범위 | 현재 메시지, 업로드된 파일, 인증 상태, tool 결과 |
| **Store** | 장기 메모리 | 대화 간 | 사용자 선호도, 추출된 인사이트, 메모리, 과거 데이터 |

### 작동 방식

LangChain [middleware](/oss/javascript/langchain/middleware)는 LangChain을 사용하는 개발자에게 context engineering을 실용적으로 만드는 기본 메커니즘입니다.

Middleware를 사용하면 agent 생명주기의 모든 단계에 연결하여 다음을 수행할 수 있습니다:

* Context 업데이트
* Agent 생명주기의 다른 단계로 이동

이 가이드 전체에서 context engineering 목적을 위한 수단으로 middleware API를 자주 사용하는 것을 볼 수 있습니다.

## Model Context

각 model call에 들어가는 것을 제어합니다 - 지시사항, 사용 가능한 tool, 사용할 model, 출력 형식. 이러한 결정은 신뢰성과 비용에 직접적인 영향을 미칩니다.

<CardGroup cols={2}>
    <Card title="System Prompt" icon="message-lines" href="#system-prompt">
        개발자가 LLM에게 제공하는 기본 지시사항.
    </Card>
    <Card title="Messages" icon="comments" href="#messages">
        LLM에 전송되는 전체 메시지 목록(대화 기록).
    </Card>
    <Card title="Tools" icon="wrench" href="#tools">
        Agent가 작업을 수행하기 위해 액세스할 수 있는 유틸리티.
    </Card>
    <Card title="Model" icon="brain-circuit" href="#model">
        호출될 실제 model(구성 포함).
    </Card>
    <Card title="Response Format" icon="brackets-curly" href="#response-format">
        Model의 최종 응답에 대한 스키마 사양.
    </Card>
</CardGroup>

이러한 모든 유형의 model context는 **state**(단기 메모리), **store**(장기 메모리) 또는 **runtime context**(정적 구성)에서 가져올 수 있습니다.

### System Prompt

System prompt는 LLM의 동작과 기능을 설정합니다. 다른 사용자, context 또는 대화 단계에는 다른 지시사항이 필요합니다. 성공적인 agent는 메모리, 선호도 및 구성을 활용하여 대화의 현재 상태에 적합한 지시사항을 제공합니다.

<Tabs>
  <Tab title="State">
    State에서 메시지 수 또는 대화 context에 액세스:



    ```typescript
    import { createAgent } from "langchain";

    const agent = createAgent({
      model: "openai:gpt-4o",
      tools: [...],
      middleware: [
        dynamicSystemPromptMiddleware((state) => {
          // Read from State: check conversation length
          const messageCount = state.messages.length;

          let base = "You are a helpful assistant.";

          if (messageCount > 10) {
            base += "\nThis is a long conversation - be extra concise.";
          }

          return base;
        }),
      ],
    });
    ```

  </Tab>

  <Tab title="Store">
    장기 메모리에서 사용자 선호도에 액세스:



    ```typescript
    import * as z from "zod";
    import { createAgent, dynamicSystemPromptMiddleware } from "langchain";

    const contextSchema = z.object({
      userId: z.string(),
    });

    type Context = z.infer<typeof contextSchema>;

    const agent = createAgent({
      model: "openai:gpt-4o",
      tools: [...],
      contextSchema,
      middleware: [
        dynamicSystemPromptMiddleware<Context>(async (state, runtime) => {
          const userId = runtime.context.userId;

          // Read from Store: get user preferences
          const store = runtime.store;
          const userPrefs = await store.get(["preferences"], userId);

          let base = "You are a helpful assistant.";

          if (userPrefs) {
            const style = userPrefs.value?.communicationStyle || "balanced";
            base += `\nUser prefers ${style} responses.`;
          }

          return base;
        }),
      ],
    });
    ```

  </Tab>

  <Tab title="Runtime Context">
    Runtime Context에서 사용자 ID 또는 구성에 액세스:



    ```typescript
    import * as z from "zod";
    import { createAgent, dynamicSystemPromptMiddleware } from "langchain";

    const contextSchema = z.object({
      userRole: z.string(),
      deploymentEnv: z.string(),
    });

    type Context = z.infer<typeof contextSchema>;

    const agent = createAgent({
      model: "openai:gpt-4o",
      tools: [...],
      contextSchema,
      middleware: [
        dynamicSystemPromptMiddleware<Context>((state, runtime) => {
          // Read from Runtime Context: user role and environment
          const userRole = runtime.context.userRole;
          const env = runtime.context.deploymentEnv;

          let base = "You are a helpful assistant.";

          if (userRole === "admin") {
            base += "\nYou have admin access. You can perform all operations.";
          } else if (userRole === "viewer") {
            base += "\nYou have read-only access. Guide users to read operations only.";
          }

          if (env === "production") {
            base += "\nBe extra careful with any data modifications.";
          }

          return base;
        }),
      ],
    });
    ```

  </Tab>

</Tabs>

### Messages

Message는 LLM에 전송되는 prompt를 구성합니다.
LLM이 올바른 정보를 가지고 잘 응답할 수 있도록 메시지의 내용을 관리하는 것이 중요합니다.

<Tabs>
  <Tab title="State">
    현재 쿼리와 관련이 있을 때 State에서 업로드된 파일 context를 주입:



    ```typescript
    import { createMiddleware } from "langchain";

    const injectFileContext = createMiddleware({
      name: "InjectFileContext",
      wrapModelCall: (request, handler) => {
        // request.state is a shortcut for request.state.messages
        const uploadedFiles = request.state.uploadedFiles || [];  // [!code highlight]

        if (uploadedFiles.length > 0) {
          // Build context about available files
          const fileDescriptions = uploadedFiles.map(file =>
            `- ${file.name} (${file.type}): ${file.summary}`
          );

          const fileContext = `Files you have access to in this conversation:
${fileDescriptions.join("\n")}

Reference these files when answering questions.`;

          // Inject file context before recent messages
          const messages = [  // [!code highlight]
            ...request.messages  // Rest of conversation
            { role: "user", content: fileContext }
          ];
          request = request.override({ messages });  // [!code highlight]
        }

        return handler(request);
      },
    });

    const agent = createAgent({
      model: "openai:gpt-4o",
      tools: [...],
      middleware: [injectFileContext],
    });
    ```

  </Tab>

  <Tab title="Store">
    초안 작성을 안내하기 위해 Store에서 사용자의 이메일 작성 스타일을 주입:



    ```typescript
    import * as z from "zod";
    import { createMiddleware } from "langchain";

    const contextSchema = z.object({
      userId: z.string(),
    });

    const injectWritingStyle = createMiddleware({
      name: "InjectWritingStyle",
      contextSchema,
      wrapModelCall: async (request, handler) => {
        const userId = request.runtime.context.userId;  // [!code highlight]

        // Read from Store: get user's writing style examples
        const store = request.runtime.store;  // [!code highlight]
        const writingStyle = await store.get(["writing_style"], userId);  // [!code highlight]

        if (writingStyle) {
          const style = writingStyle.value;
          // Build style guide from stored examples
          const styleContext = `Your writing style:
- Tone: ${style.tone || 'professional'}
- Typical greeting: "${style.greeting || 'Hi'}"
- Typical sign-off: "${style.signOff || 'Best'}"
- Example email you've written:
${style.exampleEmail || ''}`;

          // Append at end - models pay more attention to final messages
          const messages = [
            ...request.messages,
            { role: "user", content: styleContext }
          ];
          request = request.override({ messages });  // [!code highlight]
        }

        return handler(request);
      },
    });
    ```

  </Tab>

  <Tab title="Runtime Context">
    사용자의 관할권에 따라 Runtime Context에서 규정 준수 규칙을 주입:



    ```typescript
    import * as z from "zod";
    import { createMiddleware } from "langchain";

    const contextSchema = z.object({
      userJurisdiction: z.string(),
      industry: z.string(),
      complianceFrameworks: z.array(z.string()),
    });

    type Context = z.infer<typeof contextSchema>;

    const injectComplianceRules = createMiddleware<Context>({
      name: "InjectComplianceRules",
      contextSchema,
      wrapModelCall: (request, handler) => {
        // Read from Runtime Context: get compliance requirements
        const { userJurisdiction, industry, complianceFrameworks } = request.runtime.context;  // [!code highlight]

        // Build compliance constraints
        const rules = [];
        if (complianceFrameworks.includes("GDPR")) {
          rules.push("- Must obtain explicit consent before processing personal data");
          rules.push("- Users have right to data deletion");
        }
        if (complianceFrameworks.includes("HIPAA")) {
          rules.push("- Cannot share patient health information without authorization");
          rules.push("- Must use secure, encrypted communication");
        }
        if (industry === "finance") {
          rules.push("- Cannot provide financial advice without proper disclaimers");
        }

        if (rules.length > 0) {
          const complianceContext = `Compliance requirements for ${userJurisdiction}:
${rules.join("\n")}`;

          // Append at end - models pay more attention to final messages
          const messages = [
            ...request.messages,
            { role: "user", content: complianceContext }
          ];
          request = request.override({ messages });  // [!code highlight]
        }

        return handler(request);
      },
    });
    ```

  </Tab>

</Tabs>

<Note>
**Transient vs Persistent 메시지 업데이트:**

위의 예제는 `wrap_model_call`을 사용하여 **transient** 업데이트를 수행합니다 - state에 저장된 내용을 변경하지 않고 단일 호출에 대해 model에 전송되는 메시지를 수정합니다.

State를 수정하는 **persistent** 업데이트(예: [Life-cycle Context](#summarization)의 요약 예제)의 경우, `before_model` 또는 `after_model`과 같은 life-cycle hook을 사용하여 대화 기록을 영구적으로 업데이트하세요. 자세한 내용은 [middleware 문서](/oss/javascript/langchain/middleware)를 참조하세요.
</Note>

### Tools

Tool을 사용하면 model이 데이터베이스, API 및 외부 시스템과 상호 작용할 수 있습니다. Tool을 정의하고 선택하는 방법은 model이 작업을 효과적으로 완료할 수 있는지 여부에 직접적인 영향을 미칩니다.

#### Tool 정의

각 tool에는 명확한 이름, 설명, 인수 이름 및 인수 설명이 필요합니다. 이것들은 단순한 메타데이터가 아닙니다—tool을 언제 어떻게 사용할지에 대한 model의 추론을 안내합니다.



```typescript
import { tool } from "@langchain/core/tools";
import { z } from "zod";

const searchOrders = tool(
  async ({ userId, status, limit = 10 }) => {
    // Implementation here
  },
  {
    name: "search_orders",
    description: `Search for user orders by status.

    Use this when the user asks about order history or wants to check
    order status. Always filter by the provided status.`,
    schema: z.object({
      userId: z.string().describe("Unique identifier for the user"),
      status: z.enum(["pending", "shipped", "delivered"]).describe("Order status to filter by"),
      limit: z.number().default(10).describe("Maximum number of results to return"),
    }),
  }
);
```


#### Tool 선택

모든 tool이 모든 상황에 적합한 것은 아닙니다. 너무 많은 tool은 model을 압도하고(context 과부하) 오류를 증가시킬 수 있습니다; 너무 적으면 기능이 제한됩니다. 동적 tool 선택은 인증 상태, 사용자 권한, feature flag 또는 대화 단계에 따라 사용 가능한 toolset을 조정합니다.

<Tabs>
  <Tab title="State">
    특정 대화 이정표 이후에만 고급 tool 활성화:



    ```typescript
    import { createMiddleware } from "langchain";

    const stateBasedTools = createMiddleware({
      name: "StateBasedTools",
      wrapModelCall: (request, handler) => {
        // Read from State: check authentication and conversation length
        const state = request.state;  // [!code highlight]
        const isAuthenticated = state.authenticated || false;  // [!code highlight]
        const messageCount = state.messages.length;

        let filteredTools = request.tools;

        // Only enable sensitive tools after authentication
        if (!isAuthenticated) {
          filteredTools = request.tools.filter(t => t.name.startsWith("public_"));  // [!code highlight]
        } else if (messageCount < 5) {
          filteredTools = request.tools.filter(t => t.name !== "advanced_search");  // [!code highlight]
        }

        return handler({ ...request, tools: filteredTools });  // [!code highlight]
      },
    });
    ```

  </Tab>

  <Tab title="Store">
    Store의 사용자 선호도 또는 feature flag에 따라 tool 필터링:



    ```typescript
    import * as z from "zod";
    import { createMiddleware } from "langchain";

    const contextSchema = z.object({
      userId: z.string(),
    });

    const storeBasedTools = createMiddleware({
      name: "StoreBasedTools",
      contextSchema,
      wrapModelCall: async (request, handler) => {
        const userId = request.runtime.context.userId;  // [!code highlight]

        // Read from Store: get user's enabled features
        const store = request.runtime.store;  // [!code highlight]
        const featureFlags = await store.get(["features"], userId);  // [!code highlight]

        let filteredTools = request.tools;

        if (featureFlags) {
          const enabledFeatures = featureFlags.value?.enabledTools || [];
          filteredTools = request.tools.filter(t => enabledFeatures.includes(t.name));  // [!code highlight]
        }

        return handler({ ...request, tools: filteredTools });  // [!code highlight]
      },
    });
    ```

  </Tab>

  <Tab title="Runtime Context">
    Runtime Context의 사용자 권한에 따라 tool 필터링:



    ```typescript
    import * as z from "zod";
    import { createMiddleware } from "langchain";

    const contextSchema = z.object({
      userRole: z.string(),
    });

    const contextBasedTools = createMiddleware({
      name: "ContextBasedTools",
      contextSchema,
      wrapModelCall: (request, handler) => {
        // Read from Runtime Context: get user role
        const userRole = request.runtime.context.userRole;  // [!code highlight]

        let filteredTools = request.tools;

        if (userRole === "admin") {
          // Admins get all tools
        } else if (userRole === "editor") {
          filteredTools = request.tools.filter(t => t.name !== "delete_data");  // [!code highlight]
        } else {
          filteredTools = request.tools.filter(t => t.name.startsWith("read_"));  // [!code highlight]
        }

        return handler({ ...request, tools: filteredTools });  // [!code highlight]
      },
    });
    ```

  </Tab>
</Tabs>

더 많은 예제는 [동적으로 tool 선택하기](/oss/javascript/langchain/middleware#dynamically-selecting-tools)를 참조하세요.

### Model

다른 model은 다른 강점, 비용 및 context window를 가지고 있습니다. 당면한 작업에 적합한 model을 선택하세요. 이는 agent 실행 중에 변경될 수 있습니다.

<Tabs>
  <Tab title="State">
    State의 대화 길이에 따라 다른 model 사용:



    ```typescript
    import { createMiddleware, initChatModel } from "langchain";

    // Initialize models once outside the middleware
    const largeModel = initChatModel("anthropic:claude-sonnet-4-5");
    const standardModel = initChatModel("openai:gpt-4o");
    const efficientModel = initChatModel("openai:gpt-4o-mini");

    const stateBasedModel = createMiddleware({
      name: "StateBasedModel",
      wrapModelCall: (request, handler) => {
        // request.messages is a shortcut for request.state.messages
        const messageCount = request.messages.length;  // [!code highlight]
        let model;

        if (messageCount > 20) {
          model = largeModel;
        } else if (messageCount > 10) {
          model = standardModel;
        } else {
          model = efficientModel;
        }

        return handler({ ...request, model });  // [!code highlight]
      },
    });
    ```

  </Tab>

  <Tab title="Store">
    Store에서 사용자가 선호하는 model 사용:



    ```typescript
    import * as z from "zod";
    import { createMiddleware, initChatModel } from "langchain";

    const contextSchema = z.object({
      userId: z.string(),
    });

    // Initialize available models once
    const MODEL_MAP = {
      "gpt-4o": initChatModel("openai:gpt-4o"),
      "gpt-4o-mini": initChatModel("openai:gpt-4o-mini"),
      "claude-sonnet": initChatModel("anthropic:claude-sonnet-4-5"),
    };

    const storeBasedModel = createMiddleware({
      name: "StoreBasedModel",
      contextSchema,
      wrapModelCall: async (request, handler) => {
        const userId = request.runtime.context.userId;  // [!code highlight]

        // Read from Store: get user's preferred model
        const store = request.runtime.store;  // [!code highlight]
        const userPrefs = await store.get(["preferences"], userId);  // [!code highlight]

        let model = request.model;

        if (userPrefs) {
          const preferredModel = userPrefs.value?.preferredModel;
          if (preferredModel && MODEL_MAP[preferredModel]) {
            model = MODEL_MAP[preferredModel];  // [!code highlight]
          }
        }

        return handler({ ...request, model });  // [!code highlight]
      },
    });
    ```

  </Tab>

  <Tab title="Runtime Context">
    Runtime Context의 비용 제한 또는 환경에 따라 model 선택:



    ```typescript
    import * as z from "zod";
    import { createMiddleware, initChatModel } from "langchain";

    const contextSchema = z.object({
      costTier: z.string(),
      environment: z.string(),
    });

    // Initialize models once outside the middleware
    const premiumModel = initChatModel("anthropic:claude-sonnet-4-5");
    const standardModel = initChatModel("openai:gpt-4o");
    const budgetModel = initChatModel("openai:gpt-4o-mini");

    const contextBasedModel = createMiddleware({
      name: "ContextBasedModel",
      contextSchema,
      wrapModelCall: (request, handler) => {
        // Read from Runtime Context: cost tier and environment
        const costTier = request.runtime.context.costTier;  // [!code highlight]
        const environment = request.runtime.context.environment;  // [!code highlight]

        let model;

        if (environment === "production" && costTier === "premium") {
          model = premiumModel;
        } else if (costTier === "budget") {
          model = budgetModel;
        } else {
          model = standardModel;
        }

        return handler({ ...request, model });  // [!code highlight]
      },
    });
    ```

  </Tab>
</Tabs>

더 많은 예제는 [동적 model](/oss/javascript/langchain/agents#dynamic-model)을 참조하세요.

### Response Format

구조화된 출력은 비구조화된 텍스트를 검증된 구조화된 데이터로 변환합니다. 특정 필드를 추출하거나 다운스트림 시스템에 대한 데이터를 반환할 때 자유 형식 텍스트는 충분하지 않습니다.

**작동 방식:** 응답 형식으로 스키마를 제공하면 model의 최종 응답이 해당 스키마를 준수하도록 보장됩니다. Agent는 model이 tool 호출을 완료할 때까지 model / tool 호출 loop를 실행한 다음 최종 응답이 제공된 형식으로 강제 변환됩니다.

#### 형식 정의

스키마 정의는 model을 안내합니다. 필드 이름, 유형 및 설명은 출력이 준수해야 하는 형식을 정확히 지정합니다.



```typescript
import { z } from "zod";

const customerSupportTicket = z.object({
  category: z.enum(["billing", "technical", "account", "product"]).describe(
    "Issue category"
  ),
  priority: z.enum(["low", "medium", "high", "critical"]).describe(
    "Urgency level"
  ),
  summary: z.string().describe(
    "One-sentence summary of the customer's issue"
  ),
  customerSentiment: z.enum(["frustrated", "neutral", "satisfied"]).describe(
    "Customer's emotional tone"
  ),
}).describe("Structured ticket information extracted from customer message");
```


#### 형식 선택

동적 응답 형식 선택은 사용자 선호도, 대화 단계 또는 역할에 따라 스키마를 조정합니다—초기에는 간단한 형식을 반환하고 복잡성이 증가함에 따라 상세한 형식을 반환합니다.

<Tabs>
  <Tab title="State">
    대화 state에 따라 구조화된 출력 구성:



    ```typescript
    import { createMiddleware } from "langchain";
    import { z } from "zod";

    const simpleResponse = z.object({
      answer: z.string().describe("A brief answer"),
    });

    const detailedResponse = z.object({
      answer: z.string().describe("A detailed answer"),
      reasoning: z.string().describe("Explanation of reasoning"),
      confidence: z.number().describe("Confidence score 0-1"),
    });

    const stateBasedOutput = createMiddleware({
      name: "StateBasedOutput",
      wrapModelCall: (request, handler) => {
        // request.state is a shortcut for request.state.messages
        const messageCount = request.messages.length;  // [!code highlight]

        if (messageCount < 3) {
          // Early conversation - use simple format
          responseFormat = simpleResponse; // [!code highlight]
        } else {
          // Established conversation - use detailed format
          responseFormat = detailedResponse; // [!code highlight]
        }

        return handler({ ...request, responseFormat });
      },
    });
    ```

  </Tab>

  <Tab title="Store">
    Store의 사용자 선호도에 따라 출력 형식 구성:



    ```typescript
    import * as z from "zod";
    import { createMiddleware } from "langchain";

    const contextSchema = z.object({
      userId: z.string(),
    });

    const verboseResponse = z.object({
      answer: z.string().describe("Detailed answer"),
      sources: z.array(z.string()).describe("Sources used"),
    });

    const conciseResponse = z.object({
      answer: z.string().describe("Brief answer"),
    });

    const storeBasedOutput = createMiddleware({
      name: "StoreBasedOutput",
      wrapModelCall: async (request, handler) => {
        const userId = request.runtime.context.userId;  // [!code highlight]

        // Read from Store: get user's preferred response style
        const store = request.runtime.store;  // [!code highlight]
        const userPrefs = await store.get(["preferences"], userId);  // [!code highlight]

        if (userPrefs) {
          const style = userPrefs.value?.responseStyle || "concise";
          if (style === "verbose") {
            request.responseFormat = verboseResponse;  // [!code highlight]
          } else {
            request.responseFormat = conciseResponse;  // [!code highlight]
          }
        }

        return handler(request);
      },
    });
    ```

  </Tab>

  <Tab title="Runtime Context">
    사용자 역할 또는 환경과 같은 Runtime Context에 따라 출력 형식 구성:



    ```typescript
    import * as z from "zod";
    import { createMiddleware } from "langchain";

    const contextSchema = z.object({
      userRole: z.string(),
      environment: z.string(),
    });

    const adminResponse = z.object({
      answer: z.string().describe("Answer"),
      debugInfo: z.record(z.any()).describe("Debug information"),
      systemStatus: z.string().describe("System status"),
    });

    const userResponse = z.object({
      answer: z.string().describe("Answer"),
    });

    const contextBasedOutput = createMiddleware({
      name: "ContextBasedOutput",
      wrapModelCall: (request, handler) => {
        // Read from Runtime Context: user role and environment
        const userRole = request.runtime.context.userRole;  // [!code highlight]
        const environment = request.runtime.context.environment;  // [!code highlight]

        if (userRole === "admin" && environment === "production") {
          responseFormat = adminResponse;  // [!code highlight]
        } else {
          responseFormat = userResponse;  // [!code highlight]
        }

        return handler({ ...request, responseFormat });
      },
    });
    ```

  </Tab>
</Tabs>

## Tool Context

Tool은 context를 읽고 쓰는 점에서 특별합니다.

가장 기본적인 경우, tool이 실행될 때 LLM의 요청 매개변수를 받고 tool 메시지를 반환합니다. Tool은 작업을 수행하고 결과를 생성합니다.

Tool은 또한 model이 작업을 수행하고 완료할 수 있도록 하는 중요한 정보를 가져올 수 있습니다.

### 읽기

대부분의 실제 tool은 LLM의 매개변수 이상이 필요합니다. 데이터베이스 쿼리를 위한 사용자 ID, 외부 서비스를 위한 API key 또는 결정을 내리기 위한 현재 세션 state가 필요합니다. Tool은 이 정보에 액세스하기 위해 state, store 및 runtime context에서 읽습니다.

<Tabs>
  <Tab title="State">
    현재 세션 정보를 확인하기 위해 State에서 읽기:



    ```typescript
    import * as z from "zod";
    import { tool } from "@langchain/core/tools";
    import { createAgent } from "langchain";

    const checkAuthentication = tool(
      async (_, { runtime }) => {
        // Read from State: check current auth status
        const currentState = runtime.state;
        const isAuthenticated = currentState.authenticated || false;

        if (isAuthenticated) {
          return "User is authenticated";
        } else {
          return "User is not authenticated";
        }
      },
      {
        name: "check_authentication",
        description: "Check if user is authenticated",
        schema: z.object({}),
      }
    );
    ```

  </Tab>

  <Tab title="Store">
    지속된 사용자 선호도에 액세스하기 위해 Store에서 읽기:



    ```typescript
    import * as z from "zod";
    import { tool } from "@langchain/core/tools";
    import { createAgent } from "langchain";

    const contextSchema = z.object({
      userId: z.string(),
    });

    const getPreference = tool(
      async ({ preferenceKey }, { runtime }) => {
        const userId = runtime.context.userId;

        // Read from Store: get existing preferences
        const store = runtime.store;
        const existingPrefs = await store.get(["preferences"], userId);

        if (existingPrefs) {
          const value = existingPrefs.value?.[preferenceKey];
          return value ? `${preferenceKey}: ${value}` : `No preference set for ${preferenceKey}`;
        } else {
          return "No preferences found";
        }
      },
      {
        name: "get_preference",
        description: "Get user preference from Store",
        schema: z.object({
          preferenceKey: z.string(),
        }),
      }
    );
    ```

  </Tab>

  <Tab title="Runtime Context">
    API key 및 사용자 ID와 같은 구성을 위해 Runtime Context에서 읽기:



    ```typescript
    import * as z from "zod";
    import { tool } from "@langchain/core/tools";
    import { createAgent } from "langchain";

    const contextSchema = z.object({
      userId: z.string(),
      apiKey: z.string(),
      dbConnection: z.string(),
    });

    const fetchUserData = tool(
      async ({ query }, { runtime }) => {
        // Read from Runtime Context: get API key and DB connection
        const { userId, apiKey, dbConnection } = runtime.context;

        // Use configuration to fetch data
        const results = await performDatabaseQuery(dbConnection, query, apiKey);

        return `Found ${results.length} results for user ${userId}`;
      },
      {
        name: "fetch_user_data",
        description: "Fetch data using Runtime Context configuration",
        schema: z.object({
          query: z.string(),
        }),
      }
    );

    const agent = createAgent({
      model: "openai:gpt-4o",
      tools: [fetchUserData],
      contextSchema,
    });
    ```

  </Tab>
</Tabs>

### 쓰기

Tool 결과는 agent가 주어진 작업을 완료하는 데 도움이 될 수 있습니다. Tool은 결과를 model에 직접 반환하고 agent의 메모리를 업데이트하여 향후 단계에서 중요한 context를 사용할 수 있도록 할 수 있습니다.

<Tabs>
  <Tab title="State">
    Command를 사용하여 세션별 정보를 추적하기 위해 State에 쓰기:



    ```typescript
    import * as z from "zod";
    import { tool } from "@langchain/core/tools";
    import { createAgent } from "langchain";
    import { Command } from "@langchain/langgraph";

    const authenticateUser = tool(
      async ({ password }, { runtime }) => {
        // Perform authentication
        if (password === "correct") {
          // Write to State: mark as authenticated using Command
          return new Command({
            update: { authenticated: true },
          });
        } else {
          return new Command({ update: { authenticated: false } });
        }
      },
      {
        name: "authenticate_user",
        description: "Authenticate user and update State",
        schema: z.object({
          password: z.string(),
        }),
      }
    );
    ```

  </Tab>

  <Tab title="Store">
    세션 간에 데이터를 지속하기 위해 Store에 쓰기:



    ```typescript
    import * as z from "zod";
    import { tool } from "@langchain/core/tools";
    import { createAgent } from "langchain";

    const contextSchema = z.object({
      userId: z.string(),
    });

    const savePreference = tool(
      async ({ preferenceKey, preferenceValue }, { runtime }) => {
        const userId = runtime.context.userId;

        // Read existing preferences
        const store = runtime.store;
        const existingPrefs = await store.get(["preferences"], userId);

        // Merge with new preference
        const prefs = existingPrefs?.value || {};
        prefs[preferenceKey] = preferenceValue;

        // Write to Store: save updated preferences
        await store.put(["preferences"], userId, prefs);

        return `Saved preference: ${preferenceKey} = ${preferenceValue}`;
      },
      {
        name: "save_preference",
        description: "Save user preference to Store",
        schema: z.object({
          preferenceKey: z.string(),
          preferenceValue: z.string(),
        }),
      }
    );
    ```

  </Tab>
</Tabs>

Tool에서 state, store 및 runtime context에 액세스하는 포괄적인 예제는 [Tools](/oss/javascript/langchain/tools)를 참조하세요.

## Life-cycle Context

핵심 agent 단계 **사이**에 발생하는 것을 제어합니다 - 요약, guardrail 및 로깅과 같은 교차 관심사를 구현하기 위해 데이터 흐름을 가로챕니다.

[Model Context](#model-context) 및 [Tool Context](#tool-context)에서 보았듯이, [middleware](/oss/javascript/langchain/middleware)는 context engineering을 실용적으로 만드는 메커니즘입니다. Middleware를 사용하면 agent 생명주기의 모든 단계에 연결하여 다음 중 하나를 수행할 수 있습니다:

1. **Context 업데이트** - 변경 사항을 지속하고, 대화 기록을 업데이트하거나, 인사이트를 저장하기 위해 state 및 store를 수정합니다
2. **생명주기에서 이동** - context에 따라 agent 주기의 다른 단계로 이동합니다(예: 조건이 충족되면 tool 실행을 건너뛰고, 수정된 context로 model call을 반복)

<div style={{ display: "flex", justifyContent: "center" }}>
  <img
    src="/oss/images/middleware_final.png"
    alt="Middleware hooks in the agent loop"
    className="rounded-lg"
  />
</div>

### 예제: 요약

가장 일반적인 life-cycle 패턴 중 하나는 대화 기록이 너무 길어질 때 자동으로 압축하는 것입니다. [Model Context](#messages)에 표시된 transient 메시지 트리밍과 달리, 요약은 **state를 영구적으로 업데이트**합니다 - 이전 메시지를 향후 모든 턴에 대해 저장되는 요약으로 영구적으로 대체합니다.

LangChain은 이를 위한 내장 middleware를 제공합니다:



```typescript
import { createAgent, summarizationMiddleware } from "langchain";

const agent = createAgent({
  model: "openai:gpt-4o",
  tools: [...],
  middleware: [
    summarizationMiddleware({
      model: "openai:gpt-4o-mini",
      maxTokensBeforeSummary: 4000, // Trigger summarization at 4000 tokens
      messagesToKeep: 20, // Keep last 20 messages after summary
    }),
  ],
});
```


대화가 토큰 제한을 초과하면 `SummarizationMiddleware`가 자동으로:
1. 별도의 LLM 호출을 사용하여 이전 메시지를 요약합니다
2. State에서 요약 메시지로 대체합니다(영구적으로)
3. Context를 위해 최근 메시지를 그대로 유지합니다

요약된 대화 기록은 영구적으로 업데이트됩니다 - 향후 턴에서는 원본 메시지 대신 요약을 볼 수 있습니다.

<Note>
내장 middleware의 전체 목록, 사용 가능한 hook 및 사용자 정의 middleware를 만드는 방법은 [Middleware 문서](/oss/javascript/langchain/middleware)를 참조하세요.
</Note>

## 모범 사례

1. **간단하게 시작** - 정적 prompt와 tool로 시작하고, 필요할 때만 동적 기능을 추가하세요
2. **점진적으로 테스트** - 한 번에 하나의 context engineering 기능을 추가하세요
3. **성능 모니터링** - Model call, 토큰 사용량 및 지연 시간을 추적하세요
4. **내장 middleware 사용** - [`SummarizationMiddleware`](/oss/javascript/langchain/middleware#summarization), [`LLMToolSelectorMiddleware`](/oss/javascript/langchain/middleware#llm-tool-selector) 등을 활용하세요
5. **Context 전략 문서화** - 어떤 context가 전달되고 있는지, 그 이유를 명확히 하세요
6. **Transient vs persistent 이해**: Model context 변경은 transient(호출당)이며, life-cycle context 변경은 state에 지속됩니다

## 관련 리소스

- [Context 개념 개요](/oss/javascript/concepts/context) - Context 유형과 사용 시기 이해
- [Middleware](/oss/javascript/langchain/middleware) - 완전한 middleware 가이드
- [Tools](/oss/javascript/langchain/tools) - Tool 생성 및 context 액세스
- [Memory](/oss/javascript/concepts/memory) - 단기 및 장기 메모리 패턴
- [Agents](/oss/javascript/langchain/agents) - 핵심 agent 개념

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/langchain/context-engineering.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for    real-time answers.
</Tip>
