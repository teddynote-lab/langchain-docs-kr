---
title: SQL agent 만들기
sidebarTitle: SQL agent
---

import ChatModelTabsPy from '/snippets/chat-model-tabs.mdx';
import ChatModelTabsJS from '/snippets/chat-model-tabs-js.mdx';


## Overview

이 튜토리얼에서는 LangChain [agents](/oss/javascript/langchain/agents)를 사용하여 SQL 데이터베이스에 대한 질문에 답변할 수 있는 agent를 만드는 방법을 배웁니다.

높은 수준에서 agent는 다음을 수행합니다:

<Steps>
<Step title="데이터베이스에서 사용 가능한 테이블과 스키마 가져오기" />
<Step title="질문과 관련된 테이블 결정하기" />
<Step title="관련 테이블의 스키마 가져오기" />
<Step title="질문과 스키마 정보를 기반으로 쿼리 생성하기" />
<Step title="LLM을 사용하여 일반적인 실수가 있는지 쿼리 재확인하기" />
<Step title="쿼리를 실행하고 결과 반환하기" />
<Step title="쿼리가 성공할 때까지 데이터베이스 엔진에서 발생한 오류 수정하기" />
<Step title="결과를 기반으로 응답 작성하기" />
</Steps>

<Warning>
SQL 데이터베이스의 Q&A 시스템을 구축하려면 모델이 생성한 SQL 쿼리를 실행해야 합니다. 이를 수행하는 데는 본질적인 위험이 있습니다. 데이터베이스 연결 권한이 항상 agent의 필요에 따라 가능한 한 좁게 범위가 지정되어 있는지 확인하세요. 이렇게 하면 모델 기반 시스템 구축의 위험을 완화할 수 있지만 완전히 제거할 수는 없습니다.
</Warning>

### Concepts

다음 개념을 다룰 것입니다:

- SQL 데이터베이스에서 읽기 위한 [Tools](/oss/javascript/langchain/tools)
- LangChain [agents](/oss/javascript/langchain/agents)
- [Human-in-the-loop](/oss/javascript/langchain/human-in-the-loop) 프로세스


## Setup

### Installation


    <CodeGroup>
    ```bash npm
    npm i langchain @langchain/core typeorm sqlite3 zod
    ```
    ```bash yarn
    yarn add langchain @langchain/core typeorm sqlite3 zod
    ```
    ```bash pnpm
    pnpm add langchain @langchain/core typeorm sqlite3 zod
    ```
    </CodeGroup>


### LangSmith
chain 또는 agent 내부에서 무슨 일이 일어나고 있는지 검사하려면 [LangSmith](https://smith.langchain.com)를 설정하세요. 그런 다음 다음 환경 변수를 설정하세요:

    ```shell
    export LANGSMITH_TRACING="true"
    export LANGSMITH_API_KEY="..."
    ```

## 1. LLM 선택하기


[tool-calling](/oss/javascript/integrations/providers/overview)을 지원하는 모델을 선택하세요:
<ChatModelTabsJS />


아래 예제에 표시된 출력은 OpenAI를 사용했습니다.

## 2. 데이터베이스 구성하기

이 튜토리얼에서는 [SQLite database](https://www.sqlitetutorial.net/sqlite-sample-database/)를 생성할 것입니다. SQLite는 설정하고 사용하기 쉬운 경량 데이터베이스입니다. 디지털 미디어 스토어를 나타내는 샘플 데이터베이스인 `chinook` 데이터베이스를 로드할 것입니다.

편의를 위해 공개 GCS 버킷에 데이터베이스(`Chinook.db`)를 호스팅했습니다.


```typescript
import fs from "node:fs/promises";
import path from "node:path";

const url = "https://storage.googleapis.com/benchmarks-artifacts/chinook/Chinook.db";
const localPath = path.resolve("Chinook.db");

async function resolveDbPath() {
  if (await fs.exists(localPath)) {
    return localPath;
  }
  const resp = await fetch(url);
  if (!resp.ok) throw new Error(`Failed to download DB. Status code: ${resp.status}`);
  const buf = Buffer.from(await resp.arrayBuffer());
  await fs.writeFile(localPath, buf);
  return localPath;
}
```



## 3. 데이터베이스 상호 작용을 위한 tool 추가하기

데이터베이스와 상호 작용하기 위해 `langchain/sql_db`에서 사용 가능한 `SqlDatabase` wrapper를 사용하세요. wrapper는 SQL 쿼리를 실행하고 결과를 가져오는 간단한 인터페이스를 제공합니다:
```typescript
import { SqlDatabase } from "@langchain/classic/sql_db";
import { DataSource } from "typeorm";

let db: SqlDatabase | undefined;
async function getDb() {
  if (!db) {
    const dbPath = await resolveDbFile();
    const datasource = new DataSource({ type: "sqlite", database: dbPath });
    db = await SqlDatabase.fromDataSourceParams({ appDataSource: datasource });
  }
  return db;
}

async function getSchema() {
  const db = await getDb();
  return await db.getTableInfo();
}
```




## 6. Human-in-the-loop 검토 구현하기

의도하지 않은 작업이나 비효율성을 위해 agent의 SQL 쿼리를 실행하기 전에 확인하는 것이 신중할 수 있습니다.

LangChain agent는 agent tool 호출에 대한 감독을 추가하기 위한 내장 [human-in-the-loop middleware](/oss/javascript/langchain/human-in-the-loop) 지원 기능을 제공합니다. `sql_db_query` tool 호출 시 사람의 검토를 위해 일시 중지하도록 agent를 구성해 보겠습니다:

```python
from langchain.agents import create_agent
from langchain.agents.middleware import HumanInTheLoopMiddleware # [!code highlight]
from langgraph.checkpoint.memory import InMemorySaver # [!code highlight]


agent = create_agent(
    model,
    tools,
    system_prompt=system_prompt,
    middleware=[ # [!code highlight]
        HumanInTheLoopMiddleware( # [!code highlight]
            interrupt_on={"sql_db_query": True}, # [!code highlight]
            description_prefix="Tool execution pending approval", # [!code highlight]
        ), # [!code highlight]
    ], # [!code highlight]
    checkpointer=InMemorySaver(), # [!code highlight]
)
```
<Note>
실행을 일시 중지하고 재개할 수 있도록 agent에 [checkpointer](/oss/javascript/langchain/short-term-memory)를 추가했습니다. 이에 대한 세부 정보와 사용 가능한 middleware 구성은 [human-in-the-loop guide](/oss/javascript/langchain/human-in-the-loop)를 참조하세요.
</Note>

agent를 실행하면 이제 `sql_db_query` tool을 실행하기 전에 검토를 위해 일시 중지됩니다:
```python
question = "Which genre on average has the longest tracks?"
config = {"configurable": {"thread_id": "1"}} # [!code highlight]

for step in agent.stream(
    {"messages": [{"role": "user", "content": question}]},
    config, # [!code highlight]
    stream_mode="values",
):
    if "messages" in step:
        step["messages"][-1].pretty_print()
    elif "__interrupt__" in step: # [!code highlight]
        print("INTERRUPTED:") # [!code highlight]
        interrupt = step["__interrupt__"][0] # [!code highlight]
        for request in interrupt.value["action_requests"]: # [!code highlight]
            print(request["description"]) # [!code highlight]
    else:
        pass
```
```
...

INTERRUPTED:
Tool execution pending approval

Tool: sql_db_query
Args: {'query': 'SELECT g.Name AS Genre, AVG(t.Milliseconds) AS AvgTrackLength FROM Track t JOIN Genre g ON t.GenreId = g.GenreId GROUP BY g.Name ORDER BY AvgTrackLength DESC LIMIT 1;'}
```
이 경우 쿼리를 수락하여 [Command](/oss/javascript/langgraph/use-graph-api#combine-control-flow-and-state-updates-with-command)를 사용하여 실행을 재개할 수 있습니다:
```python
from langgraph.types import Command # [!code highlight]

for step in agent.stream(
    Command(resume={"decisions": [{"type": "approve"}]}), # [!code highlight]
    config,
    stream_mode="values",
):
    if "messages" in step:
        step["messages"][-1].pretty_print()
    elif "__interrupt__" in step:
        print("INTERRUPTED:")
        interrupt = step["__interrupt__"][0]
        for request in interrupt.value["action_requests"]:
            print(request["description"])
    else:
        pass
```
```
================================== Ai Message ==================================
Tool Calls:
  sql_db_query (call_7oz86Epg7lYRqi9rQHbZPS1U)
 Call ID: call_7oz86Epg7lYRqi9rQHbZPS1U
  Args:
    query: SELECT Genre.Name, AVG(Track.Milliseconds) AS AvgDuration FROM Track JOIN Genre ON Track.GenreId = Genre.GenreId GROUP BY Genre.Name ORDER BY AvgDuration DESC LIMIT 5;
================================= Tool Message =================================
Name: sql_db_query

[('Sci Fi & Fantasy', 2911783.0384615385), ('Science Fiction', 2625549.076923077), ('Drama', 2575283.78125), ('TV Shows', 2145041.0215053763), ('Comedy', 1585263.705882353)]
================================== Ai Message ==================================

The genre with the longest average track length is "Sci Fi & Fantasy" with an average duration of about 2,911,783 milliseconds, followed by "Science Fiction" and "Drama."
```

자세한 내용은 [human-in-the-loop guide](/oss/javascript/langchain/human-in-the-loop)를 참조하세요.

## 4. SQL 쿼리 실행하기

명령을 실행하기 전에 `_safe_sql`에서 LLM이 생성한 명령을 확인하세요:

```typescript

const DENY_RE = /\b(INSERT|UPDATE|DELETE|ALTER|DROP|CREATE|REPLACE|TRUNCATE)\b/i;
const HAS_LIMIT_TAIL_RE = /\blimit\b\s+\d+(\s*,\s*\d+)?\s*;?\s*$/i;

function sanitizeSqlQuery(q) {
  let query = String(q ?? "").trim();

  // block multiple statements (allow one optional trailing ;)
  const semis = [...query].filter((c) => c === ";").length;
  if (semis > 1 || (query.endsWith(";") && query.slice(0, -1).includes(";"))) {
    throw new Error("multiple statements are not allowed.")
  }
  query = query.replace(/;+\s*$/g, "").trim();

  // read-only gate
  if (!query.toLowerCase().startsWith("select")) {
    throw new Error("Only SELECT statements are allowed")
  }
  if (DENY_RE.test(query)) {
    throw new Error("DML/DDL detected. Only read-only queries are permitted.")
  }

  // append LIMIT only if not already present
  if (!HAS_LIMIT_TAIL_RE.test(query)) {
    query += " LIMIT 5";
  }
  return query;
}

```

그런 다음 `SQLDatabase`의 `run`을 사용하여 `execute_sql` tool로 명령을 실행하세요:

```typescript
import { tool } from "langchain"
import * as z from "zod";

const executeSql = tool(
  async ({ query }) => {
    const q = sanitizeSqlQuery(query);
    try {
      const result = await db.run(q);
      return typeof result === "string" ? result : JSON.stringify(result, null, 2);
    } catch (e) {
      throw new Error(e?.message ?? String(e))
    }
  },
  {
    name: "execute_sql",
    description: "Execute a READ-ONLY SQLite SELECT query and return results.",
    schema: z.object({
      query: z.string().describe("SQLite SELECT query to execute (read-only)."),
    }),
  }
);

```

## 5. `createAgent` 사용하기

`createAgent`를 사용하여 최소한의 코드로 [ReAct agent](https://arxiv.org/pdf/2210.03629)를 구축하세요. agent는 요청을 해석하고 SQL 명령을 생성합니다. tool은 명령의 안전성을 확인한 다음 명령을 실행하려고 시도합니다. 명령에 오류가 있으면 오류 메시지가 모델로 반환됩니다. 그러면 모델은 원래 요청과 새 오류 메시지를 검토하고 새 명령을 생성할 수 있습니다. 이는 LLM이 명령을 성공적으로 생성하거나 종료 횟수에 도달할 때까지 계속될 수 있습니다. 이 경우 오류 메시지와 같은 피드백을 모델에 제공하는 패턴은 매우 강력합니다.

동작을 사용자 정의하기 위해 설명적인 system prompt로 agent를 초기화하세요:

```typescript
import { SystemMessage } from "langchain";

const getSystemPrompt = async () => new SystemMessage(`You are a careful SQLite analyst.

Authoritative schema (do not invent columns/tables):
${await getSchema()}

Rules:
- Think step-by-step.
- When you need data, call the tool \`execute_sql\` with ONE SELECT query.
- Read-only only; no INSERT/UPDATE/DELETE/ALTER/DROP/CREATE/REPLACE/TRUNCATE.
- Limit to 5 rows unless user explicitly asks otherwise.
- If the tool returns 'Error:', revise the SQL and try again.
- Limit the number of attempts to 5.
- If you are not successful after 5 attempts, return a note to the user.
- Prefer explicit column lists; avoid SELECT *.
`);
```

이제 모델, tool 및 prompt로 agent를 생성하세요:

```typescript
import { createAgent } from "langchain";

const agent = createAgent({
  model: "openai:gpt-5",
  tools: [executeSql],
  systemPrompt: getSystemPrompt,
});

```

## 6. Agent 실행하기

샘플 쿼리에서 agent를 실행하고 동작을 관찰하세요:

```typescript
const question = "Which genre, on average, has the longest tracks?";
const stream = await agent.stream(
  { messages: [{ role: "user", content: question }] },
  { streamMode: "values" }
);
for await (const step of stream) {
  const message = step.messages.at(-1);
  console.log(`${message.role}: ${JSON.stringify(message.content, null, 2)}`);
}
```

```
human: Which genre, on average, has the longest tracks?
ai:
tool: [{"Genre":"Sci Fi & Fantasy","AvgMilliseconds":2911783.0384615385}]
ai: Sci Fi & Fantasy — average track length ≈ 48.5 minutes (about 2,911,783 ms).
```

agent는 쿼리를 올바르게 작성하고, 쿼리를 확인하고, 실행하여 최종 응답을 알렸습니다.

<Note>
    수행된 단계, 호출된 tool, LLM이 본 prompt 등을 포함하여 위 실행의 모든 측면을 [LangSmith trace](https://smith.langchain.com/public/653d218b-af67-4854-95ca-6abecb9b2520/r)에서 검사할 수 있습니다.
</Note>

#### (선택 사항) Studio 사용하기

[Studio](/langsmith/studio)는 "클라이언트 측" 루프와 메모리를 제공하므로 이를 채팅 인터페이스로 실행하고 데이터베이스를 쿼리할 수 있습니다. "데이터베이스의 스키마를 알려주세요" 또는 "상위 5명의 고객에 대한 송장을 보여주세요"와 같은 질문을 할 수 있습니다. 생성된 SQL 명령과 결과 출력을 볼 수 있습니다. 시작하는 방법에 대한 세부 정보는 아래에 있습니다.
<Accordion title="Studio에서 agent 실행하기">

이전에 언급한 패키지 외에도 다음이 필요합니다:

```shell
npm i -g langgraph-cli@latest
```

실행할 디렉토리에 다음 내용이 포함된 `langgraph.json` 파일이 필요합니다:

```json
{
  "dependencies": ["."],
  "graphs": {
      "agent": "./sqlAgent.ts:agent",
      "graph": "./sqlAgentLanggraph.ts:graph"
  },
  "env": ".env"
}
```

```typescript
import fs from "node:fs/promises";
import path from "node:path";
import { SqlDatabase } from "@langchain/classic/sql_db";
import { DataSource } from "typeorm";
import { SystemMessage, createAgent, tool } from "langchain"
import * as z from "zod";

const url = "https://storage.googleapis.com/benchmarks-artifacts/chinook/Chinook.db";
const localPath = path.resolve("Chinook.db");

async function resolveDbPath() {
  if (await fs.exists(localPath)) {
    return localPath;
  }
  const resp = await fetch(url);
  if (!resp.ok) throw new Error(`Failed to download DB. Status code: ${resp.status}`);
  const buf = Buffer.from(await resp.arrayBuffer());
  await fs.writeFile(localPath, buf);
  return localPath;
}

let db: SqlDatabase | undefined;
async function getDb() {
  if (!db) {
    const dbPath = await resolveDbPath();
    const datasource = new DataSource({ type: "sqlite", database: dbPath });
    db = await SqlDatabase.fromDataSourceParams({ appDataSource: datasource });
  }
  return db;
}

async function getSchema() {
  const db = await getDb();
  return await db.getTableInfo();
}

const DENY_RE = /\b(INSERT|UPDATE|DELETE|ALTER|DROP|CREATE|REPLACE|TRUNCATE)\b/i;
const HAS_LIMIT_TAIL_RE = /\blimit\b\s+\d+(\s*,\s*\d+)?\s*;?\s*$/i;

function sanitizeSqlQuery(q) {
  let query = String(q ?? "").trim();

  // block multiple statements (allow one optional trailing ;)
  const semis = [...query].filter((c) => c === ";").length;
  if (semis > 1 || (query.endsWith(";") && query.slice(0, -1).includes(";"))) {
    throw new Error("multiple statements are not allowed.")
  }
  query = query.replace(/;+\s*$/g, "").trim();

  // read-only gate
  if (!query.toLowerCase().startsWith("select")) {
    throw new Error("Only SELECT statements are allowed")
  }
  if (DENY_RE.test(query)) {
    throw new Error("DML/DDL detected. Only read-only queries are permitted.")
  }

  // append LIMIT only if not already present
  if (!HAS_LIMIT_TAIL_RE.test(query)) {
    query += " LIMIT 5";
  }
  return query;
}

const executeSql = tool(
  async ({ query }) => {
    const q = sanitizeSqlQuery(query);
    try {
      const result = await db.run(q);
      return typeof result === "string" ? result : JSON.stringify(result, null, 2);
    } catch (e) {
      throw new Error(e?.message ?? String(e))
    }
  },
  {
    name: "execute_sql",
    description: "Execute a READ-ONLY SQLite SELECT query and return results.",
    schema: z.object({
      query: z.string().describe("SQLite SELECT query to execute (read-only)."),
    }),
  }
);

const getSystemPrompt = async () => new SystemMessage(`You are a careful SQLite analyst.

Authoritative schema (do not invent columns/tables):
${await getSchema()}

Rules:
- Think step-by-step.
- When you need data, call the tool \`execute_sql\` with ONE SELECT query.
- Read-only only; no INSERT/UPDATE/DELETE/ALTER/DROP/CREATE/REPLACE/TRUNCATE.
- Limit to 5 rows unless user explicitly asks otherwise.
- If the tool returns 'Error:', revise the SQL and try again.
- Limit the number of attempts to 5.
- If you are not successful after 5 attempts, return a note to the user.
- Prefer explicit column lists; avoid SELECT *.
`);

export const agent = createAgent({
  model: "openai:gpt-5",
  tools: [executeSql],
  systemPrompt: getSystemPrompt,
});
```
</Accordion>


## Next steps

더 깊은 사용자 정의를 위해 LangGraph primitive를 사용하여 SQL agent를 직접 구현하는 [이 튜토리얼](/oss/javascript/langgraph/sql-agent)을 확인하세요.

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/langchain/sql-agent.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for    real-time answers.
</Tip>
