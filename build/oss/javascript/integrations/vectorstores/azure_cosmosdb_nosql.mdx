---
title: Azure Cosmos DB for NoSQL
---

> [Azure Cosmos DB for NoSQL](https://learn.microsoft.com/azure/cosmos-db/nosql/)은 유연한 스키마로 항목을 쿼리할 수 있는 지원과 JSON에 대한 네이티브 지원을 제공합니다. 이제 벡터 인덱싱 및 검색 기능을 제공합니다. 이 기능은 고차원 벡터를 처리하도록 설계되어 모든 규모에서 효율적이고 정확한 벡터 검색을 가능하게 합니다. 이제 데이터와 함께 문서에 벡터를 직접 저장할 수 있습니다. 데이터베이스의 각 문서는 기존의 스키마 없는 데이터뿐만 아니라 문서의 다른 속성으로 고차원 벡터도 포함할 수 있습니다.

[이 페이지](https://learn.microsoft.com/azure/cosmos-db/nosql/vector-search)에서 Azure Cosmos DB for NoSQL의 벡터 검색 기능을 활용하는 방법을 알아보세요. Azure 계정이 없다면 [무료 계정을 생성](https://azure.microsoft.com/free/)하여 시작할 수 있습니다.

## Setup

먼저 [`@langchain/azure-cosmosdb`](https://www.npmjs.com/package/@langchain/azure-cosmosdb) 패키지를 설치해야 합니다:

<Tip>
LangChain 패키지 설치에 대한 일반적인 지침은 [이 섹션](/oss/javascript/langchain/install)을 참조하세요.
</Tip>

```bash npm
npm install @langchain/azure-cosmosdb @langchain/core
```
또한 Azure Cosmos DB for NoSQL 인스턴스가 실행 중이어야 합니다. [이 가이드](https://learn.microsoft.com/azure/cosmos-db/nosql/quickstart-portal)를 따라 Azure Portal에서 무료 버전을 비용 없이 배포할 수 있습니다.

인스턴스가 실행되면 연결 문자열이 있는지 확인하세요. Azure Portal의 인스턴스 "Settings / Keys" 섹션에서 찾을 수 있습니다. 그런 다음 다음 환경 변수를 설정해야 합니다:

```bash .env example
# Use connection string to authenticate
AZURE_COSMOSDB_NOSQL_CONNECTION_STRING=

# Use managed identity to authenticate
AZURE_COSMOSDB_NOSQL_ENDPOINT=
```

### Azure Managed Identity 사용하기

Azure Managed Identity를 사용하는 경우 다음과 같이 자격 증명을 구성할 수 있습니다:

```typescript
import { AzureCosmosDBNoSQLVectorStore } from "@langchain/azure-cosmosdb";
import { OpenAIEmbeddings } from "@langchain/openai";

// Create Azure Cosmos DB vector store
const store = new AzureCosmosDBNoSQLVectorStore(new OpenAIEmbeddings(), {
  // Or use environment variable AZURE_COSMOSDB_NOSQL_ENDPOINT
  endpoint: "https://my-cosmosdb.documents.azure.com:443/",

  // Database and container must already exist
  databaseName: "my-database",
  containerName: "my-container",
});
```

<Info>
**Azure Managed Identity와 역할 기반 액세스 제어를 사용할 때는 데이터베이스와 컨테이너가 미리 생성되어 있어야 합니다. RBAC는 데이터베이스 및 컨테이너 생성 권한을 제공하지 않습니다. 권한 모델에 대한 자세한 내용은 [Azure Cosmos DB 문서](https://learn.microsoft.com/azure/cosmos-db/how-to-setup-rbac#permission-model)에서 확인할 수 있습니다.**


</Info>

### filter 사용 시 보안 고려사항

<Warning>
**사용자가 제공한 입력으로 filter를 사용하면 데이터가 제대로 정제되지 않을 경우 보안 위험이 될 수 있습니다. 잠재적인 보안 문제를 방지하려면 아래 권장 사항을 따르세요.**


</Warning>

원시 사용자 입력을 `WHERE ${userFilter}`와 같은 SQL 유사 절에 연결하도록 허용하면 SQL injection 공격의 심각한 위험이 발생하여 의도하지 않은 데이터가 노출되거나 시스템 무결성이 손상될 수 있습니다. 이를 완화하려면 항상 Azure Cosmos DB의 매개변수화된 쿼리 메커니즘을 사용하여 `@param` 플레이스홀더를 전달하여 쿼리 로직과 사용자 제공 입력을 명확하게 분리하세요.

다음은 안전하지 않은 코드의 예입니다:

```typescript
import { AzureCosmosDBNoSQLVectorStore } from "@langchain/azure-cosmosdb";

const store = new AzureCosmosDBNoSQLVectorStore(embeddings, {});

// Unsafe: user-controlled input injected into the query
const userId = req.query.userId; // e.g. "123' OR 1=1"
const unsafeQuerySpec = {
  query: `SELECT * FROM c WHERE c.metadata.userId = '${userId}'`,
};

await store.delete({ filter: unsafeQuerySpec });
```
공격자가 `123 OR 1=1`을 제공하면 쿼리는 `SELECT * FROM c WHERE c.metadata.userId = '123' OR 1=1`이 되어 조건이 항상 참이 되도록 강제하여 의도한 filter를 우회하고 모든 문서를 삭제하게 됩니다.

이러한 injection 위험을 방지하려면 아래와 같이 `@userId`와 같은 플레이스홀더를 정의하고 Cosmos DB가 사용자 입력을 매개변수로 별도로 바인딩하여 실행 가능한 쿼리 로직이 아닌 데이터로만 엄격하게 처리되도록 해야 합니다.

```typescript
import { SqlQuerySpec } from "@azure/cosmos";

const safeQuerySpec: SqlQuerySpec = {
  query: "SELECT * FROM c WHERE c.metadata.userId = @userId",
  parameters: [{ name: "@userId", value: userId }],
};

await store.delete({ filter: safeQuerySpec });
```

이제 공격자가 `123 OR 1=1`을 입력하면 입력은 쿼리 구조의 일부가 아닌 일치시킬 리터럴 문자열 값으로 처리됩니다.

더 많은 사용 예제와 모범 사례는 [Azure Cosmos DB for NoSQL의 매개변수화된 쿼리](https://learn.microsoft.com/azure/cosmos-db/nosql/query/parameterized-queries)에 대한 공식 문서를 참조하세요.

## 사용 예제

다음은 Azure Cosmos DB for NoSQL에서 파일의 문서를 인덱싱하고, 벡터 검색 쿼리를 실행하고, 마지막으로 chain을 사용하여 검색된 문서를 기반으로 자연어로 질문에 답하는 예제입니다.

```typescript
import { AzureCosmosDBNoSQLVectorStore } from "@langchain/azure-cosmosdb";
import { ChatPromptTemplate } from "@langchain/core/prompts";
import { ChatOpenAI, OpenAIEmbeddings } from "@langchain/openai";
import { createStuffDocumentsChain } from "@langchain/classic/chains/combine_documents";
import { createRetrievalChain } from "@langchain/classic/chains/retrieval";
import { TextLoader } from "@langchain/classic/document_loaders/fs/text";
import { RecursiveCharacterTextSplitter } from "@langchain/textsplitters";

// Load documents from file
const loader = new TextLoader("./state_of_the_union.txt");
const rawDocuments = await loader.load();
const splitter = new RecursiveCharacterTextSplitter({
  chunkSize: 1000,
  chunkOverlap: 0,
});
const documents = await splitter.splitDocuments(rawDocuments);

// Create Azure Cosmos DB vector store
const store = await AzureCosmosDBNoSQLVectorStore.fromDocuments(
  documents,
  new OpenAIEmbeddings(),
  {
    databaseName: "langchain",
    containerName: "documents",
  }
);

// Performs a similarity search
const resultDocuments = await store.similaritySearch(
  "What did the president say about Ketanji Brown Jackson?"
);

console.log("Similarity search results:");
console.log(resultDocuments[0].pageContent);
/*
  Tonight. I call on the Senate to: Pass the Freedom to Vote Act. Pass the John Lewis Voting Rights Act. And while you’re at it, pass the Disclose Act so Americans can know who is funding our elections.

  Tonight, I’d like to honor someone who has dedicated his life to serve this country: Justice Stephen Breyer—an Army veteran, Constitutional scholar, and retiring Justice of the United States Supreme Court. Justice Breyer, thank you for your service.

  One of the most serious constitutional responsibilities a President has is nominating someone to serve on the United States Supreme Court.

  And I did that 4 days ago, when I nominated Circuit Court of Appeals Judge Ketanji Brown Jackson. One of our nation’s top legal minds, who will continue Justice Breyer’s legacy of excellence.
*/

// Use the store as part of a chain
const model = new ChatOpenAI({ model: "gpt-3.5-turbo-1106" });
const questionAnsweringPrompt = ChatPromptTemplate.fromMessages([
  [
    "system",
    "Answer the user's questions based on the below context:\n\n{context}",
  ],
  ["human", "{input}"],
]);

const combineDocsChain = await createStuffDocumentsChain({
  llm: model,
  prompt: questionAnsweringPrompt,
});

const chain = await createRetrievalChain({
  retriever: store.asRetriever(),
  combineDocsChain,
});

const res = await chain.invoke({
  input: "What is the president's top priority regarding prices?",
});

console.log("Chain response:");
console.log(res.answer);
/*
  The president's top priority is getting prices under control.
*/

// Clean up
await store.delete();
```

## Related

- Vector store [개념 가이드](/oss/javascript/integrations/vectorstores)
- Vector store [사용 방법 가이드](/oss/javascript/integrations/vectorstores)

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/javascript/integrations/vectorstores/azure_cosmosdb_nosql.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for    real-time answers.
</Tip>
