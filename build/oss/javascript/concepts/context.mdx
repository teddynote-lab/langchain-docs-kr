---
title: Context 개요
sidebarTitle: Context
---

**Context engineering**은 AI 애플리케이션이 작업을 수행할 수 있도록 올바른 정보와 도구를 적절한 형식으로 제공하는 동적 시스템을 구축하는 실천 방법입니다. Context는 두 가지 주요 차원으로 특징지을 수 있습니다:

1. **가변성**에 따라:
  * **Static context**: 실행 중에 변경되지 않는 불변 데이터 (예: 사용자 메타데이터, 데이터베이스 연결, 도구)
  * **Dynamic context**: 애플리케이션이 실행되면서 진화하는 가변 데이터 (예: 대화 기록, 중간 결과, 도구 호출 관찰)
2. **수명**에 따라:
  * **Runtime context**: 단일 실행 또는 호출에 범위가 지정된 데이터
  * **Cross-conversation context**: 여러 대화 또는 세션에 걸쳐 지속되는 데이터

<Tip>
    Runtime context는 로컬 context를 의미합니다: 코드가 실행되는 데 필요한 데이터와 종속성입니다. 다음을 의미하지 **않습니다**:

    * LLM context: LLM의 prompt에 전달되는 데이터
    * "context window": LLM에 전달할 수 있는 최대 토큰 수

    Runtime context는 LLM context를 최적화하는 데 사용할 수 있습니다. 예를 들어, runtime context의 사용자 메타데이터를 사용하여 사용자 기본 설정을 가져와 context window에 제공할 수 있습니다.
</Tip>

LangGraph는 가변성과 수명 차원을 결합한 세 가지 context 관리 방법을 제공합니다:



| Context 유형                                                                                | 설명                                   | 가변성 | 수명           |
| ------------------------------------------------------------------------------------------- | --------------------------------------------- | ---------- | ------------------ |
| [**Config**](#config-static-context)                                                        | 실행 시작 시 전달되는 데이터             | Static     | Single run         |
| [**Dynamic runtime context (state)**](#dynamic-runtime-context-state)                       | 단일 실행 중에 진화하는 가변 데이터 | Dynamic    | Single run         |
| [**Dynamic cross-conversation context (store)**](#dynamic-cross-conversation-context-store) | 대화 간에 공유되는 영구 데이터   | Dynamic    | Cross-conversation |

<a id="static-context"></a>
## Config

Config는 사용자 메타데이터나 API 키와 같은 불변 데이터를 위한 것입니다. 실행 중에 변경되지 않는 값이 있을 때 사용하세요.

이 목적을 위해 예약된 **"configurable"**이라는 키를 사용하여 구성을 지정합니다.

```typescript
await graph.invoke(
  { messages: [{ role: "user", content: "hi!" }] },
  { configurable: { user_id: "user_123" } } // [!code highlight]
);
```


<a id="state"></a>
## Dynamic runtime context

**Dynamic runtime context**는 단일 실행 중에 진화할 수 있는 가변 데이터를 나타내며 LangGraph state 객체를 통해 관리됩니다. 여기에는 대화 기록, 중간 결과, 도구 또는 LLM 출력에서 파생된 값이 포함됩니다. LangGraph에서 state 객체는 실행 중 [단기 메모리](/oss/javascript/concepts/memory) 역할을 합니다.

<Tabs>
    <Tab title="In an agent">
    예제는 state를 agent **prompt**에 통합하는 방법을 보여줍니다.

    State는 agent의 **tools**에서도 접근할 수 있으며, 필요에 따라 state를 읽거나 업데이트할 수 있습니다. 자세한 내용은 [tool calling guide](/oss/javascript/langchain/tools#short-term-memory)를 참조하세요.



    ```typescript
    import { createAgent, createMiddleware } from "langchain";
    import type { AgentState } from "langchain";
    import * as z from "zod";

    const CustomState = z.object({ // [!code highlight]
      userName: z.string(),
    });

    const personalizedPrompt = createMiddleware({ // [!code highlight]
      name: "PersonalizedPrompt",
      stateSchema: CustomState,
      wrapModelCall: (request, handler) => {
        const userName = request.state.userName || "User";
        const systemPrompt = `You are a helpful assistant. User's name is ${userName}`;
        return handler({ ...request, systemPrompt });
      },
    });

    const agent = createAgent({  // [!code highlight]
      model: "anthropic:claude-sonnet-4-5",
      tools: [/* your tools here */],
      middleware: [personalizedPrompt] as const, // [!code highlight]
    });

    await agent.invoke({
      messages: [{ role: "user", content: "hi!" }],
      userName: "John Smith",
    });
    ```

    </Tab>
    <Tab title="In a workflow">


    ```typescript
    import type { BaseMessage } from "@langchain/core/messages";
    import { StateGraph, MessagesZodMeta, START } from "@langchain/langgraph";
    import { registry } from "@langchain/langgraph/zod";
    import * as z from "zod";

    const CustomState = z.object({  // [!code highlight]
      messages: z
        .array(z.custom<BaseMessage>())
        .register(registry, MessagesZodMeta),
      extraField: z.number(),
    });

    const builder = new StateGraph(CustomState)
      .addNode("node", async (state) => {  // [!code highlight]
        const messages = state.messages;
        // ...
        return {  // [!code highlight]
          extraField: state.extraField + 1,
        };
      })
      .addEdge(START, "node");

    const graph = builder.compile();
    ```

    </Tab>
</Tabs>

<Tip>
    **메모리 활성화하기**
    메모리를 활성화하는 방법에 대한 자세한 내용은 [memory guide](/oss/javascript/langgraph/add-memory)를 참조하세요. 이는 여러 호출에 걸쳐 agent의 state를 유지할 수 있는 강력한 기능입니다. 그렇지 않으면 state는 단일 실행에만 범위가 지정됩니다.
</Tip>

<a id="store"></a>

## Dynamic cross-conversation context

**Dynamic cross-conversation context**는 여러 대화 또는 세션에 걸쳐 지속되는 영구적이고 가변적인 데이터를 나타내며 LangGraph store를 통해 관리됩니다. 여기에는 사용자 프로필, 기본 설정, 과거 상호작용이 포함됩니다. LangGraph store는 여러 실행에 걸친 [장기 메모리](/oss/javascript/concepts/memory#long-term-memory) 역할을 합니다. 이는 영구적인 사실(예: 사용자 프로필, 기본 설정, 이전 상호작용)을 읽거나 업데이트하는 데 사용할 수 있습니다.

## 참고 자료

- [Memory 개념 개요](/oss/javascript/concepts/memory)
- [LangChain의 단기 메모리](/oss/javascript/langchain/short-term-memory)
- [LangChain의 장기 메모리](/oss/javascript/langchain/long-term-memory)
- [LangGraph의 메모리](/oss/javascript/langgraph/add-memory)

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/concepts/context.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for    real-time answers.
</Tip>
