---
title: Graph API 사용하기
sidebarTitle: Graph API 사용하기
---



import ChatModelTabs from '/snippets/chat-model-tabs.mdx';

이 가이드는 LangGraph의 Graph API 기본 사항을 설명합니다. [state](#define-and-update-state)와 [시퀀스](#create-a-sequence-of-steps), [분기](#create-branches), [루프](#create-and-control-loops)와 같은 일반적인 그래프 구조를 구성하는 방법을 안내합니다. 또한 map-reduce 워크플로우를 위한 [Send API](#map-reduce-and-the-send-api)와 노드 간 "홉"과 상태 업데이트를 결합하는 [Command API](#combine-control-flow-and-state-updates-with-command)를 포함한 LangGraph의 제어 기능도 다룹니다.

## Setup



`langgraph` 설치:

```bash
npm install @langchain/langgraph
```


<Tip>
**더 나은 디버깅을 위해 LangSmith 설정하기**
[LangSmith](https://smith.langchain.com)에 가입하여 LangGraph 프로젝트의 문제를 빠르게 발견하고 성능을 개선하세요. LangSmith를 사용하면 trace 데이터를 활용하여 LangGraph로 구축된 LLM 앱을 디버그, 테스트 및 모니터링할 수 있습니다 — 시작하는 방법에 대한 자세한 내용은 [문서](https://docs.smith.langchain.com)를 참조하세요.
</Tip>

## Define and update state

여기서는 LangGraph에서 [state](/oss/javascript/langgraph/graph-api#state)를 정의하고 업데이트하는 방법을 보여줍니다. 다음을 시연합니다:

1. state를 사용하여 그래프의 [schema](/oss/javascript/langgraph/graph-api#schema)를 정의하는 방법
2. [reducers](/oss/javascript/langgraph/graph-api#reducers)를 사용하여 상태 업데이트 처리 방식을 제어하는 방법

### Define state



LangGraph의 [State](/oss/javascript/langgraph/graph-api#state)는 Zod 스키마를 사용하여 정의할 수 있습니다. 아래에서는 Zod를 사용합니다. 대체 접근 방식 사용에 대한 자세한 내용은 [이 섹션](#alternative-state-definitions)을 참조하세요.


기본적으로 그래프는 동일한 입력 및 출력 스키마를 가지며, state가 해당 스키마를 결정합니다. 별도의 입력 및 출력 스키마를 정의하는 방법은 [이 섹션](#define-input-and-output-schemas)을 참조하세요.

[messages](/oss/javascript/langgraph/graph-api#messagesstate)를 사용하는 간단한 예제를 살펴보겠습니다. 이는 많은 LLM 애플리케이션에 대한 다재다능한 state 형식을 나타냅니다. 자세한 내용은 [개념 페이지](/oss/javascript/langgraph/graph-api#working-with-messages-in-graph-state)를 참조하세요.



```typescript
import { BaseMessage } from "@langchain/core/messages";
import { MessagesZodMeta } from "@langchain/langgraph";
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";

const State = z.object({
  messages: z.array(z.custom<BaseMessage>()).register(registry, MessagesZodMeta),
  extraField: z.number(),
});
```

이 state는 [message](https://js.langchain.com/docs/concepts/messages/) 객체 목록과 추가 정수 필드를 추적합니다.


### Update state



단일 노드가 있는 예제 그래프를 만들어 보겠습니다. [node](/oss/javascript/langgraph/graph-api#nodes)는 그래프의 state를 읽고 업데이트하는 TypeScript 함수입니다. 이 함수의 첫 번째 인수는 항상 state입니다:

```typescript
import { AIMessage } from "@langchain/core/messages";

const node = (state: z.infer<typeof State>) => {
  const messages = state.messages;
  const newMessage = new AIMessage("Hello!");
  return { messages: messages.concat([newMessage]), extraField: 10 };
};
```

이 노드는 단순히 메시지 목록에 메시지를 추가하고 추가 필드를 채웁니다.


<Warning>
노드는 state를 변경하는 대신 state에 대한 업데이트를 직접 반환해야 합니다.
</Warning>



다음으로 이 노드를 포함하는 간단한 그래프를 정의해 보겠습니다. [`StateGraph`](/oss/javascript/langgraph/graph-api#stategraph)를 사용하여 이 state에서 작동하는 그래프를 정의합니다. 그런 다음 [`addNode`](/oss/javascript/langgraph/graph-api#nodes)를 사용하여 그래프를 채웁니다.

```typescript
import { StateGraph } from "@langchain/langgraph";

const graph = new StateGraph(State)
  .addNode("node", node)
  .addEdge("__start__", "node")
  .compile();
```


LangGraph는 그래프를 시각화하기 위한 내장 유틸리티를 제공합니다. 그래프를 검사해 보겠습니다. 시각화에 대한 자세한 내용은 [이 섹션](#visualize-your-graph)을 참조하세요.



```typescript
import * as fs from "node:fs/promises";

const drawableGraph = await graph.getGraphAsync();
const image = await drawableGraph.drawMermaidPng();
const imageBuffer = new Uint8Array(await image.arrayBuffer());

await fs.writeFile("graph.png", imageBuffer);
```


이 경우 그래프는 단일 노드만 실행합니다. 간단한 호출을 진행해 보겠습니다:



```typescript
import { HumanMessage } from "@langchain/core/messages";

const result = await graph.invoke({ messages: [new HumanMessage("Hi")], extraField: 0 });
console.log(result);
```

```
{ messages: [HumanMessage { content: 'Hi' }, AIMessage { content: 'Hello!' }], extraField: 10 }
```


다음 사항에 유의하세요:

* state의 단일 키를 업데이트하여 호출을 시작했습니다.
* 호출 결과에서 전체 state를 받습니다.



편의를 위해 로깅을 통해 [message 객체](https://js.langchain.com/docs/concepts/messages/)의 내용을 자주 검사합니다:

```typescript
for (const message of result.messages) {
  console.log(`${message.getType()}: ${message.content}`);
}
```

```
human: Hi
ai: Hello!
```


### Process state updates with reducers

state의 각 키는 자체적인 독립적인 [reducer](/oss/javascript/langgraph/graph-api#reducers) 함수를 가질 수 있으며, 이는 노드의 업데이트가 적용되는 방식을 제어합니다. reducer 함수가 명시적으로 지정되지 않으면 키에 대한 모든 업데이트가 이를 덮어쓴다고 가정합니다.



Zod state 스키마의 경우, 스키마 필드에서 특수 `.langgraph.reducer()` 메서드를 사용하여 reducer를 정의할 수 있습니다.

이전 예제에서 노드는 메시지를 추가하여 state의 `"messages"` 키를 업데이트했습니다. 아래에서는 이 키에 reducer를 추가하여 업데이트가 자동으로 추가되도록 합니다:

```typescript
import "@langchain/langgraph/zod";

const State = z.object({
  messages: z.array(z.custom<BaseMessage>()).langgraph.reducer((x, y) => x.concat(y)),  // [!code highlight]
  extraField: z.number(),
});
```

이제 노드를 단순화할 수 있습니다:

```typescript
const node = (state: z.infer<typeof State>) => {
  const newMessage = new AIMessage("Hello!");
  return { messages: [newMessage], extraField: 10 };  // [!code highlight]
};
```




```typescript
import { START } from "@langchain/langgraph";

const graph = new StateGraph(State)
  .addNode("node", node)
  .addEdge(START, "node")
  .compile();

const result = await graph.invoke({ messages: [new HumanMessage("Hi")] });

for (const message of result.messages) {
  console.log(`${message.getType()}: ${message.content}`);
}
```

```
human: Hi
ai: Hello!
```


#### MessagesState

실제로 메시지 목록을 업데이트할 때 추가 고려 사항이 있습니다:

* state의 기존 메시지를 업데이트하고 싶을 수 있습니다.
* [OpenAI 형식](https://python.langchain.com/docs/concepts/messages/#openai-format)과 같은 [메시지 형식](/oss/javascript/langgraph/graph-api#using-messages-in-your-graph)의 단축 표현을 허용하고 싶을 수 있습니다.



LangGraph는 이러한 고려 사항을 처리하는 내장 `MessagesZodMeta`를 포함합니다:

```typescript
import { MessagesZodMeta } from "@langchain/langgraph";
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";

const State = z.object({  // [!code highlight]
  messages: z
    .array(z.custom<BaseMessage>())
    .register(registry, MessagesZodMeta),
  extraField: z.number(),
});

const graph = new StateGraph(State)
  .addNode("node", (state) => {
    const newMessage = new AIMessage("Hello!");
    return { messages: [newMessage], extraField: 10 };
  })
  .addEdge(START, "node")
  .compile();
```

```typescript
const inputMessage = { role: "user", content: "Hi" };  // [!code highlight]

const result = await graph.invoke({ messages: [inputMessage] });

for (const message of result.messages) {
  console.log(`${message.getType()}: ${message.content}`);
}
```

```
human: Hi
ai: Hello!
```

이것은 [chat models](https://js.langchain.com/docs/concepts/chat_models/)를 포함하는 애플리케이션에 대한 다재다능한 state 표현입니다. LangGraph는 편의를 위해 이 사전 구축된 `MessagesZodMeta`를 포함하므로 다음과 같이 사용할 수 있습니다:

```typescript
import { MessagesZodMeta } from "@langchain/langgraph";
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";

const State = z.object({
  messages: z
    .array(z.custom<BaseMessage>())
    .register(registry, MessagesZodMeta),
  extraField: z.number(),
});
```


### Define input and output schemas

기본적으로 `StateGraph`는 단일 스키마로 작동하며 모든 노드는 해당 스키마를 사용하여 통신할 것으로 예상됩니다. 그러나 그래프에 대해 별도의 입력 및 출력 스키마를 정의하는 것도 가능합니다.

별도의 스키마가 지정되면 노드 간 통신에는 여전히 내부 스키마가 사용됩니다. 입력 스키마는 제공된 입력이 예상 구조와 일치하는지 확인하고, 출력 스키마는 정의된 출력 스키마에 따라 관련 정보만 반환하도록 내부 데이터를 필터링합니다.

아래에서는 별도의 입력 및 출력 스키마를 정의하는 방법을 살펴보겠습니다.



```typescript
import { StateGraph, START, END } from "@langchain/langgraph";
import * as z from "zod";

// Define the schema for the input
const InputState = z.object({
  question: z.string(),
});

// Define the schema for the output
const OutputState = z.object({
  answer: z.string(),
});

// Define the overall schema, combining both input and output
const OverallState = InputState.merge(OutputState);

// Build the graph with input and output schemas specified
const graph = new StateGraph({
  input: InputState,
  output: OutputState,
  state: OverallState,
})
  .addNode("answerNode", (state) => {
    // Example answer and an extra key
    return { answer: "bye", question: state.question };
  })
  .addEdge(START, "answerNode")
  .addEdge("answerNode", END)
  .compile();

// Invoke the graph with an input and print the result
console.log(await graph.invoke({ question: "hi" }));
```

```
{ answer: 'bye' }
```


invoke의 출력에는 출력 스키마만 포함됩니다.

### Pass private state between nodes

경우에 따라 노드가 중간 로직에 중요하지만 그래프의 주요 스키마의 일부일 필요가 없는 정보를 교환하기를 원할 수 있습니다. 이 비공개 데이터는 그래프의 전체 입력/출력과 관련이 없으며 특정 노드 간에만 공유되어야 합니다.

아래에서는 세 개의 노드(node_1, node_2 및 node_3)로 구성된 예제 순차 그래프를 만들 것입니다. 여기서 비공개 데이터는 처음 두 단계(node_1 및 node_2) 간에 전달되고, 세 번째 단계(node_3)는 공개 전체 state에만 액세스할 수 있습니다.



```typescript
import { StateGraph, START, END } from "@langchain/langgraph";
import * as z from "zod";

// The overall state of the graph (this is the public state shared across nodes)
const OverallState = z.object({
  a: z.string(),
});

// Output from node1 contains private data that is not part of the overall state
const Node1Output = z.object({
  privateData: z.string(),
});

// The private data is only shared between node1 and node2
const node1 = (state: z.infer<typeof OverallState>): z.infer<typeof Node1Output> => {
  const output = { privateData: "set by node1" };
  console.log(`Entered node 'node1':\n\tInput: ${JSON.stringify(state)}.\n\tReturned: ${JSON.stringify(output)}`);
  return output;
};

// Node 2 input only requests the private data available after node1
const Node2Input = z.object({
  privateData: z.string(),
});

const node2 = (state: z.infer<typeof Node2Input>): z.infer<typeof OverallState> => {
  const output = { a: "set by node2" };
  console.log(`Entered node 'node2':\n\tInput: ${JSON.stringify(state)}.\n\tReturned: ${JSON.stringify(output)}`);
  return output;
};

// Node 3 only has access to the overall state (no access to private data from node1)
const node3 = (state: z.infer<typeof OverallState>): z.infer<typeof OverallState> => {
  const output = { a: "set by node3" };
  console.log(`Entered node 'node3':\n\tInput: ${JSON.stringify(state)}.\n\tReturned: ${JSON.stringify(output)}`);
  return output;
};

// Connect nodes in a sequence
// node2 accepts private data from node1, whereas
// node3 does not see the private data.
const graph = new StateGraph({
  state: OverallState,
  nodes: {
    node1: { action: node1, output: Node1Output },
    node2: { action: node2, input: Node2Input },
    node3: { action: node3 },
  }
})
  .addEdge(START, "node1")
  .addEdge("node1", "node2")
  .addEdge("node2", "node3")
  .addEdge("node3", END)
  .compile();

// Invoke the graph with the initial state
const response = await graph.invoke({ a: "set at start" });

console.log(`\nOutput of graph invocation: ${JSON.stringify(response)}`);
```

```
Entered node 'node1':
    ut: {"a":"set at start"}.
    urned: {"privateData":"set by node1"}
Entered node 'node2':
    ut: {"privateData":"set by node1"}.
    urned: {"a":"set by node2"}
Entered node 'node3':
    ut: {"a":"set by node2"}.
    urned: {"a":"set by node3"}

Output of graph invocation: {"a":"set by node3"}
```




### Alternative state definitions

Zod 스키마가 권장되는 접근 방식이지만, LangGraph는 state 스키마를 정의하는 다른 방법도 지원합니다:

```typescript
import { BaseMessage } from "@langchain/core/messages";
import { StateGraph } from "@langchain/langgraph";

interface WorkflowChannelsState {
  messages: BaseMessage[];
  question: string;
  answer: string;
}

const workflowWithChannels = new StateGraph<WorkflowChannelsState>({
  channels: {
    messages: {
      reducer: (currentState, updateValue) => currentState.concat(updateValue),
      default: () => [],
    },
    question: null,
    answer: null,
  },
});
```


## Add runtime configuration

때로는 그래프를 호출할 때 구성할 수 있기를 원할 수 있습니다. 예를 들어, 런타임에 사용할 LLM 또는 시스템 프롬프트를 지정하고 싶을 수 있지만 _이러한 매개변수로 그래프 state를 오염시키지 않고_ 말입니다.

런타임 구성을 추가하려면:

1. 구성에 대한 스키마 지정
2. 노드 또는 조건부 엣지의 함수 시그니처에 구성 추가
3. 그래프에 구성 전달

간단한 예제는 아래를 참조하세요:



```typescript
import { StateGraph, END, START } from "@langchain/langgraph";
import * as z from "zod";

// 1. Specify config schema
const ContextSchema = z.object({
  myRuntimeValue: z.string(),
});

// 2. Define a graph that accesses the config in a node
const StateSchema = z.object({
  myStateValue: z.number(),
});

const graph = new StateGraph(StateSchema, ContextSchema)
  .addNode("node", (state, runtime) => {
    if (runtime?.context?.myRuntimeValue === "a") {  // [!code highlight]
      return { myStateValue: 1 };
    } else if (runtime?.context?.myRuntimeValue === "b") {  // [!code highlight]
      return { myStateValue: 2 };
    } else {
      throw new Error("Unknown values.");
    }
  })
  .addEdge(START, "node")
  .addEdge("node", END)
  .compile();

// 3. Pass in configuration at runtime:
console.log(await graph.invoke({}, { context: { myRuntimeValue: "a" } }));  // [!code highlight]
console.log(await graph.invoke({}, { context: { myRuntimeValue: "b" } }));  // [!code highlight]
```

```
{ myStateValue: 1 }
{ myStateValue: 2 }
```


<Accordion title="확장 예제: 런타임에 LLM 지정">


  아래에서는 런타임에 사용할 LLM을 구성하는 실용적인 예제를 보여줍니다. OpenAI와 Anthropic 모델을 모두 사용할 것입니다.

  ```typescript
  import { ChatOpenAI } from "@langchain/openai";
  import { ChatAnthropic } from "@langchain/anthropic";
  import { BaseMessage } from "@langchain/core/messages";
  import { MessagesZodMeta, StateGraph, START, END } from "@langchain/langgraph";
  import { registry } from "@langchain/langgraph/zod";
  import { RunnableConfig } from "@langchain/core/runnables";
  import * as z from "zod";

  const ConfigSchema = z.object({
    modelProvider: z.string().default("anthropic"),
  });

  const MessagesZodState = z.object({
    messages: z
      .array(z.custom<BaseMessage>())
      .register(registry, MessagesZodMeta),
  });

  const MODELS = {
    anthropic: new ChatAnthropic({ model: "claude-3-5-haiku-latest" }),
    openai: new ChatOpenAI({ model: "gpt-4o-mini" }),
  };

  const graph = new StateGraph(MessagesZodState, ConfigSchema)
    .addNode("model", async (state, config) => {
      const modelProvider = config?.configurable?.modelProvider || "anthropic";
      const model = MODELS[modelProvider as keyof typeof MODELS];
      const response = await model.invoke(state.messages);
      return { messages: [response] };
    })
    .addEdge(START, "model")
    .addEdge("model", END)
    .compile();

  // Usage
  const inputMessage = { role: "user", content: "hi" };
  // With no configuration, uses default (Anthropic)
  const response1 = await graph.invoke({ messages: [inputMessage] });
  // Or, can set OpenAI
  const response2 = await graph.invoke(
    { messages: [inputMessage] },
    { configurable: { modelProvider: "openai" } },
  );

  console.log(response1.messages.at(-1)?.response_metadata?.model);
  console.log(response2.messages.at(-1)?.response_metadata?.model);
  ```

  ```
  claude-3-5-haiku-20241022
  gpt-4o-mini-2024-07-18
  ```

</Accordion>

<Accordion title="확장 예제: 런타임에 모델 및 시스템 메시지 지정">


  아래에서는 런타임에 사용할 LLM과 시스템 메시지라는 두 가지 매개변수를 구성하는 실용적인 예제를 보여줍니다.

  ```typescript
  import { ChatOpenAI } from "@langchain/openai";
  import { ChatAnthropic } from "@langchain/anthropic";
  import { SystemMessage, BaseMessage } from "@langchain/core/messages";
  import { MessagesZodMeta, StateGraph, START, END } from "@langchain/langgraph";
  import { registry } from "@langchain/langgraph/zod";
  import * as z from "zod";

  const ConfigSchema = z.object({
    modelProvider: z.string().default("anthropic"),
    systemMessage: z.string().optional(),
  });

  const MessagesZodState = z.object({
    messages: z
      .array(z.custom<BaseMessage>())
      .register(registry, MessagesZodMeta),
  });

  const MODELS = {
    anthropic: new ChatAnthropic({ model: "claude-3-5-haiku-latest" }),
    openai: new ChatOpenAI({ model: "gpt-4o-mini" }),
  };

  const graph = new StateGraph(MessagesZodState, ConfigSchema)
    .addNode("model", async (state, config) => {
      const modelProvider = config?.configurable?.modelProvider || "anthropic";
      const systemMessage = config?.configurable?.systemMessage;

      const model = MODELS[modelProvider as keyof typeof MODELS];
      let messages = state.messages;

      if (systemMessage) {
        messages = [new SystemMessage(systemMessage), ...messages];
      }

      const response = await model.invoke(messages);
      return { messages: [response] };
    })
    .addEdge(START, "model")
    .addEdge("model", END)
    .compile();

  // Usage
  const inputMessage = { role: "user", content: "hi" };
  const response = await graph.invoke(
    { messages: [inputMessage] },
    {
      configurable: {
        modelProvider: "openai",
        systemMessage: "Respond in Italian."
      }
    }
  );

  for (const message of response.messages) {
    console.log(`${message.getType()}: ${message.content}`);
  }
  ```

  ```
  human: hi
  ai: Ciao! Come posso aiutarti oggi?
  ```

</Accordion>

## Add retry policies

노드에 사용자 정의 재시도 정책을 적용하고 싶은 많은 사용 사례가 있습니다. 예를 들어 API를 호출하거나, 데이터베이스를 쿼리하거나, LLM을 호출하는 경우 등입니다. LangGraph를 사용하면 노드에 재시도 정책을 추가할 수 있습니다.



재시도 정책을 구성하려면 [addNode](https://reference.langchain.com/javascript/classes/_langchain_langgraph.index.Graph.html#addnode)에 `retryPolicy` 매개변수를 전달합니다. `retryPolicy` 매개변수는 `RetryPolicy` 객체를 받습니다. 아래에서는 기본 매개변수로 `RetryPolicy` 객체를 인스턴스화하고 노드와 연결합니다:

```typescript
import { RetryPolicy } from "@langchain/langgraph";

const graph = new StateGraph(State)
  .addNode("nodeName", nodeFunction, { retryPolicy: {} })
  .compile();
```

기본적으로 재시도 정책은 다음을 제외한 모든 예외에서 재시도합니다:

* `TypeError`
* `SyntaxError`
* `ReferenceError`


<Accordion title="확장 예제: 재시도 정책 사용자 정의">


  SQL 데이터베이스에서 읽는 예제를 고려해 보겠습니다. 아래에서는 노드에 두 가지 다른 재시도 정책을 전달합니다:

  ```typescript
  import Database from "better-sqlite3";
  import { ChatAnthropic } from "@langchain/anthropic";
  import { StateGraph, START, END, MessagesZodMeta } from "@langchain/langgraph";
  import { registry } from "@langchain/langgraph/zod";
  import { AIMessage, BaseMessage } from "@langchain/core/messages";
  import * as z from "zod";

  const MessagesZodState = z.object({
    messages: z
      .array(z.custom<BaseMessage>())
      .register(registry, MessagesZodMeta),
  });

  // Create an in-memory database
  const db: typeof Database.prototype = new Database(":memory:");

  const model = new ChatAnthropic({ model: "claude-3-5-sonnet-20240620" });

  const callModel = async (state: z.infer<typeof MessagesZodState>) => {
    const response = await model.invoke(state.messages);
    return { messages: [response] };
  };

  const queryDatabase = async (state: z.infer<typeof MessagesZodState>) => {
    const queryResult: string = JSON.stringify(
      db.prepare("SELECT * FROM Artist LIMIT 10;").all(),
    );

    return { messages: [new AIMessage({ content: "queryResult" })] };
  };

  const workflow = new StateGraph(MessagesZodState)
    // Define the two nodes we will cycle between
    .addNode("call_model", callModel, { retryPolicy: { maxAttempts: 5 } })
    .addNode("query_database", queryDatabase, {
      retryPolicy: {
        retryOn: (e: any): boolean => {
          if (e instanceof Database.SqliteError) {
            // Retry on "SQLITE_BUSY" error
            return e.code === "SQLITE_BUSY";
          }
          return false; // Don't retry on other errors
        },
      },
    })
    .addEdge(START, "call_model")
    .addEdge("call_model", "query_database")
    .addEdge("query_database", END);

  const graph = workflow.compile();
  ```

</Accordion>



## Create a sequence of steps

<Info>
**전제 조건**
이 가이드는 위의 [state](#define-and-update-state) 섹션에 대한 이해를 전제로 합니다.
</Info>

여기서는 간단한 단계 시퀀스를 구성하는 방법을 보여줍니다. 다음을 보여줍니다:

1. 순차 그래프를 구축하는 방법
2. 유사한 그래프를 구성하기 위한 내장 단축 표현



노드 시퀀스를 추가하려면 [graph](/oss/javascript/langgraph/graph-api#stategraph)의 `.addNode` 및 `.addEdge` 메서드를 사용합니다:

```typescript
import { START, StateGraph } from "@langchain/langgraph";

const builder = new StateGraph(State)
  .addNode("step1", step1)
  .addNode("step2", step2)
  .addNode("step3", step3)
  .addEdge(START, "step1")
  .addEdge("step1", "step2")
  .addEdge("step2", "step3");
```


<Accordion title="LangGraph로 애플리케이션 단계를 시퀀스로 분할하는 이유는?">

LangGraph를 사용하면 애플리케이션에 기본 지속성 레이어를 쉽게 추가할 수 있습니다.
이를 통해 노드 실행 사이에 state를 체크포인트할 수 있으므로 LangGraph 노드는 다음을 관리합니다:

* 상태 업데이트가 [체크포인트](/oss/javascript/langgraph/persistence)되는 방법
* [human-in-the-loop](/oss/javascript/langgraph/interrupts) 워크플로우에서 중단이 재개되는 방법
* LangGraph의 [time travel](/oss/javascript/langgraph/use-time-travel) 기능을 사용하여 실행을 "되감기"하고 분기하는 방법

또한 실행 단계가 [스트리밍](/oss/javascript/langgraph/streaming)되는 방법과 [Studio](/langsmith/studio)를 사용하여 애플리케이션이 시각화되고 디버그되는 방법을 결정합니다.

엔드투엔드 예제를 보여드리겠습니다. 세 단계의 시퀀스를 만들 것입니다:

1. state의 키에 값 채우기
2. 동일한 값 업데이트
3. 다른 값 채우기

먼저 [state](/oss/javascript/langgraph/graph-api#state)를 정의해 보겠습니다. 이것은 [그래프의 스키마](/oss/javascript/langgraph/graph-api#schema)를 관리하며 업데이트를 적용하는 방법도 지정할 수 있습니다. 자세한 내용은 [이 섹션](#process-state-updates-with-reducers)을 참조하세요.

우리의 경우 두 개의 값만 추적합니다:



```typescript
import * as z from "zod";

const State = z.object({
  value1: z.string(),
  value2: z.number(),
});
```




[nodes](/oss/javascript/langgraph/graph-api#nodes)는 그래프의 state를 읽고 업데이트하는 TypeScript 함수입니다. 이 함수의 첫 번째 인수는 항상 state입니다:

```typescript
const step1 = (state: z.infer<typeof State>) => {
  return { value1: "a" };
};

const step2 = (state: z.infer<typeof State>) => {
  const currentValue1 = state.value1;
  return { value1: `${currentValue1} b` };
};

const step3 = (state: z.infer<typeof State>) => {
  return { value2: 10 };
};
```


<Note>
state에 업데이트를 발행할 때 각 노드는 업데이트하려는 키의 값만 지정할 수 있습니다.

기본적으로 이것은 해당 키의 값을 **덮어씁니다**. [reducers](/oss/javascript/langgraph/graph-api#reducers)를 사용하여 업데이트 처리 방식을 제어할 수도 있습니다. 예를 들어 키에 연속적인 업데이트를 추가할 수 있습니다. 자세한 내용은 [이 섹션](#process-state-updates-with-reducers)을 참조하세요.
</Note>

마지막으로 그래프를 정의합니다. [StateGraph](/oss/javascript/langgraph/graph-api#stategraph)를 사용하여 이 state에서 작동하는 그래프를 정의합니다.



그런 다음 [addNode](/oss/javascript/langgraph/graph-api#nodes) 및 [addEdge](/oss/javascript/langgraph/graph-api#edges)를 사용하여 그래프를 채우고 제어 흐름을 정의합니다.

```typescript
import { START, StateGraph } from "@langchain/langgraph";

const graph = new StateGraph(State)
  .addNode("step1", step1)
  .addNode("step2", step2)
  .addNode("step3", step3)
  .addEdge(START, "step1")
  .addEdge("step1", "step2")
  .addEdge("step2", "step3")
  .compile();
```




<Tip>
**사용자 정의 이름 지정**
`.addNode`를 사용하여 노드에 사용자 정의 이름을 지정할 수 있습니다:

```typescript
const graph = new StateGraph(State)
.addNode("myNode", step1)
.compile();
```
</Tip>


다음 사항에 유의하세요:



* `.addEdge`는 노드의 이름을 받으며, 함수의 경우 기본값은 `node.name`입니다.
* 그래프의 진입점을 지정해야 합니다. 이를 위해 [START node](/oss/javascript/langgraph/graph-api#start-node)와 함께 엣지를 추가합니다.
* 실행할 노드가 더 이상 없으면 그래프가 중지됩니다.

다음으로 그래프를 [컴파일](/oss/javascript/langgraph/graph-api#compiling-your-graph)합니다. 이것은 그래프 구조에 대한 몇 가지 기본 검사를 제공합니다(예: 고립된 노드 식별). [checkpointer](/oss/javascript/langgraph/persistence)를 통해 애플리케이션에 지속성을 추가하는 경우 여기에서도 전달됩니다.


LangGraph는 그래프를 시각화하기 위한 내장 유틸리티를 제공합니다. 시퀀스를 검사해 보겠습니다. 시각화에 대한 자세한 내용은 [이 가이드](#visualize-your-graph)를 참조하세요.



```typescript
import * as fs from "node:fs/promises";

const drawableGraph = await graph.getGraphAsync();
const image = await drawableGraph.drawMermaidPng();
const imageBuffer = new Uint8Array(await image.arrayBuffer());

await fs.writeFile("graph.png", imageBuffer);
```


간단한 호출을 진행해 보겠습니다:



```typescript
const result = await graph.invoke({ value1: "c" });
console.log(result);
```

```
{ value1: 'a b', value2: 10 }
```


다음 사항에 유의하세요:

* 단일 state 키에 대한 값을 제공하여 호출을 시작했습니다. 항상 최소한 하나의 키에 대한 값을 제공해야 합니다.
* 전달한 값은 첫 번째 노드에 의해 덮어쓰여졌습니다.
* 두 번째 노드가 값을 업데이트했습니다.
* 세 번째 노드가 다른 값을 채웠습니다.



</Accordion>

## Create branches

노드의 병렬 실행은 전체 그래프 작업 속도를 높이는 데 필수적입니다. LangGraph는 노드의 병렬 실행에 대한 기본 지원을 제공하여 그래프 기반 워크플로우의 성능을 크게 향상시킬 수 있습니다. 이 병렬화는 표준 엣지와 [conditional_edges](https://langchain-ai.github.io/langgraph/reference/graphs.md#langgraph.graph.MessageGraph.add_conditional_edges)를 모두 활용하여 팬아웃 및 팬인 메커니즘을 통해 달성됩니다. 아래는 작동하는 분기 데이터 플로우를 추가하는 방법을 보여주는 몇 가지 예제입니다.

### Run graph nodes in parallel

이 예제에서는 `Node A`에서 `B와 C`로 팬아웃한 다음 `D`로 팬인합니다. state에서 [reducer add 연산을 지정](/oss/javascript/langgraph/graph-api#reducers)합니다. 이것은 기존 값을 단순히 덮어쓰는 대신 State의 특정 키에 대한 값을 결합하거나 누적합니다. 리스트의 경우 이것은 새 리스트를 기존 리스트와 연결하는 것을 의미합니다. reducer로 state를 업데이트하는 방법에 대한 자세한 내용은 위의 [state reducers](#process-state-updates-with-reducers) 섹션을 참조하세요.



```typescript
import { StateGraph, START, END } from "@langchain/langgraph";
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";

const State = z.object({
  // The reducer makes this append-only
  aggregate: z.array(z.string()).register(registry, {
    reducer: {
      fn: (x, y) => x.concat(y),
    },
    default: () => [] as string[],
  }),
});

const nodeA = (state: z.infer<typeof State>) => {
  console.log(`Adding "A" to ${state.aggregate}`);
  return { aggregate: ["A"] };
};

const nodeB = (state: z.infer<typeof State>) => {
  console.log(`Adding "B" to ${state.aggregate}`);
  return { aggregate: ["B"] };
};

const nodeC = (state: z.infer<typeof State>) => {
  console.log(`Adding "C" to ${state.aggregate}`);
  return { aggregate: ["C"] };
};

const nodeD = (state: z.infer<typeof State>) => {
  console.log(`Adding "D" to ${state.aggregate}`);
  return { aggregate: ["D"] };
};

const graph = new StateGraph(State)
  .addNode("a", nodeA)
  .addNode("b", nodeB)
  .addNode("c", nodeC)
  .addNode("d", nodeD)
  .addEdge(START, "a")
  .addEdge("a", "b")
  .addEdge("a", "c")
  .addEdge("b", "d")
  .addEdge("c", "d")
  .addEdge("d", END)
  .compile();
```




```typescript
import * as fs from "node:fs/promises";

const drawableGraph = await graph.getGraphAsync();
const image = await drawableGraph.drawMermaidPng();
const imageBuffer = new Uint8Array(await image.arrayBuffer());

await fs.writeFile("graph.png", imageBuffer);
```


reducer를 사용하면 각 노드에 추가된 값이 누적되는 것을 볼 수 있습니다.



```typescript
const result = await graph.invoke({
  aggregate: [],
});
console.log(result);
```

```
Adding "A" to []
Adding "B" to ['A']
Adding "C" to ['A']
Adding "D" to ['A', 'B', 'C']
{ aggregate: ['A', 'B', 'C', 'D'] }
```


<Note>
위의 예제에서 노드 `"b"`와 `"c"`는 동일한 [superstep](/oss/javascript/langgraph/graph-api#graphs)에서 동시에 실행됩니다. 동일한 단계에 있기 때문에 노드 `"d"`는 `"b"`와 `"c"`가 모두 완료된 후에 실행됩니다.

중요한 것은 병렬 superstep의 업데이트가 일관되게 정렬되지 않을 수 있다는 것입니다. 병렬 superstep의 업데이트에 대해 일관되고 미리 결정된 순서가 필요한 경우, 출력을 state의 별도 필드에 순서를 지정할 값과 함께 작성해야 합니다.
</Note>

<Accordion title="예외 처리는?">
  LangGraph는 [supersteps](/oss/javascript/langgraph/graph-api#graphs) 내에서 노드를 실행합니다. 즉, 병렬 분기가 병렬로 실행되는 동안 전체 superstep은 **트랜잭션**입니다. 이러한 분기 중 하나라도 예외를 발생시키면 업데이트가 state에 적용되지 **않습니다**(전체 superstep이 오류 발생).

  중요한 것은 [checkpointer](/oss/javascript/langgraph/persistence)를 사용할 때 superstep 내의 성공한 노드의 결과가 저장되고 재개될 때 반복되지 않는다는 것입니다.

  오류가 발생하기 쉬운 경우(불안정한 API 호출을 처리하고 싶을 수 있음), LangGraph는 이를 해결하는 두 가지 방법을 제공합니다:

  1. 노드 내에서 일반 python 코드를 작성하여 예외를 포착하고 처리할 수 있습니다.
  2. **[retry_policy](https://langchain-ai.github.io/langgraph/reference/types/#langgraph.types.RetryPolicy)**를 설정하여 특정 유형의 예외를 발생시키는 노드를 재시도하도록 그래프에 지시할 수 있습니다. 실패한 분기만 재시도되므로 중복 작업을 수행할 걱정이 없습니다.

  이들을 함께 사용하면 병렬 실행을 수행하고 예외 처리를 완전히 제어할 수 있습니다.
</Accordion>



<Tip>
**최대 동시성 설정**
그래프를 호출할 때 [configuration](https://reference.langchain.com/javascript/interfaces/_langchain_langgraph.index.LangGraphRunnableConfig.html)에서 `max_concurrency`를 설정하여 최대 동시 작업 수를 제어할 수 있습니다.

```typescript
const result = await graph.invoke({ value1: "c" }, {configurable: {max_concurrency: 10}});
```
</Tip>




### Conditional branching



런타임에 state에 따라 팬아웃이 달라져야 하는 경우 [addConditionalEdges](https://reference.langchain.com/javascript/classes/_langchain_langgraph.index.StateGraph.html#addconditionaledges)를 사용하여 그래프 state를 사용하여 하나 이상의 경로를 선택할 수 있습니다. 아래 예제를 참조하세요. 여기서 노드 `a`는 다음 노드를 결정하는 state 업데이트를 생성합니다.

```typescript
import { StateGraph, START, END } from "@langchain/langgraph";
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";

const State = z.object({
  aggregate: z.array(z.string()).register(registry, {
    reducer: {
      fn: (x, y) => x.concat(y),
    },
    default: () => [] as string[],
  }),
  // Add a key to the state. We will set this key to determine
  // how we branch.
  which: z.string().register(registry, {  // [!code highlight]
    reducer: {
      fn: (x, y) => y ?? x,
    },
  }),
});

const nodeA = (state: z.infer<typeof State>) => {
  console.log(`Adding "A" to ${state.aggregate}`);
  return { aggregate: ["A"], which: "c" };
};

const nodeB = (state: z.infer<typeof State>) => {
  console.log(`Adding "B" to ${state.aggregate}`);
  return { aggregate: ["B"] };
};

const nodeC = (state: z.infer<typeof State>) => {
  console.log(`Adding "C" to ${state.aggregate}`);
  return { aggregate: ["C"] };  // [!code highlight]
};

const conditionalEdge = (state: z.infer<typeof State>): "b" | "c" => {
  // Fill in arbitrary logic here that uses the state
  // to determine the next node
  return state.which as "b" | "c";
};

const graph = new StateGraph(State)
  .addNode("a", nodeA)
  .addNode("b", nodeB)
  .addNode("c", nodeC)
  .addEdge(START, "a")
  .addEdge("b", END)
  .addEdge("c", END)
  .addConditionalEdges("a", conditionalEdge)
  .compile();
```

```typescript
import * as fs from "node:fs/promises";

const drawableGraph = await graph.getGraphAsync();
const image = await drawableGraph.drawMermaidPng();
const imageBuffer = new Uint8Array(await image.arrayBuffer());

await fs.writeFile("graph.png", imageBuffer);
```

```typescript
const result = await graph.invoke({ aggregate: [] });
console.log(result);
```

```
Adding "A" to []
Adding "C" to ['A']
{ aggregate: ['A', 'C'], which: 'c' }
```


<Tip>
조건부 엣지는 여러 대상 노드로 라우팅할 수 있습니다. 예를 들어:



```typescript
const routeBcOrCd = (state: z.infer<typeof State>): string[] => {
if (state.which === "cd") {
return ["c", "d"];
}
return ["b", "c"];
};
```

</Tip>

## Map-Reduce and the Send API

LangGraph는 Send API를 사용하여 map-reduce 및 기타 고급 분기 패턴을 지원합니다. 사용 방법의 예는 다음과 같습니다:



```typescript
import { StateGraph, START, END, Send } from "@langchain/langgraph";
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";

const OverallState = z.object({
  topic: z.string(),
  subjects: z.array(z.string()),
  jokes: z.array(z.string()).register(registry, {
    reducer: {
      fn: (x, y) => x.concat(y),
    },
  }),
  bestSelectedJoke: z.string(),
});

const generateTopics = (state: z.infer<typeof OverallState>) => {
  return { subjects: ["lions", "elephants", "penguins"] };
};

const generateJoke = (state: { subject: string }) => {
  const jokeMap: Record<string, string> = {
    lions: "Why don't lions like fast food? Because they can't catch it!",
    elephants: "Why don't elephants use computers? They're afraid of the mouse!",
    penguins: "Why don't penguins like talking to strangers at parties? Because they find it hard to break the ice."
  };
  return { jokes: [jokeMap[state.subject]] };
};

const continueToJokes = (state: z.infer<typeof OverallState>) => {
  return state.subjects.map((subject) => new Send("generateJoke", { subject }));
};

const bestJoke = (state: z.infer<typeof OverallState>) => {
  return { bestSelectedJoke: "penguins" };
};

const graph = new StateGraph(OverallState)
  .addNode("generateTopics", generateTopics)
  .addNode("generateJoke", generateJoke)
  .addNode("bestJoke", bestJoke)
  .addEdge(START, "generateTopics")
  .addConditionalEdges("generateTopics", continueToJokes)
  .addEdge("generateJoke", "bestJoke")
  .addEdge("bestJoke", END)
  .compile();
```

```typescript
import * as fs from "node:fs/promises";

const drawableGraph = await graph.getGraphAsync();
const image = await drawableGraph.drawMermaidPng();
const imageBuffer = new Uint8Array(await image.arrayBuffer());

await fs.writeFile("graph.png", imageBuffer);
```

```typescript
// Call the graph: here we call it to generate a list of jokes
for await (const step of await graph.stream({ topic: "animals" })) {
  console.log(step);
}
```

```
{ generateTopics: { subjects: [ 'lions', 'elephants', 'penguins' ] } }
{ generateJoke: { jokes: [ "Why don't lions like fast food? Because they can't catch it!" ] } }
{ generateJoke: { jokes: [ "Why don't elephants use computers? They're afraid of the mouse!" ] } }
{ generateJoke: { jokes: [ "Why don't penguins like talking to strangers at parties? Because they find it hard to break the ice." ] } }
{ bestJoke: { bestSelectedJoke: 'penguins' } }
```


## Create and control loops

루프가 있는 그래프를 만들 때 실행을 종료하는 메커니즘이 필요합니다. 이것은 일반적으로 종료 조건에 도달하면 [END](/oss/javascript/langgraph/graph-api#end-node) 노드로 라우팅하는 [conditional edge](/oss/javascript/langgraph/graph-api#conditional-edges)를 추가하여 수행됩니다.

그래프를 호출하거나 스트리밍할 때 그래프 재귀 제한을 설정할 수도 있습니다. 재귀 제한은 오류를 발생시키기 전에 그래프가 실행할 수 있는 [supersteps](/oss/javascript/langgraph/graph-api#graphs) 수를 설정합니다. 재귀 제한의 개념에 대한 자세한 내용은 [여기](/oss/javascript/langgraph/graph-api#recursion-limit)를 참조하세요.

이러한 메커니즘이 어떻게 작동하는지 더 잘 이해하기 위해 루프가 있는 간단한 그래프를 고려해 보겠습니다.

<Tip>
재귀 제한 오류를 받는 대신 state의 마지막 값을 반환하려면 [다음 섹션](#impose-a-recursion-limit)을 참조하세요.
</Tip>

루프를 만들 때 종료 조건을 지정하는 조건부 엣지를 포함할 수 있습니다:



```typescript
const graph = new StateGraph(State)
  .addNode("a", nodeA)
  .addNode("b", nodeB)
  .addEdge(START, "a")
  .addConditionalEdges("a", route)
  .addEdge("b", "a")
  .compile();

const route = (state: z.infer<typeof State>): "b" | typeof END => {
  if (terminationCondition(state)) {
    return END;
  } else {
    return "b";
  }
};
```


재귀 제한을 제어하려면 config에서 `"recursionLimit"`을 지정합니다. 이것은 `GraphRecursionError`를 발생시키며, 이를 포착하고 처리할 수 있습니다:



```typescript
import { GraphRecursionError } from "@langchain/langgraph";

try {
  await graph.invoke(inputs, { recursionLimit: 3 });
} catch (error) {
  if (error instanceof GraphRecursionError) {
    console.log("Recursion Error");
  }
}
```


간단한 루프가 있는 그래프를 정의해 보겠습니다. 종료 조건을 구현하기 위해 조건부 엣지를 사용합니다.



```typescript
import { StateGraph, START, END } from "@langchain/langgraph";
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";

const State = z.object({
  // The reducer makes this append-only
  aggregate: z.array(z.string()).register(registry, {
    reducer: {
      fn: (x, y) => x.concat(y),
    },
    default: () => [] as string[],
  }),
});

const nodeA = (state: z.infer<typeof State>) => {
  console.log(`Node A sees ${state.aggregate}`);
  return { aggregate: ["A"] };
};

const nodeB = (state: z.infer<typeof State>) => {
  console.log(`Node B sees ${state.aggregate}`);
  return { aggregate: ["B"] };
};

// Define edges
const route = (state: z.infer<typeof State>): "b" | typeof END => {
  if (state.aggregate.length < 7) {
    return "b";
  } else {
    return END;
  }
};

const graph = new StateGraph(State)
  .addNode("a", nodeA)
  .addNode("b", nodeB)
  .addEdge(START, "a")
  .addConditionalEdges("a", route)
  .addEdge("b", "a")
  .compile();
```

```typescript
import * as fs from "node:fs/promises";

const drawableGraph = await graph.getGraphAsync();
const image = await drawableGraph.drawMermaidPng();
const imageBuffer = new Uint8Array(await image.arrayBuffer());

await fs.writeFile("graph.png", imageBuffer);
```


이 아키텍처는 노드 `"a"`가 도구 호출 모델이고 노드 `"b"`가 도구를 나타내는 [ReAct agent](/oss/javascript/langgraph/workflows-agents)와 유사합니다.

`route` 조건부 엣지에서 state의 `"aggregate"` 리스트가 임계값 길이를 초과한 후 종료하도록 지정합니다.

그래프를 호출하면 종료 조건에 도달할 때까지 노드 `"a"`와 `"b"` 사이를 번갈아 가며 종료되는 것을 볼 수 있습니다.



```typescript
const result = await graph.invoke({ aggregate: [] });
console.log(result);
```

```
Node A sees []
Node B sees ['A']
Node A sees ['A', 'B']
Node B sees ['A', 'B', 'A']
Node A sees ['A', 'B', 'A', 'B']
Node B sees ['A', 'B', 'A', 'B', 'A']
Node A sees ['A', 'B', 'A', 'B', 'A', 'B']
{ aggregate: ['A', 'B', 'A', 'B', 'A', 'B', 'A'] }
```


### Impose a recursion limit

일부 애플리케이션에서는 주어진 종료 조건에 도달한다는 보장이 없을 수 있습니다. 이러한 경우 그래프의 [recursion limit](/oss/javascript/langgraph/graph-api#recursion-limit)을 설정할 수 있습니다. 이것은 주어진 수의 [supersteps](/oss/javascript/langgraph/graph-api#graphs) 후에 `GraphRecursionError`를 발생시킵니다. 그런 다음 이 예외를 포착하고 처리할 수 있습니다:



```typescript
import { GraphRecursionError } from "@langchain/langgraph";

try {
  await graph.invoke({ aggregate: [] }, { recursionLimit: 4 });
} catch (error) {
  if (error instanceof GraphRecursionError) {
    console.log("Recursion Error");
  }
}
```

```
Node A sees []
Node B sees ['A']
Node A sees ['A', 'B']
Node B sees ['A', 'B', 'A']
Node A sees ['A', 'B', 'A', 'B']
Recursion Error
```








## Combine control flow and state updates with `Command`

제어 흐름(엣지)과 상태 업데이트(노드)를 결합하는 것이 유용할 수 있습니다. 예를 들어, 동일한 노드에서 상태 업데이트를 수행하고 다음에 갈 노드를 결정하고 싶을 수 있습니다. LangGraph는 노드 함수에서 [Command](https://langchain-ai.github.io/langgraph/reference/types/#langgraph.types.Command) 객체를 반환하여 이를 수행하는 방법을 제공합니다:



```typescript
import { Command } from "@langchain/langgraph";

const myNode = (state: State): Command => {
  return new Command({
    // state update
    update: { foo: "bar" },
    // control flow
    goto: "myOtherNode"
  });
};
```


아래에서 엔드투엔드 예제를 보여줍니다. A, B, C 세 개의 노드가 있는 간단한 그래프를 만들어 보겠습니다. 먼저 노드 A를 실행한 다음 노드 A의 출력에 따라 노드 B 또는 노드 C로 갈지 결정합니다.



```typescript
import { StateGraph, START, Command } from "@langchain/langgraph";
import * as z from "zod";

// Define graph state
const State = z.object({
  foo: z.string(),
});

// Define the nodes

const nodeA = (state: z.infer<typeof State>): Command => {
  console.log("Called A");
  const value = Math.random() > 0.5 ? "b" : "c";
  // this is a replacement for a conditional edge function
  const goto = value === "b" ? "nodeB" : "nodeC";

  // note how Command allows you to BOTH update the graph state AND route to the next node
  return new Command({
    // this is the state update
    update: { foo: value },
    // this is a replacement for an edge
    goto,
  });
};

const nodeB = (state: z.infer<typeof State>) => {
  console.log("Called B");
  return { foo: state.foo + "b" };
};

const nodeC = (state: z.infer<typeof State>) => {
  console.log("Called C");
  return { foo: state.foo + "c" };
};
```

이제 위의 노드로 `StateGraph`를 만들 수 있습니다. 그래프에 라우팅을 위한 [conditional edges](/oss/javascript/langgraph/graph-api#conditional-edges)가 없다는 점에 유의하세요! 이것은 제어 흐름이 `nodeA` 내부에서 `Command`로 정의되기 때문입니다.

```typescript
const graph = new StateGraph(State)
  .addNode("nodeA", nodeA, {
    ends: ["nodeB", "nodeC"],
  })
  .addNode("nodeB", nodeB)
  .addNode("nodeC", nodeC)
  .addEdge(START, "nodeA")
  .compile();
```

<Warning>
`ends`를 사용하여 `nodeA`가 이동할 수 있는 노드를 지정했다는 것을 알 수 있습니다. 이것은 그래프 렌더링에 필요하며 LangGraph에 `nodeA`가 `nodeB`와 `nodeC`로 이동할 수 있음을 알려줍니다.
</Warning>

```typescript
import * as fs from "node:fs/promises";

const drawableGraph = await graph.getGraphAsync();
const image = await drawableGraph.drawMermaidPng();
const imageBuffer = new Uint8Array(await image.arrayBuffer());

await fs.writeFile("graph.png", imageBuffer);
```

그래프를 여러 번 실행하면 노드 A의 무작위 선택에 따라 다른 경로(A -> B 또는 A -> C)를 취하는 것을 볼 수 있습니다.

```typescript
const result = await graph.invoke({ foo: "" });
console.log(result);
```

```
Called A
Called C
{ foo: 'cc' }
```


### Navigate to a node in a parent graph

[subgraphs](/oss/javascript/langgraph/use-subgraphs)를 사용하는 경우 서브그래프 내의 노드에서 다른 서브그래프(즉, 부모 그래프의 다른 노드)로 이동하고 싶을 수 있습니다. 이렇게 하려면 `Command`에서 `graph=Command.PARENT`를 지정할 수 있습니다:



```typescript
const myNode = (state: State): Command => {
  return new Command({
    update: { foo: "bar" },
    goto: "otherSubgraph",  // where `otherSubgraph` is a node in the parent graph
    graph: Command.PARENT
  });
};
```


위의 예제를 사용하여 이를 시연해 보겠습니다. 위의 예제에서 `nodeA`를 부모 그래프에 서브그래프로 추가할 단일 노드 그래프로 변경하여 이를 수행합니다.

<Warning>
**`Command.PARENT`를 사용한 상태 업데이트**
서브그래프 노드에서 부모 그래프 노드로 부모와 서브그래프 [state schemas](/oss/javascript/langgraph/graph-api#schema) 모두에서 공유되는 키에 대한 업데이트를 보낼 때, 부모 그래프 state에서 업데이트하는 키에 대해 [reducer](/oss/javascript/langgraph/graph-api#reducers)를 **반드시** 정의해야 합니다. 아래 예제를 참조하세요.
</Warning>



```typescript
import { StateGraph, START, Command } from "@langchain/langgraph";
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";

const State = z.object({
  // NOTE: we define a reducer here
  foo: z.string().register(registry, {  // [!code highlight]
    reducer: {
      fn: (x, y) => x + y,
    },
  }),
});

const nodeA = (state: z.infer<typeof State>) => {
  console.log("Called A");
  const value = Math.random() > 0.5 ? "nodeB" : "nodeC";

  // note how Command allows you to BOTH update the graph state AND route to the next node
  return new Command({
    update: { foo: "a" },  // [!code highlight]
    goto: value,
    // this tells LangGraph to navigate to nodeB or nodeC in the parent graph
    // NOTE: this will navigate to the closest parent graph relative to the subgraph
    graph: Command.PARENT,
  });
};

const subgraph = new StateGraph(State)
  .addNode("nodeA", nodeA, { ends: ["nodeB", "nodeC"] })
  .addEdge(START, "nodeA")
  .compile();

const nodeB = (state: z.infer<typeof State>) => {
  console.log("Called B");  // [!code highlight]
  // NOTE: since we've defined a reducer, we don't need to manually append
  // new characters to existing 'foo' value. instead, reducer will append these
  // automatically
  return { foo: "b" };
};  // [!code highlight]

const nodeC = (state: z.infer<typeof State>) => {
  console.log("Called C");
  return { foo: "c" };
};

const graph = new StateGraph(State)
  .addNode("subgraph", subgraph, { ends: ["nodeB", "nodeC"] })
  .addNode("nodeB", nodeB)
  .addNode("nodeC", nodeC)
  .addEdge(START, "subgraph")
  .compile();
```

```typescript
const result = await graph.invoke({ foo: "" });
console.log(result);
```

```
Called A
Called C
{ foo: 'ac' }
```


### Use inside tools

일반적인 사용 사례는 도구 내부에서 그래프 state를 업데이트하는 것입니다. 예를 들어, 고객 지원 애플리케이션에서 대화 시작 시 계정 번호 또는 ID를 기반으로 고객 정보를 조회하고 싶을 수 있습니다. 도구에서 그래프 state를 업데이트하려면 도구에서 `Command(update={"my_custom_key": "foo", "messages": [...]})`를 반환할 수 있습니다:



```typescript
import { tool } from "@langchain/core/tools";
import { Command } from "@langchain/langgraph";
import * as z from "zod";

const lookupUserInfo = tool(
  async (input, config) => {
    const userId = config.configurable?.userId;
    const userInfo = getUserInfo(userId);
    return new Command({
      update: {
        // update the state keys
        userInfo: userInfo,
        // update the message history
        messages: [{
          role: "tool",
          content: "Successfully looked up user information",
          tool_call_id: config.toolCall.id
        }]
      }
    });
  },
  {
    name: "lookupUserInfo",
    description: "Use this to look up user information to better assist them with their questions.",
    schema: z.object({}),
  }
);
```


<Warning>
도구에서 [`Command`](https://langchain-ai.github.io/langgraphjs/reference/classes/langgraph.Command.html)를 반환할 때 `Command.update`에 `messages`(또는 메시지 기록에 사용되는 state 키)를 **반드시** 포함해야 하며 `messages`의 메시지 목록에는 `ToolMessage`가 **반드시** 포함되어야 합니다. 이것은 결과 메시지 기록이 유효하도록 하기 위해 필요합니다(LLM 제공자는 도구 호출이 있는 AI 메시지 다음에 도구 결과 메시지가 와야 함을 요구합니다).
</Warning>

[`Command`](https://langchain-ai.github.io/langgraphjs/reference/classes/langgraph.Command.html)를 통해 state를 업데이트하는 도구를 사용하는 경우, `Command` 객체를 반환하는 도구를 자동으로 처리하고 그래프 state로 전파하는 사전 구축된 [`ToolNode`](https://reference.langchain.com/javascript/classes/langchain.index.ToolNode.html)를 사용하는 것이 좋습니다. 도구를 호출하는 사용자 정의 노드를 작성하는 경우 도구에서 반환된 [`Command`](https://langchain-ai.github.io/langgraphjs/reference/classes/langgraph.Command.html) 객체를 노드의 업데이트로 수동으로 전파해야 합니다.

## Visualize your graph

여기서는 생성한 그래프를 시각화하는 방법을 보여줍니다.

[StateGraph](https://langchain-ai.github.io/langgraph/reference/graphs/#langgraph.graph.state.StateGraph)를 포함한 임의의 [Graph](https://langchain-ai.github.io/langgraph/reference/graphs/)를 시각화할 수 있습니다.



시각화를 시연하기 위해 간단한 예제 그래프를 만들어 보겠습니다.

```typescript
import { StateGraph, START, END, MessagesZodMeta } from "@langchain/langgraph";
import { BaseMessage } from "@langchain/core/messages";
import { registry } from "@langchain/langgraph/zod";
import * as z from "zod";

const State = z.object({
  messages: z
    .array(z.custom<BaseMessage>())
    .register(registry, MessagesZodMeta),
  value: z.number().register(registry, {
    reducer: {
      fn: (x, y) => x + y,
    },
  }),
});

const app = new StateGraph(State)
  .addNode("node1", (state) => {
    return { value: state.value + 1 };
  })
  .addNode("node2", (state) => {
    return { value: state.value * 2 };
  })
  .addEdge(START, "node1")
  .addConditionalEdges("node1", (state) => {
    if (state.value < 10) {
      return "node2";
    }
    return END;
  })
  .addEdge("node2", "node1")
  .compile();
```


### Mermaid

그래프 클래스를 Mermaid 구문으로 변환할 수도 있습니다.



```typescript
const drawableGraph = await app.getGraphAsync();
console.log(drawableGraph.drawMermaid());
```

```
%%{init: {'flowchart': {'curve': 'linear'}}}%%
graph TD;
    tart__([<p>__start__</p>]):::first
    e1(node1)
    e2(node2)
    nd__([<p>__end__</p>]):::last
    tart__ --> node1;
    e1 -.-> node2;
    e1 -.-> __end__;
    e2 --> node1;
    ssDef default fill:#f2f0ff,line-height:1.2
    ssDef first fill-opacity:0
    ssDef last fill:#bfb6fc
```


### PNG



원하는 경우 그래프를 `.png`로 렌더링할 수 있습니다. 이것은 Mermaid.ink API를 사용하여 다이어그램을 생성합니다.

```typescript
import * as fs from "node:fs/promises";

const drawableGraph = await app.getGraphAsync();
const image = await drawableGraph.drawMermaidPng();
const imageBuffer = new Uint8Array(await image.arrayBuffer());

await fs.writeFile("graph.png", imageBuffer);
```

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/langgraph/use-graph-api.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for    real-time answers.
</Tip>
