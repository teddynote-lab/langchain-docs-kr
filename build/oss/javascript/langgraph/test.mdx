---
title: 테스트
---



LangGraph 에이전트의 프로토타입을 만든 후, 자연스러운 다음 단계는 테스트를 추가하는 것입니다. 이 가이드는 단위 테스트를 작성할 때 사용할 수 있는 유용한 패턴들을 다룹니다.

이 가이드는 LangGraph에 특화되어 있으며 커스텀 구조를 가진 graph와 관련된 시나리오를 다룹니다 - 막 시작하는 경우, LangChain의 내장 @[`create_agent`]를 사용하는 [이 섹션](/oss/javascript/langchain/test/)을 확인하세요.

## 사전 요구사항



먼저, [`vitest`](https://vitest.dev/)가 설치되어 있는지 확인하세요:

```bash
$ npm install -D vitest
```


## 시작하기

많은 LangGraph 에이전트가 state에 의존하기 때문에, 유용한 패턴은 사용하려는 각 테스트 전에 graph를 생성한 다음, 테스트 내에서 새로운 checkpointer 인스턴스로 컴파일하는 것입니다.

아래 예제는 `node1`과 `node2`를 거쳐 진행되는 간단한 선형 graph에서 이것이 어떻게 작동하는지 보여줍니다. 각 node는 단일 state key인 `my_key`를 업데이트합니다:



```ts
import { test, expect } from 'vitest';
import {
  StateGraph,
  START,
  END,
  MemorySaver,
} from '@langchain/langgraph';
import { z } from "zod/v4";

const State = z.object({
  my_key: z.string(),
});

const createGraph = () => {
  return new StateGraph(State)
    .addNode('node1', (state) => ({ my_key: 'hello from node1' }))
    .addNode('node2', (state) => ({ my_key: 'hello from node2' }))
    .addEdge(START, 'node1')
    .addEdge('node1', 'node2')
    .addEdge('node2', END);
};

test('basic agent execution', async () => {
  const uncompiledGraph = createGraph();
  const checkpointer = new MemorySaver();
  const compiledGraph = uncompiledGraph.compile({ checkpointer });
  const result = await compiledGraph.invoke(
    { my_key: 'initial_value' },
    { configurable: { thread_id: '1' } }
  );
  expect(result.my_key).toBe('hello from node2');
});
```


## 개별 node와 edge 테스트하기

컴파일된 LangGraph 에이전트는 각 개별 node에 대한 참조를 `graph.nodes`로 노출합니다. 이를 활용하여 에이전트 내의 개별 node를 테스트할 수 있습니다. 이는 graph를 컴파일할 때 전달된 checkpointer를 우회한다는 점에 유의하세요:



```ts
import { test, expect } from 'vitest';
import {
  StateGraph,
  START,
  END,
  MemorySaver,
} from '@langchain/langgraph';
import { z } from "zod/v4";

const State = z.object({
  my_key: z.string(),
});

const createGraph = () => {
  return new StateGraph(State)
    .addNode('node1', (state) => ({ my_key: 'hello from node1' }))
    .addNode('node2', (state) => ({ my_key: 'hello from node2' }))
    .addEdge(START, 'node1')
    .addEdge('node1', 'node2')
    .addEdge('node2', END);
};

test('individual node execution', async () => {
  const uncompiledGraph = createGraph();
  // Will be ignored in this example
  const checkpointer = new MemorySaver();
  const compiledGraph = uncompiledGraph.compile({ checkpointer });
  // Only invoke node 1
  const result = await compiledGraph.nodes['node1'].invoke(
    { my_key: 'initial_value' },
  );
  expect(result.my_key).toBe('hello from node1');
});
```


## 부분 실행

더 큰 graph로 구성된 에이전트의 경우, 전체 플로우를 end-to-end로 테스트하는 대신 에이전트 내의 부분 실행 경로를 테스트하고 싶을 수 있습니다. 경우에 따라 [이러한 섹션을 subgraph로 재구성](/oss/javascript/langgraph/use-subgraphs)하는 것이 의미상 타당할 수 있으며, 이를 일반적으로 독립적으로 호출할 수 있습니다.

그러나 에이전트 graph의 전체 구조를 변경하고 싶지 않다면, LangGraph의 persistence 메커니즘을 사용하여 원하는 섹션의 시작 직전에 에이전트가 일시 중지되고, 원하는 섹션의 끝에서 다시 일시 중지되는 상태를 시뮬레이션할 수 있습니다. 단계는 다음과 같습니다:


1. checkpointer와 함께 에이전트를 컴파일합니다 (테스트를 위해서는 in-memory checkpointer [`MemorySaver`](https://reference.langchain.com/javascript/classes/_langchain_langgraph-checkpoint.MemorySaver.html)로 충분합니다).
2. 테스트를 시작하려는 node *이전*의 node 이름으로 설정된 [`asNode`](/oss/javascript/langgraph/persistence#as-node) 매개변수와 함께 에이전트의 [`update_state`](/oss/javascript/langgraph/use-time-travel) 메서드를 호출합니다.
3. state를 업데이트하는 데 사용한 것과 동일한 `thread_id`와 중지하려는 node의 이름으로 설정된 `interruptBefore` 매개변수로 에이전트를 호출합니다.


다음은 선형 graph에서 두 번째와 세 번째 node만 실행하는 예제입니다:



```ts
import { test, expect } from 'vitest';
import {
  StateGraph,
  START,
  END,
  MemorySaver,
} from '@langchain/langgraph';
import { z } from "zod/v4";

const State = z.object({
  my_key: z.string(),
});

const createGraph = () => {
  return new StateGraph(State)
    .addNode('node1', (state) => ({ my_key: 'hello from node1' }))
    .addNode('node2', (state) => ({ my_key: 'hello from node2' }))
    .addNode('node3', (state) => ({ my_key: 'hello from node3' }))
    .addNode('node4', (state) => ({ my_key: 'hello from node4' }))
    .addEdge(START, 'node1')
    .addEdge('node1', 'node2')
    .addEdge('node2', 'node3')
    .addEdge('node3', 'node4')
    .addEdge('node4', END);
};

test('partial execution from node2 to node3', async () => {
  const uncompiledGraph = createGraph();
  const checkpointer = new MemorySaver();
  const compiledGraph = uncompiledGraph.compile({ checkpointer });
  await compiledGraph.updateState(
    { configurable: { thread_id: '1' } },
    // The state passed into node 2 - simulating the state at
    // the end of node 1
    { my_key: 'initial_value' },
    // Update saved state as if it came from node 1
    // Execution will resume at node 2
    'node1',
  );
  const result = await compiledGraph.invoke(
    // Resume execution by passing None
    null,
    {
      configurable: { thread_id: '1' },
      // Stop after node 3 so that node 4 doesn't run
      interruptAfter: ['node3']
    },
  );
  expect(result.my_key).toBe('hello from node3');
});
```

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/langgraph/test.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for    real-time answers.
</Tip>
