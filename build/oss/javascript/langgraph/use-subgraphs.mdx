---
title: Subgraph
sidebarTitle: Subgraph
---



이 가이드는 subgraph 사용의 메커니즘을 설명합니다. Subgraph는 다른 graph에서 [node](/oss/javascript/langgraph/graph-api#nodes)로 사용되는 [graph](/oss/javascript/langgraph/graph-api#graphs)입니다.

Subgraph는 다음과 같은 경우에 유용합니다:
- [멀티 에이전트 시스템](/oss/javascript/langchain/multi-agent) 구축
- 여러 graph에서 node 집합 재사용
- 개발 분산: 서로 다른 팀이 graph의 다른 부분을 독립적으로 작업하려는 경우, 각 부분을 subgraph로 정의할 수 있으며, subgraph 인터페이스(입력 및 출력 schema)가 준수되는 한 parent graph는 subgraph의 세부 사항을 알 필요 없이 구축될 수 있습니다

Subgraph를 추가할 때 parent graph와 subgraph가 통신하는 방법을 정의해야 합니다:

* [node에서 graph 호출](#invoke-a-graph-from-a-node) — subgraph는 parent graph의 node 내부에서 호출됩니다
* [graph를 node로 추가](#add-a-graph-as-a-node) — subgraph가 parent의 node로 직접 추가되고 parent와 **[state key](/oss/javascript/langgraph/graph-api#state)를 공유**합니다

## Setup



```bash
npm install @langchain/langgraph
```


<Tip>
**LangGraph 개발을 위한 LangSmith 설정**
[LangSmith](https://smith.langchain.com)에 가입하여 LangGraph 프로젝트의 문제를 빠르게 발견하고 성능을 개선하세요. LangSmith를 사용하면 trace 데이터를 활용하여 LangGraph로 구축된 LLM 앱을 디버그, 테스트 및 모니터링할 수 있습니다 — 시작하는 방법에 대한 자세한 내용은 [여기](https://docs.smith.langchain.com)를 참조하세요.
</Tip>


## Invoke a graph from a node

Subgraph를 구현하는 간단한 방법은 다른 graph의 node 내부에서 graph를 호출하는 것입니다. 이 경우 subgraph는 parent graph와 **완전히 다른 schema**를 가질 수 있습니다(공유 key 없음). 예를 들어, [멀티 에이전트](/oss/javascript/langchain/multi-agent) 시스템의 각 에이전트에 대해 개별 메시지 기록을 유지하고 싶을 수 있습니다.

애플리케이션이 이러한 경우라면 **subgraph를 호출하는 node 함수**를 정의해야 합니다. 이 함수는 subgraph를 호출하기 전에 입력(parent) state를 subgraph state로 변환하고, node에서 state 업데이트를 반환하기 전에 결과를 다시 parent state로 변환해야 합니다.



```typescript
import { StateGraph, START } from "@langchain/langgraph";
import * as z from "zod";

const SubgraphState = z.object({
  bar: z.string(),
});

// Subgraph
const subgraphBuilder = new StateGraph(SubgraphState)
  .addNode("subgraphNode1", (state) => {
    return { bar: "hi! " + state.bar };
  })
  .addEdge(START, "subgraphNode1");

const subgraph = subgraphBuilder.compile();

// Parent graph
const State = z.object({
  foo: z.string(),
});

// Transform the state to the subgraph state and back
const builder = new StateGraph(State)
  .addNode("node1", async (state) => {
    const subgraphOutput = await subgraph.invoke({ bar: state.foo });
    return { foo: subgraphOutput.bar };
  })
  .addEdge(START, "node1");

const graph = builder.compile();
```


<Accordion title="전체 예제: 다른 state schema">


  ```typescript
  import { StateGraph, START } from "@langchain/langgraph";
  import * as z from "zod";

  // Define subgraph
  const SubgraphState = z.object({
    // note that none of these keys are shared with the parent graph state
    bar: z.string(),
    baz: z.string(),
  });

  const subgraphBuilder = new StateGraph(SubgraphState)
    .addNode("subgraphNode1", (state) => {
      return { baz: "baz" };
    })
    .addNode("subgraphNode2", (state) => {
      return { bar: state.bar + state.baz };
    })
    .addEdge(START, "subgraphNode1")
    .addEdge("subgraphNode1", "subgraphNode2");

  const subgraph = subgraphBuilder.compile();

  // Define parent graph
  const ParentState = z.object({
    foo: z.string(),
  });

  const builder = new StateGraph(ParentState)
    .addNode("node1", (state) => {
      return { foo: "hi! " + state.foo };
    })
    .addNode("node2", async (state) => {
      const response = await subgraph.invoke({ bar: state.foo });   // [!code highlight]
      return { foo: response.bar };   // [!code highlight]
    })
    .addEdge(START, "node1")
    .addEdge("node1", "node2");

  const graph = builder.compile();

  for await (const chunk of await graph.stream(
    { foo: "foo" },
    { subgraphs: true }
  )) {
    console.log(chunk);
  }
  ```

  1. state를 subgraph state로 변환
  2. 응답을 parent state로 다시 변환

  ```
  [[], { node1: { foo: 'hi! foo' } }]
  [['node2:9c36dd0f-151a-cb42-cbad-fa2f851f9ab7'], { subgraphNode1: { baz: 'baz' } }]
  [['node2:9c36dd0f-151a-cb42-cbad-fa2f851f9ab7'], { subgraphNode2: { bar: 'hi! foobaz' } }]
  [[], { node2: { foo: 'hi! foobaz' } }]
  ```

</Accordion>

<Accordion title="전체 예제: 다른 state schema (두 단계의 subgraph)">
  이것은 두 단계의 subgraph가 있는 예제입니다: parent -> child -> grandchild.



  ```typescript
  import { StateGraph, START, END } from "@langchain/langgraph";
  import * as z from "zod";

  // Grandchild graph
  const GrandChildState = z.object({
    myGrandchildKey: z.string(),
  });

  const grandchild = new StateGraph(GrandChildState)
    .addNode("grandchild1", (state) => {
      // NOTE: child or parent keys will not be accessible here
      return { myGrandchildKey: state.myGrandchildKey + ", how are you" };
    })
    .addEdge(START, "grandchild1")
    .addEdge("grandchild1", END);

  const grandchildGraph = grandchild.compile();

  // Child graph
  const ChildState = z.object({
    myChildKey: z.string(),
  });

  const child = new StateGraph(ChildState)
    .addNode("child1", async (state) => {
      // NOTE: parent or grandchild keys won't be accessible here
      const grandchildGraphInput = { myGrandchildKey: state.myChildKey };   // [!code highlight]
      const grandchildGraphOutput = await grandchildGraph.invoke(grandchildGraphInput);
      return { myChildKey: grandchildGraphOutput.myGrandchildKey + " today?" };   // [!code highlight]
    })   // [!code highlight]
    .addEdge(START, "child1")
    .addEdge("child1", END);

  const childGraph = child.compile();

  // Parent graph
  const ParentState = z.object({
    myKey: z.string(),
  });

  const parent = new StateGraph(ParentState)
    .addNode("parent1", (state) => {
      // NOTE: child or grandchild keys won't be accessible here
      return { myKey: "hi " + state.myKey };
    })
    .addNode("child", async (state) => {
      const childGraphInput = { myChildKey: state.myKey };   // [!code highlight]
      const childGraphOutput = await childGraph.invoke(childGraphInput);
      return { myKey: childGraphOutput.myChildKey };   // [!code highlight]
    })   // [!code highlight]
    .addNode("parent2", (state) => {
      return { myKey: state.myKey + " bye!" };
    })
    .addEdge(START, "parent1")
    .addEdge("parent1", "child")
    .addEdge("child", "parent2")
    .addEdge("parent2", END);

  const parentGraph = parent.compile();

  for await (const chunk of await parentGraph.stream(
    { myKey: "Bob" },
    { subgraphs: true }
  )) {
    console.log(chunk);
  }
  ```

  1. child state channel(`myChildKey`)에서 grandchild state channel(`myGrandchildKey`)로 state를 변환합니다
  2. grandchild state channel(`myGrandchildKey`)에서 child state channel(`myChildKey`)로 state를 다시 변환합니다
  3. 컴파일된 graph(`grandchildGraph`)가 아닌 함수를 전달합니다
  4. parent state channel(`myKey`)에서 child state channel(`myChildKey`)로 state를 변환합니다
  5. child state channel(`myChildKey`)에서 parent state channel(`myKey`)로 state를 다시 변환합니다
  6. 컴파일된 graph(`childGraph`)가 아닌 함수를 전달합니다

  ```
  [[], { parent1: { myKey: 'hi Bob' } }]
  [['child:2e26e9ce-602f-862c-aa66-1ea5a4655e3b', 'child1:781bb3b1-3971-84ce-810b-acf819a03f9c'], { grandchild1: { myGrandchildKey: 'hi Bob, how are you' } }]
  [['child:2e26e9ce-602f-862c-aa66-1ea5a4655e3b'], { child1: { myChildKey: 'hi Bob, how are you today?' } }]
  [[], { child: { myKey: 'hi Bob, how are you today?' } }]
  [[], { parent2: { myKey: 'hi Bob, how are you today? bye!' } }]
  ```

</Accordion>

## Add a graph as a node

Parent graph와 subgraph가 [schema](/oss/javascript/langgraph/graph-api#state)의 공유 state key(channel)를 통해 통신할 수 있는 경우, graph를 다른 graph의 [node](/oss/javascript/langgraph/graph-api#nodes)로 추가할 수 있습니다. 예를 들어, [멀티 에이전트](/oss/javascript/langchain/multi-agent) 시스템에서 에이전트들은 종종 공유 [messages](/oss/javascript/langgraph/graph-api#why-use-messages) key를 통해 통신합니다.

<img
  src="/oss/images/subgraph.png"
  alt="SQL agent graph"
  style={{ height: "450px" }}
/>

Subgraph가 parent graph와 state key를 공유하는 경우, 다음 단계에 따라 graph에 추가할 수 있습니다:



1. Subgraph workflow(`subgraphBuilder`)를 정의하고 컴파일합니다
2. Parent graph workflow를 정의할 때 `.addNode` 메서드에 컴파일된 subgraph를 전달합니다

```typescript
import { StateGraph, START } from "@langchain/langgraph";
import * as z from "zod";

const State = z.object({
  foo: z.string(),
});

// Subgraph
const subgraphBuilder = new StateGraph(State)
  .addNode("subgraphNode1", (state) => {
    return { foo: "hi! " + state.foo };
  })
  .addEdge(START, "subgraphNode1");

const subgraph = subgraphBuilder.compile();

// Parent graph
const builder = new StateGraph(State)
  .addNode("node1", subgraph)
  .addEdge(START, "node1");

const graph = builder.compile();
```


<Accordion title="전체 예제: 공유 state schema">


  ```typescript
  import { StateGraph, START } from "@langchain/langgraph";
  import * as z from "zod";

  // Define subgraph
  const SubgraphState = z.object({
    foo: z.string(),    // [!code highlight]
    bar: z.string(),    // [!code highlight]
  });

  const subgraphBuilder = new StateGraph(SubgraphState)
    .addNode("subgraphNode1", (state) => {
      return { bar: "bar" };
    })
    .addNode("subgraphNode2", (state) => {
      // note that this node is using a state key ('bar') that is only available in the subgraph
      // and is sending update on the shared state key ('foo')
      return { foo: state.foo + state.bar };
    })
    .addEdge(START, "subgraphNode1")
    .addEdge("subgraphNode1", "subgraphNode2");

  const subgraph = subgraphBuilder.compile();

  // Define parent graph
  const ParentState = z.object({
    foo: z.string(),
  });

  const builder = new StateGraph(ParentState)
    .addNode("node1", (state) => {
      return { foo: "hi! " + state.foo };
    })
    .addNode("node2", subgraph)
    .addEdge(START, "node1")
    .addEdge("node1", "node2");

  const graph = builder.compile();

  for await (const chunk of await graph.stream({ foo: "foo" })) {
    console.log(chunk);
  }
  ```

  1. 이 key는 parent graph state와 공유됩니다
  2. 이 key는 `SubgraphState`에 private하며 parent graph에 표시되지 않습니다

  ```
  { node1: { foo: 'hi! foo' } }
  { node2: { foo: 'hi! foobar' } }
  ```

</Accordion>

## Add persistence

**Parent graph를 컴파일할 때만 checkpointer를 제공**하면 됩니다. LangGraph는 자동으로 checkpointer를 child subgraph에 전파합니다.



```typescript
import { StateGraph, START, MemorySaver } from "@langchain/langgraph";
import * as z from "zod";

const State = z.object({
  foo: z.string(),
});

// Subgraph
const subgraphBuilder = new StateGraph(State)
  .addNode("subgraphNode1", (state) => {
    return { foo: state.foo + "bar" };
  })
  .addEdge(START, "subgraphNode1");

const subgraph = subgraphBuilder.compile();

// Parent graph
const builder = new StateGraph(State)
  .addNode("node1", subgraph)
  .addEdge(START, "node1");

const checkpointer = new MemorySaver();
const graph = builder.compile({ checkpointer });
```


Subgraph가 **자체 메모리를 가지도록** 하려면 적절한 checkpointer 옵션으로 컴파일할 수 있습니다. 이는 [멀티 에이전트](/oss/javascript/langchain/multi-agent) 시스템에서 에이전트가 내부 메시지 기록을 추적하도록 하려는 경우 유용합니다:



```typescript
const subgraphBuilder = new StateGraph(...)
const subgraph = subgraphBuilder.compile({ checkpointer: true });
```


## View subgraph state

[persistence](/oss/javascript/langgraph/persistence)를 활성화하면 적절한 메서드를 통해 [graph state를 검사](/oss/javascript/langgraph/persistence#checkpoints)(checkpoint)할 수 있습니다. Subgraph state를 보려면 subgraphs 옵션을 사용할 수 있습니다.



`graph.getState(config)`를 통해 graph state를 검사할 수 있습니다. Subgraph state를 보려면 `graph.getState(config, { subgraphs: true })`를 사용할 수 있습니다.


<Warning>
**중단되었을 때만 사용 가능**
Subgraph state는 **subgraph가 중단되었을 때만** 볼 수 있습니다. Graph를 재개하면 subgraph state에 액세스할 수 없습니다.
</Warning>

<Accordion title="중단된 subgraph state 보기">


  ```typescript
  import { StateGraph, START, MemorySaver, interrupt, Command } from "@langchain/langgraph";
  import * as z from "zod";

  const State = z.object({
    foo: z.string(),
  });

  // Subgraph
  const subgraphBuilder = new StateGraph(State)
    .addNode("subgraphNode1", (state) => {
      const value = interrupt("Provide value:");
      return { foo: state.foo + value };
    })
    .addEdge(START, "subgraphNode1");

  const subgraph = subgraphBuilder.compile();

  // Parent graph
  const builder = new StateGraph(State)
    .addNode("node1", subgraph)
    .addEdge(START, "node1");

  const checkpointer = new MemorySaver();
  const graph = builder.compile({ checkpointer });

  const config = { configurable: { thread_id: "1" } };

  await graph.invoke({ foo: "" }, config);
  const parentState = await graph.getState(config);
  const subgraphState = (await graph.getState(config, { subgraphs: true })).tasks[0].state;   // [!code highlight]

  // resume the subgraph
  await graph.invoke(new Command({ resume: "bar" }), config);
  ```

</Accordion>

## Stream subgraph outputs

스트리밍된 출력에 subgraph의 출력을 포함하려면 parent graph의 stream 메서드에서 subgraphs 옵션을 설정할 수 있습니다. 이렇게 하면 parent graph와 모든 subgraph의 출력이 스트리밍됩니다.



```typescript
for await (const chunk of await graph.stream(
  { foo: "foo" },
  {
    subgraphs: true,   // [!code highlight]
    streamMode: "updates",
  }
)) {
  console.log(chunk);
}
```

1. Subgraph의 출력을 스트리밍하려면 `subgraphs: true`를 설정합니다.


<Accordion title="Subgraph에서 스트리밍">


  ```typescript
  import { StateGraph, START } from "@langchain/langgraph";
  import * as z from "zod";

  // Define subgraph
  const SubgraphState = z.object({
    foo: z.string(),
    bar: z.string(),
  });

  const subgraphBuilder = new StateGraph(SubgraphState)
    .addNode("subgraphNode1", (state) => {
      return { bar: "bar" };
    })
    .addNode("subgraphNode2", (state) => {
      // note that this node is using a state key ('bar') that is only available in the subgraph
      // and is sending update on the shared state key ('foo')
      return { foo: state.foo + state.bar };
    })
    .addEdge(START, "subgraphNode1")
    .addEdge("subgraphNode1", "subgraphNode2");

  const subgraph = subgraphBuilder.compile();

  // Define parent graph
  const ParentState = z.object({
    foo: z.string(),
  });

  const builder = new StateGraph(ParentState)
    .addNode("node1", (state) => {
      return { foo: "hi! " + state.foo };
    })
    .addNode("node2", subgraph)
    .addEdge(START, "node1")
    .addEdge("node1", "node2");

  const graph = builder.compile();

  for await (const chunk of await graph.stream(
    { foo: "foo" },
    {
      streamMode: "updates",
      subgraphs: true,   // [!code highlight]
    }
  )) {
    console.log(chunk);
  }
  ```

  1. Subgraph의 출력을 스트리밍하려면 `subgraphs: true`를 설정합니다.

  ```
  [[], { node1: { foo: 'hi! foo' } }]
  [['node2:e58e5673-a661-ebb0-70d4-e298a7fc28b7'], { subgraphNode1: { bar: 'bar' } }]
  [['node2:e58e5673-a661-ebb0-70d4-e298a7fc28b7'], { subgraphNode2: { foo: 'hi! foobar' } }]
  [[], { node2: { foo: 'hi! foobar' } }]
  ```

</Accordion>

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/langgraph/use-subgraphs.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for    real-time answers.
</Tip>
