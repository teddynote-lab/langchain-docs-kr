---
title: Graph RAG
---

이 가이드는 Graph RAG에 대한 소개를 제공합니다. 지원되는 모든 기능과 구성에 대한 자세한 문서는
[Graph RAG 프로젝트 페이지](https://datastax.github.io/graph-rag/)를 참조하세요.

## 개요

`langchain-graph-retriever` 패키지의 `GraphRetriever`는 벡터에 대한 **비구조화된** 유사도 검색과
메타데이터 속성의 **구조화된** 순회를 결합한 LangChain [retriever](/oss/python/langchain/retrieval/)를 제공합니다.
이를 통해 **기존** vector store에서 그래프 기반 검색이 가능합니다.

### Integration 세부 정보

| Retriever | Source | PyPI Package | Latest | Project Page |
| :--- | :--- | :---: | :---: | :---: |
| GraphRetriever | [github.com/datastax/graph-rag](https://github.com/datastax/graph-rag/tree/main/packages/langchain-graph-retriever) | [langchain-graph-retriever](https://pypi.org/project/langchain-graph-retriever/) | ![PyPI - Version](https://img.shields.io/pypi/v/langchain-graph-retriever?style=flat-square&label=%20&color=orange) | [Graph RAG](https://datastax.github.io/graph-rag/) |


## 장점

* [**기존 메타데이터를 기반으로 연결:**](https://datastax.github.io/graph-rag/guide/get-started/)
  추가 처리 없이 기존 메타데이터 필드를 사용합니다. 기존 vector store에서 더 많은 것을 검색하세요!

* [**필요에 따라 링크 변경:**](https://datastax.github.io/graph-rag/guide/edges/)
  Edge는 즉석에서 지정할 수 있어, 질문에 따라 다른 관계를 순회할 수 있습니다.


* [**플러그형 순회 전략:**](https://datastax.github.io/graph-rag/guide/strategies/)
  Eager 또는 MMR과 같은 내장 순회 전략을 사용하거나, 탐색할 노드를 선택하는 사용자 정의 로직을 정의할 수 있습니다.

* [**광범위한 호환성:**](https://datastax.github.io/graph-rag/guide/adapters/)
  다양한 vector store에 대한 adapter가 제공되며, 추가 store에 대한 지원도 쉽게 추가할 수 있습니다.

## 설정

### 설치

이 retriever는 `langchain-graph-retriever` 패키지에 포함되어 있습니다.

<CodeGroup>
```bash pip
pip install -qU langchain-graph-retriever
```

```bash uv
uv add langchain-graph-retriever
```
</CodeGroup>
## 인스턴스화

다음 예제는 동물에 관한 샘플 Document에 대해 그래프 순회를 수행하는 방법을 보여줍니다.

### 사전 요구 사항

<details>
    <summary>세부 정보 토글</summary>
    <div>
    1. Python 3.10+ 이상이 설치되어 있는지 확인하세요

    1. 샘플 데이터를 제공하는 다음 패키지를 설치하세요.
        ```bash
        pip install -qU graph_rag_example_helpers
        ```

    1. 테스트 문서를 다운로드하세요:
        ```python
        from graph_rag_example_helpers.datasets.animals import fetch_documents
        animals = fetch_documents()
        ```

    1. <EmbeddingTabs/>
    </div>
</details>

### Vector store 채우기

이 섹션은 샘플 데이터로 다양한 vector store를 채우는 방법을 보여줍니다.

아래의 vector store 중 하나를 선택하는 데 도움이 필요하거나 사용 중인 vector store에 대한 지원을 추가하려면
[Adapter 및 지원되는 Store](https://datastax.github.io/graph-rag/guide/adapters/)에 대한 문서를 참조하세요.

<Tabs groupId="vector-store" queryString>
    <Tab title="AstraDB">
        <div style={{ paddingLeft: '30px' }}>
      `astra` extra와 함께 `langchain-graph-retriever` 패키지를 설치하세요:

      ```bash
      pip install "langchain-graph-retriever[astra]"
      ```

      그런 다음 vector store를 생성하고 테스트 문서를 로드하세요:

      ```python
      from langchain_astradb import AstraDBVectorStore

      vector_store = AstraDBVectorStore.from_documents(
          documents=animals,
          embedding=embeddings,
          collection_name="animals",
          api_endpoint=ASTRA_DB_API_ENDPOINT,
          token=ASTRA_DB_APPLICATION_TOKEN,
      )
      ```
      `ASTRA_DB_API_ENDPOINT` 및 `ASTRA_DB_APPLICATION_TOKEN` 자격 증명은
      [AstraDB Vector Store 가이드](/oss/python/integrations/vectorstores/astradb)를 참조하세요.

      :::note
      더 빠른 초기 테스트를 위해 **InMemory** Vector Store 사용을 고려하세요.
      :::
        </div>
    </Tab>
    <Tab title="Apache Cassandra">
        <div style={{ paddingLeft: '30px' }}>
      `cassandra` extra와 함께 `langchain-graph-retriever` 패키지를 설치하세요:

      ```bash
      pip install "langchain-graph-retriever[cassandra]"
      ```

      그런 다음 vector store를 생성하고 테스트 문서를 로드하세요:

      ```python
      from langchain_community.vectorstores.cassandra import Cassandra
      from langchain_graph_retriever.transformers import ShreddingTransformer

      vector_store = Cassandra.from_documents(
          documents=list(ShreddingTransformer().transform_documents(animals)),
          embedding=embeddings,
          table_name="animals",
      )
      ```

      Cassandra 연결 생성에 대한 도움말은
      [Apache Cassandra Vector Store 가이드](/oss/python/integrations/vectorstores/cassandra#connection-parameters)를 참조하세요

      :::note
      Apache Cassandra는 중첩된 메타데이터 검색을 지원하지 않습니다. 이 때문에
      문서를 삽입할 때 [`ShreddingTransformer`](https://datastax.github.io/graph-rag/reference/langchain_graph_retriever/transformers/#langchain_graph_retriever.transformers.shredding.ShreddingTransformer)를
      사용해야 합니다.
      :::
        </div>
    </Tab>
    <Tab title="OpenSearch">
        <div style={{ paddingLeft: '30px' }}>
      `opensearch` extra와 함께 `langchain-graph-retriever` 패키지를 설치하세요:

      ```bash
      pip install "langchain-graph-retriever[opensearch]"
      ```

      그런 다음 vector store를 생성하고 테스트 문서를 로드하세요:

      ```python
      from langchain_community.vectorstores import OpenSearchVectorSearch

      vector_store = OpenSearchVectorSearch.from_documents(
          documents=animals,
          embedding=embeddings,
          engine="faiss",
          index_name="animals",
          opensearch_url=OPEN_SEARCH_URL,
          bulk_size=500,
      )
      ```

      OpenSearch 연결 생성에 대한 도움말은
      [OpenSearch Vector Store 가이드](/oss/python/integrations/vectorstores/opensearch)를 참조하세요.
        </div>
    </Tab>
    <Tab title="Chroma">
        <div style={{ paddingLeft: '30px' }}>
      `chroma` extra와 함께 `langchain-graph-retriever` 패키지를 설치하세요:

      ```bash
      pip install "langchain-graph-retriever[chroma]"
      ```

      그런 다음 vector store를 생성하고 테스트 문서를 로드하세요:

      ```python
      from langchain_chroma.vectorstores import Chroma
      from langchain_graph_retriever.transformers import ShreddingTransformer

      vector_store = Chroma.from_documents(
          documents=list(ShreddingTransformer().transform_documents(animals)),
          embedding=embeddings,
          collection_name="animals",
      )
      ```

      Chroma 연결 생성에 대한 도움말은
      [Chroma Vector Store 가이드](/oss/python/integrations/vectorstores/chroma)를 참조하세요.

      :::note
      Chroma는 중첩된 메타데이터 검색을 지원하지 않습니다. 이 때문에
      문서를 삽입할 때 [`ShreddingTransformer`](https://datastax.github.io/graph-rag/reference/langchain_graph_retriever/transformers/#langchain_graph_retriever.transformers.shredding.ShreddingTransformer)를
      사용해야 합니다.
      :::
        </div>
    </Tab>
    <Tab title="InMemory">
        <div style={{ paddingLeft: '30px' }}>
      `langchain-graph-retriever` 패키지를 설치하세요:

      ```bash
      pip install "langchain-graph-retriever"
      ```

      그런 다음 vector store를 생성하고 테스트 문서를 로드하세요:

      ```python
      from langchain_core.vectorstores import InMemoryVectorStore

      vector_store = InMemoryVectorStore.from_documents(
          documents=animals,
          embedding=embeddings,
      )
      ```

      :::tip
      `InMemoryVectorStore`를 사용하는 것이 Graph RAG를 시작하는 가장 빠른 방법이지만
      프로덕션 환경에서는 권장되지 않습니다. 대신 **AstraDB** 또는 **OpenSearch** 사용을 권장합니다.
      :::
        </div>
    </Tab>
</Tabs>

### 그래프 순회

이 graph retriever는 쿼리와 가장 일치하는 단일 동물로 시작한 다음,
동일한 `habitat` 및/또는 `origin`을 공유하는 다른 동물로 순회합니다.

  ```python
  from graph_retriever.strategies import Eager
  from langchain_graph_retriever import GraphRetriever

  traversal_retriever = GraphRetriever(
      store = vector_store,
      edges = [("habitat", "habitat"), ("origin", "origin")],
      strategy = Eager(k=5, start_k=1, max_depth=2),
  )
  ```

위 코드는 가장 가까운 동물(`start_k=1`)로 시작하여 5개의 문서(`k=5`)를 검색하고,
첫 번째 동물로부터 최대 2단계 떨어진 문서로 검색을 제한하는(`max_depth=2`) 그래프 순회 retriever를 생성합니다.

`edges`는 메타데이터 값을 순회에 사용할 수 있는 방법을 정의합니다. 이 경우, 모든
동물은 동일한 `habitat` 및/또는 `origin`을 가진 다른 동물과 연결됩니다.

```python
results = traversal_retriever.invoke("what animals could be found near a capybara?")

for doc in results:
    print(f"{doc.id}: {doc.page_content}")
```
```output
capybara: capybaras are the largest rodents in the world and are highly social animals.
heron: herons are wading birds known for their long legs and necks, often seen near water.
crocodile: crocodiles are large reptiles with powerful jaws and a long lifespan, often living over 70 years.
frog: frogs are amphibians known for their jumping ability and croaking sounds.
duck: ducks are waterfowl birds known for their webbed feet and quacking sounds.
```

그래프 순회는 데이터의 구조화된 관계를 활용하여 검색 품질을 향상시킵니다. 표준 유사도 검색(아래 참조)과 달리,
문서가 선택된 이유에 대한 명확하고 설명 가능한 근거를 제공합니다.

이 경우, 문서 `capybara`, `heron`, `frog`, `crocodile`, `newt`는 모두
메타데이터에 정의된 대로 동일한 `habitat=wetlands`를 공유합니다. 이는 Document 관련성과
LLM의 답변 품질을 향상시킬 것입니다.

### 표준 검색과의 비교

`max_depth=0`일 때, 그래프 순회 retriever는 표준 retriever처럼 동작합니다:

```python
standard_retriever = GraphRetriever(
    store = vector_store,
    edges = [("habitat", "habitat"), ("origin", "origin")],
    strategy = Eager(k=5, start_k=5, max_depth=0),
)
```

이는 가장 가까운 5개의 동물(`start_k=5`)로 시작하여
순회 없이 반환하는(`max_depth=0`) retriever를 생성합니다. 이 경우 edge 정의는
무시됩니다.

이는 본질적으로 다음과 동일합니다:

```python
standard_retriever = vector_store.as_retriever(search_kwargs={"k":5})
```

두 경우 모두 retriever를 호출하면 다음을 반환합니다:

```python
results = standard_retriever.invoke("what animals could be found near a capybara?")

for doc in results:
    print(f"{doc.id}: {doc.page_content}")
```

```output
capybara: capybaras are the largest rodents in the world and are highly social animals.
iguana: iguanas are large herbivorous lizards often found basking in trees and near water.
guinea pig: guinea pigs are small rodents often kept as pets due to their gentle and social nature.
hippopotamus: hippopotamuses are large semi-aquatic mammals known for their massive size and territorial behavior.
boar: boars are wild relatives of pigs, known for their tough hides and tusks.
```

이러한 문서는 유사도만을 기반으로 결합됩니다. store에 존재했던 구조적 데이터는 무시됩니다.
그래프 검색과 비교할 때, 반환된 결과가 쿼리에 답하는 데 도움이 될 가능성이 낮아지기 때문에
Document 관련성이 감소할 수 있습니다.

## 사용법

위의 예제에 따라, `invoke`는 쿼리에 대한 검색을 시작하는 데 사용됩니다.

## API 참조

사용 가능한 모든 매개변수와 고급 구성을 살펴보려면
[Graph RAG API 참조](https://datastax.github.io/graph-rag/reference/)를 참조하세요.

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/python/integrations/retrievers/graph_rag.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for    real-time answers.
</Tip>
