---
title: Fleet AI Context
---

>[Fleet AI Context](https://www.fleet.so/context)는 가장 인기 있고 허용 가능한 상위 1200개 Python 라이브러리와 해당 문서의 고품질 embedding 데이터셋입니다.
>
>`Fleet AI` 팀은 세계에서 가장 중요한 데이터를 embedding하는 것을 목표로 하고 있습니다. 그들은 최신 지식을 활용한 코드 생성을 가능하게 하기 위해 상위 1200개 Python 라이브러리를 embedding하는 것부터 시작했습니다.

이러한 embedding을 사용하여 문서 검색 시스템을 구축하고 궁극적으로 간단한 코드 생성 chain을 만드는 방법을 살펴보겠습니다!

```python
pip install -qU  langchain fleet-context langchain-openai pandas faiss-cpu # faiss-gpu for CUDA supported GPU
```

```python
from operator import itemgetter
from typing import Any, Optional, Type

import pandas as pd
from langchain.retrievers import MultiVectorRetriever
from langchain_community.vectorstores import FAISS
from langchain_core.documents import Document
from langchain_core.stores import BaseStore
from langchain_core.vectorstores import VectorStore
from langchain_openai import OpenAIEmbeddings


def load_fleet_retriever(
    df: pd.DataFrame,
    *,
    vectorstore_cls: Type[VectorStore] = FAISS,
    docstore: Optional[BaseStore] = None,
    **kwargs: Any,
):
    vectorstore = _populate_vectorstore(df, vectorstore_cls)
    if docstore is None:
        return vectorstore.as_retriever(**kwargs)
    else:
        _populate_docstore(df, docstore)
        return MultiVectorRetriever(
            vectorstore=vectorstore, docstore=docstore, id_key="parent", **kwargs
        )


def _populate_vectorstore(
    df: pd.DataFrame,
    vectorstore_cls: Type[VectorStore],
) -> VectorStore:
    if not hasattr(vectorstore_cls, "from_embeddings"):
        raise ValueError(
            f"Incompatible vector store class {vectorstore_cls}."
            "Must implement `from_embeddings` class method."
        )
    texts_embeddings = []
    metadatas = []
    for _, row in df.iterrows():
        texts_embeddings.append((row.metadata["text"], row["dense_embeddings"]))
        metadatas.append(row.metadata)
    return vectorstore_cls.from_embeddings(
        texts_embeddings,
        OpenAIEmbeddings(model="text-embedding-ada-002"),
        metadatas=metadatas,
    )


def _populate_docstore(df: pd.DataFrame, docstore: BaseStore) -> None:
    parent_docs = []
    df = df.copy()
    df["parent"] = df.metadata.apply(itemgetter("parent"))
    for parent_id, group in df.groupby("parent"):
        sorted_group = group.iloc[
            group.metadata.apply(itemgetter("section_index")).argsort()
        ]
        text = "".join(sorted_group.metadata.apply(itemgetter("text")))
        metadata = {
            k: sorted_group.iloc[0].metadata[k] for k in ("title", "type", "url")
        }
        text = metadata["title"] + "\n" + text
        metadata["id"] = parent_id
        parent_docs.append(Document(page_content=text, metadata=metadata))
    docstore.mset(((d.metadata["id"], d) for d in parent_docs))
```

## Retriever chunks

Fleet AI 팀은 embedding 프로세스의 일환으로 긴 문서를 embedding하기 전에 먼저 청크로 나눴습니다. 즉, vector는 전체 페이지가 아닌 LangChain 문서의 페이지 섹션에 해당합니다. 기본적으로 이러한 embedding에서 retriever를 생성하면 이러한 embedding된 청크를 검색하게 됩니다.

Fleet Context의 `download_embeddings()`를 사용하여 LangChain의 문서 embedding을 가져올 것입니다. 지원되는 모든 라이브러리의 문서는 [fleet.so/context](https://fleet.so/context)에서 확인할 수 있습니다.

```python
from context import download_embeddings

df = download_embeddings("langchain")
vecstore_retriever = load_fleet_retriever(df)
```

```python
vecstore_retriever.invoke("How does the multi vector retriever work")
```

## 다른 패키지

[이 Dropbox 링크](https://www.dropbox.com/scl/fo/54t2e7fogtixo58pnlyub/h?rlkey=tne16wkssgf01jor0p1iqg6p9&dl=0)에서 다른 embedding을 다운로드하여 사용할 수 있습니다.

## 상위 문서 검색

Fleet AI에서 제공하는 embedding에는 어떤 embedding 청크가 동일한 원본 문서 페이지에 해당하는지를 나타내는 메타데이터가 포함되어 있습니다. 원한다면 이 정보를 사용하여 embedding된 청크만이 아닌 전체 상위 문서를 검색할 수 있습니다. 내부적으로는 MultiVectorRetriever와 BaseStore 객체를 사용하여 관련 청크를 검색한 다음 해당 상위 문서에 매핑합니다.

```python
from langchain.storage import InMemoryStore

parent_retriever = load_fleet_retriever(
    "https://www.dropbox.com/scl/fi/4rescpkrg9970s3huz47l/libraries_langchain_release.parquet?rlkey=283knw4wamezfwiidgpgptkep&dl=1",
    docstore=InMemoryStore(),
)
```

```python
parent_retriever.invoke("How does the multi vector retriever work")
```

## Chain에 적용하기

간단한 chain에서 검색 시스템을 사용해 보겠습니다!

```python
from langchain_core.output_parsers import StrOutputParser
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnablePassthrough
from langchain_openai import ChatOpenAI

prompt = ChatPromptTemplate.from_messages(
    [
        (
            "system",
            """You are a great software engineer who is very familiar \
with Python. Given a user question or request about a new Python library called LangChain and \
parts of the LangChain documentation, answer the question or generate the requested code. \
Your answers must be accurate, should include code whenever possible, and should assume anything \
about LangChain which is note explicitly stated in the LangChain documentation. If the required \
information is not available, just say so.

LangChain Documentation
------------------

{context}""",
        ),
        ("human", "{question}"),
    ]
)

model = ChatOpenAI(model="gpt-3.5-turbo-16k")

chain = (
    {
        "question": RunnablePassthrough(),
        "context": parent_retriever
        | (lambda docs: "\n\n".join(d.page_content for d in docs)),
    }
    | prompt
    | model
    | StrOutputParser()
)
```

```python
for chunk in chain.invoke(
    "How do I create a FAISS vector store retriever that returns 10 documents per search query"
):
    print(chunk, end="", flush=True)
```

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/python/integrations/retrievers/fleet_context.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for    real-time answers.
</Tip>
