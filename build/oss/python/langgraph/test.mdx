---
title: 테스트
---



LangGraph 에이전트의 프로토타입을 만든 후, 자연스러운 다음 단계는 테스트를 추가하는 것입니다. 이 가이드는 단위 테스트를 작성할 때 사용할 수 있는 유용한 패턴들을 다룹니다.

이 가이드는 LangGraph에 특화되어 있으며 커스텀 구조를 가진 graph와 관련된 시나리오를 다룹니다 - 막 시작하는 경우, LangChain의 내장 [`create_agent`](https://reference.langchain.com/python/langchain/agents/#langchain.agents.create_agent)를 사용하는 [이 섹션](/oss/python/langchain/test/)을 확인하세요.

## 사전 요구사항

먼저, [`pytest`](https://docs.pytest.org/)가 설치되어 있는지 확인하세요:

```bash
$ pip install -U pytest
```




## 시작하기

많은 LangGraph 에이전트가 state에 의존하기 때문에, 유용한 패턴은 사용하려는 각 테스트 전에 graph를 생성한 다음, 테스트 내에서 새로운 checkpointer 인스턴스로 컴파일하는 것입니다.

아래 예제는 `node1`과 `node2`를 거쳐 진행되는 간단한 선형 graph에서 이것이 어떻게 작동하는지 보여줍니다. 각 node는 단일 state key인 `my_key`를 업데이트합니다:

```python
import pytest

from typing_extensions import TypedDict
from langgraph.graph import StateGraph, START, END
from langgraph.checkpoint.memory import MemorySaver

def create_graph() -> StateGraph:
    class MyState(TypedDict):
        my_key: str

    graph = StateGraph(MyState)
    graph.add_node("node1", lambda state: {"my_key": "hello from node1"})
    graph.add_node("node2", lambda state: {"my_key": "hello from node2"})
    graph.add_edge(START, "node1")
    graph.add_edge("node1", "node2")
    graph.add_edge("node2", END)
    return graph

def test_basic_agent_execution() -> None:
    checkpointer = MemorySaver()
    graph = create_graph()
    compiled_graph = graph.compile(checkpointer=checkpointer)
    result = compiled_graph.invoke(
        {"my_key": "initial_value"},
        config={"configurable": {"thread_id": "1"}}
    )
    assert result["my_key"] == "hello from node2"
```




## 개별 node와 edge 테스트하기

컴파일된 LangGraph 에이전트는 각 개별 node에 대한 참조를 `graph.nodes`로 노출합니다. 이를 활용하여 에이전트 내의 개별 node를 테스트할 수 있습니다. 이는 graph를 컴파일할 때 전달된 checkpointer를 우회한다는 점에 유의하세요:

```python
import pytest

from typing_extensions import TypedDict
from langgraph.graph import StateGraph, START, END
from langgraph.checkpoint.memory import MemorySaver

def create_graph() -> StateGraph:
    class MyState(TypedDict):
        my_key: str

    graph = StateGraph(MyState)
    graph.add_node("node1", lambda state: {"my_key": "hello from node1"})
    graph.add_node("node2", lambda state: {"my_key": "hello from node2"})
    graph.add_edge(START, "node1")
    graph.add_edge("node1", "node2")
    graph.add_edge("node2", END)
    return graph

def test_individual_node_execution() -> None:
    # Will be ignored in this example
    checkpointer = MemorySaver()
    graph = create_graph()
    compiled_graph = graph.compile(checkpointer=checkpointer)
    # Only invoke node 1
    result = compiled_graph.nodes["node1"].invoke(
        {"my_key": "initial_value"},
    )
    assert result["my_key"] == "hello from node1"
```




## 부분 실행

더 큰 graph로 구성된 에이전트의 경우, 전체 플로우를 end-to-end로 테스트하는 대신 에이전트 내의 부분 실행 경로를 테스트하고 싶을 수 있습니다. 경우에 따라 [이러한 섹션을 subgraph로 재구성](/oss/python/langgraph/use-subgraphs)하는 것이 의미상 타당할 수 있으며, 이를 일반적으로 독립적으로 호출할 수 있습니다.

그러나 에이전트 graph의 전체 구조를 변경하고 싶지 않다면, LangGraph의 persistence 메커니즘을 사용하여 원하는 섹션의 시작 직전에 에이전트가 일시 중지되고, 원하는 섹션의 끝에서 다시 일시 중지되는 상태를 시뮬레이션할 수 있습니다. 단계는 다음과 같습니다:

1. checkpointer와 함께 에이전트를 컴파일합니다 (테스트를 위해서는 in-memory checkpointer [`InMemorySaver`](https://reference.langchain.com/python/langgraph/checkpoints/#langgraph.checkpoint.memory.InMemorySaver)로 충분합니다).
2. 테스트를 시작하려는 node *이전*의 node 이름으로 설정된 [`as_node`](/oss/python/langgraph/persistence#as-node) 매개변수와 함께 에이전트의 [`update_state`](/oss/python/langgraph/use-time-travel) 메서드를 호출합니다.
3. state를 업데이트하는 데 사용한 것과 동일한 `thread_id`와 중지하려는 node의 이름으로 설정된 `interrupt_after` 매개변수로 에이전트를 호출합니다.



다음은 선형 graph에서 두 번째와 세 번째 node만 실행하는 예제입니다:

```python
import pytest

from typing_extensions import TypedDict
from langgraph.graph import StateGraph, START, END
from langgraph.checkpoint.memory import MemorySaver

def create_graph() -> StateGraph:
    class MyState(TypedDict):
        my_key: str

    graph = StateGraph(MyState)
    graph.add_node("node1", lambda state: {"my_key": "hello from node1"})
    graph.add_node("node2", lambda state: {"my_key": "hello from node2"})
    graph.add_node("node3", lambda state: {"my_key": "hello from node3"})
    graph.add_node("node4", lambda state: {"my_key": "hello from node4"})
    graph.add_edge(START, "node1")
    graph.add_edge("node1", "node2")
    graph.add_edge("node2", "node3")
    graph.add_edge("node3", "node4")
    graph.add_edge("node4", END)
    return graph

def test_partial_execution_from_node2_to_node3() -> None:
    checkpointer = MemorySaver()
    graph = create_graph()
    compiled_graph = graph.compile(checkpointer=checkpointer)
    compiled_graph.update_state(
        config={
          "configurable": {
            "thread_id": "1"
          }
        },
        # The state passed into node 2 - simulating the state at
        # the end of node 1
        values={"my_key": "initial_value"},
        # Update saved state as if it came from node 1
        # Execution will resume at node 2
        as_node="node1",
    )
    result = compiled_graph.invoke(
        # Resume execution by passing None
        None,
        config={"configurable": {"thread_id": "1"}},
        # Stop after node 3 so that node 4 doesn't run
        interrupt_after="node3",
    )
    assert result["my_key"] == "hello from node3"
```

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/oss/langgraph/test.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for    real-time answers.
</Tip>
