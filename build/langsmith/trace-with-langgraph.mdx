---
title: LangGraph로 추적하기
sidebarTitle: LangGraph
---

LangSmith는 LangGraph(Python 및 JS)와 원활하게 통합되어 LangChain 모듈이나 다른 SDK를 사용하는지 여부와 관계없이 에이전트를 추적할 수 있도록 도와줍니다.

## LangChain과 함께 사용

LangGraph 내에서 LangChain 모듈을 사용하는 경우, 추적을 활성화하기 위해 몇 가지 환경 변수만 설정하면 됩니다.

이 가이드는 기본 예제를 안내합니다. 구성에 대한 자세한 내용은 [LangChain으로 추적하기](/langsmith/trace-with-langchain) 가이드를 참조하세요.

### 1. 설치

Python 및 JS용 LangGraph 라이브러리와 OpenAI 통합을 설치합니다(아래 코드 스니펫에서는 OpenAI 통합을 사용합니다).

사용 가능한 패키지의 전체 목록은 [LangChain Python 문서](https://python.langchain.com/docs/integrations/platforms/) 및 [LangChain JS 문서](https://js.langchain.com/docs/integrations/platforms/)를 참조하세요.

<CodeGroup>

```bash pip
pip install langchain_openai langgraph
```

```bash yarn
yarn add @langchain/openai @langchain/langgraph
```

```bash npm
npm install @langchain/openai @langchain/langgraph
```

```bash pnpm
pnpm add @langchain/openai @langchain/langgraph
```

</CodeGroup>

### 2. 환경 구성

<CodeGroup>

```bash Python
export LANGSMITH_TRACING=true
export LANGSMITH_API_KEY=<your-api-key>
# This example uses OpenAI, but you can use any LLM provider of choice
export OPENAI_API_KEY=<your-openai-api-key>
# For LangSmith API keys linked to multiple workspaces, set the LANGSMITH_WORKSPACE_ID environment variable to specify which workspace to use.
export LANGSMITH_WORKSPACE_ID=<your-workspace-id>
```

```bash TypeScript
export LANGSMITH_TRACING=true
export LANGSMITH_API_KEY=<your-api-key>
# This example uses OpenAI, but you can use any LLM provider of choice
export OPENAI_API_KEY=<your-openai-api-key>
# For LangSmith API keys linked to multiple workspaces, set the LANGSMITH_WORKSPACE_ID environment variable to specify which workspace to use.
export LANGSMITH_WORKSPACE_ID=<your-workspace-id>
```

</CodeGroup>

<Info>
LangSmith와 함께 LangChain.js를 사용하고 서버리스 환경이 아닌 경우, 지연 시간을 줄이기 위해 다음을 명시적으로 설정하는 것이 좋습니다:

`export LANGCHAIN_CALLBACKS_BACKGROUND=true`

서버리스 환경에서는 함수가 종료되기 전에 추적이 완료될 수 있도록 반대로 설정하는 것이 좋습니다:

`export LANGCHAIN_CALLBACKS_BACKGROUND=false`

자세한 내용은 [이 LangChain.js 가이드](https://js.langchain.com/docs/how_to/callbacks_serverless)를 참조하세요.
</Info>

### 3. trace 로깅

환경을 설정한 후에는 평소처럼 LangChain runnable을 호출할 수 있습니다. LangSmith가 적절한 추적 구성을 자동으로 추론합니다:

<CodeGroup>

```python Python
from typing import Literal
from langchain.messages import HumanMessage
from langchain_openai import ChatOpenAI
from langchain.tools import tool
from langgraph.prebuilt import ToolNode
from langgraph.graph import StateGraph, MessagesState

@tool
def search(query: str):
    """Call to surf the web."""
    if "sf" in query.lower() or "san francisco" in query.lower():
        return "It's 60 degrees and foggy."
    return "It's 90 degrees and sunny."

tools = [search]
tool_node = ToolNode(tools)

model = ChatOpenAI(model="gpt-4o", temperature=0).bind_tools(tools)

def should_continue(state: MessagesState) -> Literal["tools", "__end__"]:
    messages = state['messages']
    last_message = messages[-1]
    if last_message.tool_calls:
        return "tools"
    return "__end__"

def call_model(state: MessagesState):
    messages = state['messages']
    # Invoking `model` will automatically infer the correct tracing context
    response = model.invoke(messages)
    return {"messages": [response]}

workflow = StateGraph(MessagesState)
workflow.add_node("agent", call_model)
workflow.add_node("tools", tool_node)
workflow.add_edge("__start__", "agent")
workflow.add_conditional_edges(
    "agent",
    should_continue,
)
workflow.add_edge("tools", 'agent')

app = workflow.compile()

final_state = app.invoke(
    {"messages": [HumanMessage(content="what is the weather in sf")]},
    config={"configurable": {"thread_id": 42}}
)

final_state["messages"][-1].content
```

```typescript TypeScript
import { HumanMessage, AIMessage } from "@langchain/core/messages";
import { tool } from "@langchain/core/tools";
import { z } from "zod";
import { ChatOpenAI } from "@langchain/openai";
import { StateGraph, StateGraphArgs } from "@langchain/langgraph";
import { ToolNode } from "@langchain/langgraph/prebuilt";

interface AgentState {
  messages: HumanMessage[];
}

const graphState: StateGraphArgs<AgentState>["channels"] = {
  messages: {
    reducer: (x: HumanMessage[], y: HumanMessage[]) => x.concat(y),
  },
};

const searchTool = tool(async ({ query }: { query: string }) => {
  if (query.toLowerCase().includes("sf") || query.toLowerCase().includes("san francisco")) {
    return "It's 60 degrees and foggy."
  }
  return "It's 90 degrees and sunny."
}, {
  name: "search",
  description:
    "Call to surf the web.",
  schema: z.object({
    query: z.string().describe("The query to use in your search."),
  }),
});

const tools = [searchTool];
const toolNode = new ToolNode<AgentState>(tools);

const model = new ChatOpenAI({
  model: "gpt-4o",
  temperature: 0,
}).bindTools(tools);

function shouldContinue(state: AgentState) {
  const messages = state.messages;
  const lastMessage = messages[messages.length - 1] as AIMessage;
  if (lastMessage.tool_calls?.length) {
    return "tools";
  }
  return "__end__";
}

async function callModel(state: AgentState) {
  const messages = state.messages;
  // Invoking `model` will automatically infer the correct tracing context
  const response = await model.invoke(messages);
  return { messages: [response] };
}

const workflow = new StateGraph<AgentState>({ channels: graphState })
  .addNode("agent", callModel)
  .addNode("tools", toolNode)
  .addEdge("__start__", "agent")
  .addConditionalEdges("agent", shouldContinue)
  .addEdge("tools", "agent");

const app = workflow.compile();

const finalState = await app.invoke(
  { messages: [new HumanMessage("what is the weather in sf")] },
  { configurable: { thread_id: "42" } }
);

finalState.messages[finalState.messages.length - 1].content;
```

</CodeGroup>

위 코드를 실행한 trace 예제는 [다음과 같습니다](https://smith.langchain.com/public/10863294-ee79-484a-927f-0558230f1547/r):

![LangChain을 사용한 LangGraph 실행의 Trace 트리](/langsmith/images/langgraph-with-langchain-trace.png)

## LangChain 없이 사용

LangGraph 내에서 다른 SDK나 커스텀 함수를 사용하는 경우, [적절하게 래핑하거나 데코레이팅](/langsmith/annotate-code#use-traceable--traceable)해야 합니다(Python에서는 `@traceable` 데코레이터, JS에서는 `traceable` 함수 사용, 또는 SDK의 경우 `wrap_openai`와 같은 것 사용). 그렇게 하면 LangSmith가 래핑된 메서드의 trace를 자동으로 중첩합니다.

다음은 예제입니다. 자세한 내용은 이 페이지를 참조하세요.

### 1. 설치

Python 및 JS용 LangGraph 라이브러리와 OpenAI SDK를 설치합니다(아래 코드 스니펫에서는 OpenAI 통합을 사용합니다).

<CodeGroup>

```bash pip
pip install openai langsmith langgraph
```

```bash yarn
yarn add openai langsmith @langchain/langgraph
```

```bash npm
npm install openai langsmith @langchain/langgraph
```

```bash pnpm
pnpm add openai langsmith @langchain/langgraph
```

</CodeGroup>

### 2. 환경 구성

<CodeGroup>

```bash Python
export LANGSMITH_TRACING=true
export LANGSMITH_API_KEY=<your-api-key>
# This example uses OpenAI, but you can use any LLM provider of choice
export OPENAI_API_KEY=<your-openai-api-key>
```

```bash TypeScript
export LANGSMITH_TRACING=true
export LANGSMITH_API_KEY=<your-api-key>
# This example uses OpenAI, but you can use any LLM provider of choice
export OPENAI_API_KEY=<your-openai-api-key>
```

</CodeGroup>

<Info>
LangSmith와 함께 LangChain.js를 사용하고 서버리스 환경이 아닌 경우, 지연 시간을 줄이기 위해 다음을 명시적으로 설정하는 것이 좋습니다:

`export LANGCHAIN_CALLBACKS_BACKGROUND=true`

서버리스 환경에서는 함수가 종료되기 전에 추적이 완료될 수 있도록 반대로 설정하는 것이 좋습니다:

`export LANGCHAIN_CALLBACKS_BACKGROUND=false`

자세한 내용은 [이 LangChain.js 가이드](https://js.langchain.com/docs/how_to/callbacks_serverless)를 참조하세요.
</Info>

### 3. trace 로깅

환경을 설정한 후, 추적하려는 [커스텀 함수/SDK를 래핑하거나 데코레이팅](/langsmith/annotate-code#use-traceable--traceable)합니다. 그러면 LangSmith가 적절한 추적 구성을 자동으로 추론합니다:

<CodeGroup>

```python Python
import json
import openai
import operator
from langsmith import traceable
from langsmith.wrappers import wrap_openai
from typing import Annotated, Literal, TypedDict
from langgraph.graph import StateGraph

class State(TypedDict):
    messages: Annotated[list, operator.add]

tool_schema = {
    "type": "function",
    "function": {
        "name": "search",
        "description": "Call to surf the web.",
        "parameters": {
            "type": "object",
            "properties": {"query": {"type": "string"}},
            "required": ["query"],
        },
    },
}

# Decorating the tool function will automatically trace it with the correct context
@traceable(run_type="tool", name="Search Tool")
def search(query: str):
    """Call to surf the web."""
    if "sf" in query.lower() or "san francisco" in query.lower():
        return "It's 60 degrees and foggy."
    return "It's 90 degrees and sunny."

tools = [search]

def call_tools(state):
    function_name_to_function = {"search": search}
    messages = state["messages"]
    tool_call = messages[-1]["tool_calls"][0]
    function_name = tool_call["function"]["name"]
    function_arguments = tool_call["function"]["arguments"]
    arguments = json.loads(function_arguments)
    function_response = function_name_to_function[function_name](**arguments)
    tool_message = {
        "tool_call_id": tool_call["id"],
        "role": "tool",
        "name": function_name,
        "content": function_response,
    }
    return {"messages": [tool_message]}

wrapped_client = wrap_openai(openai.Client())

def should_continue(state: State) -> Literal["tools", "__end__"]:
    messages = state["messages"]
    last_message = messages[-1]
    if last_message["tool_calls"]:
        return "tools"
    return "__end__"

def call_model(state: State):
    messages = state["messages"]
    # Calling the wrapped client will automatically infer the correct tracing context
    response = wrapped_client.chat.completions.create(
        messages=messages, model="gpt-4o-mini", tools=[tool_schema]
    )
    raw_tool_calls = response.choices[0].message.tool_calls
    tool_calls = [tool_call.to_dict() for tool_call in raw_tool_calls] if raw_tool_calls else []
    response_message = {
        "role": "assistant",
        "content": response.choices[0].message.content,
        "tool_calls": tool_calls,
    }
    return {"messages": [response_message]}

workflow = StateGraph(State)
workflow.add_node("agent", call_model)
workflow.add_node("tools", call_tools)
workflow.add_edge("__start__", "agent")
workflow.add_conditional_edges(
    "agent",
    should_continue,
)
workflow.add_edge("tools", 'agent')

app = workflow.compile()

final_state = app.invoke(
    {"messages": [{"role": "user", "content": "what is the weather in sf"}]}
)

final_state["messages"][-1]["content"]
```

```typescript TypeScript
**Note:** The below example requires `langsmith>=0.1.39` and `@langchain/langgraph>=0.0.31`

import OpenAI from "openai";
import { StateGraph } from "@langchain/langgraph";
import { wrapOpenAI } from "langsmith/wrappers/openai";
import { traceable } from "langsmith/traceable";

type GraphState = {
  messages: OpenAI.ChatCompletionMessageParam[];
};

const wrappedClient = wrapOpenAI(new OpenAI({}));

const toolSchema: OpenAI.ChatCompletionTool = {
  type: "function",
  function: {
    name: "search",
    description: "Use this tool to query the web.",
    parameters: {
      type: "object",
      properties: {
        query: {
          type: "string",
        },
      },
      required: ["query"],
    }
  }
};

// Wrapping the tool function will automatically trace it with the correct context
const search = traceable(async ({ query }: { query: string }) => {
  if (
    query.toLowerCase().includes("sf") ||
    query.toLowerCase().includes("san francisco")
  ) {
    return "It's 60 degrees and foggy.";
  }
  return "It's 90 degrees and sunny.";
}, { run_type: "tool", name: "Search Tool" });

const callTools = async ({ messages }: GraphState) => {
  const mostRecentMessage = messages[messages.length - 1];
  const toolCalls = (mostRecentMessage as OpenAI.ChatCompletionAssistantMessageParam).tool_calls;
  if (toolCalls === undefined || toolCalls.length === 0) {
    throw new Error("No tool calls passed to node.");
  }
  const toolNameMap = {
    search,
  };
  const functionName = toolCalls[0].function.name;
  const functionArguments = JSON.parse(toolCalls[0].function.arguments);
  const response = await toolNameMap[functionName](functionArguments);
  const toolMessage = {
    tool_call_id: toolCalls[0].id,
    role: "tool",
    name: functionName,
    content: response,
  }
  return { messages: [toolMessage] };
};

const callModel = async ({ messages }: GraphState) => {
  // Calling the wrapped client will automatically infer the correct tracing context
  const response = await wrappedClient.chat.completions.create({
    messages,
    model: "gpt-4o-mini",
    tools: [toolSchema],
  });
  const responseMessage = {
    role: "assistant",
    content: response.choices[0].message.content,
    tool_calls: response.choices[0].message.tool_calls ?? [],
  };
  return { messages: [responseMessage] };
};

const shouldContinue = ({ messages }: GraphState) => {
  const lastMessage =
    messages[messages.length - 1] as OpenAI.ChatCompletionAssistantMessageParam;
  if (
    lastMessage?.tool_calls !== undefined &&
    lastMessage?.tool_calls.length > 0
  ) {
    return "tools";
  }
  return "__end__";
}

const workflow = new StateGraph<GraphState>({
  channels: {
    messages: {
      reducer: (a: any, b: any) => a.concat(b),
    }
  }
});

const graph = workflow
  .addNode("model", callModel)
  .addNode("tools", callTools)
  .addEdge("__start__", "model")
  .addConditionalEdges("model", shouldContinue, {
    tools: "tools",
    __end__: "__end__",
  })
  .addEdge("tools", "model")
  .compile();

await graph.invoke({
  messages: [{ role: "user", content: "what is the weather in sf" }]
});
```

</CodeGroup>

위 코드를 실행한 trace 예제는 [다음과 같습니다](https://smith.langchain.com/public/353f27da-c221-4b67-b9ec-ede3777f3271/r):

![LangChain 없이 LangGraph 실행의 Trace 트리](/langsmith/images/langgraph-without-langchain-trace.png)

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/langsmith/trace-with-langgraph.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for    real-time answers.
</Tip>
