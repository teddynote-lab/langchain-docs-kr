---
title: Server API를 사용한 Human-in-the-loop
sidebarTitle: Server API를 사용한 Human-in-the-loop
---

에이전트나 워크플로우에서 tool 호출을 검토, 편집 및 승인하려면 LangGraph의 [human-in-the-loop](/oss/python/langgraph/interrupts) 기능을 사용하세요.

## Dynamic interrupts

<Tabs>
    <Tab title="Python">
    ```python {highlight={2,34}}
    from langgraph_sdk import get_client
    from langgraph_sdk.schema import Command
    client = get_client(url=<DEPLOYMENT_URL>)

    # Using the graph deployed with the name "agent"
    assistant_id = "agent"

    # create a thread
    thread = await client.threads.create()
    thread_id = thread["thread_id"]

    # Run the graph until the interrupt is hit.
    result = await client.runs.wait(
        thread_id,
        assistant_id,
        input={"some_text": "original text"}   # (1)!
    )

    print(result['__interrupt__']) # (2)!
    # > [
    # >     {
    # >         'value': {'text_to_revise': 'original text'},
    # >         'resumable': True,
    # >         'ns': ['human_node:fc722478-2f21-0578-c572-d9fc4dd07c3b'],
    # >         'when': 'during'
    # >     }
    # > ]


    # Resume the graph
    print(await client.runs.wait(
        thread_id,
        assistant_id,
        command=Command(resume="Edited text")   # (3)!
    ))
    # > {'some_text': 'Edited text'}
```

    1. 그래프가 초기 state로 호출됩니다.
    2. 그래프가 interrupt에 도달하면 payload와 metadata가 포함된 interrupt 객체를 반환합니다.
        3. 그래프는 `Command(resume=...)`로 재개되며, 사람의 입력을 주입하고 실행을 계속합니다.
    </Tab>
    <Tab title="JavaScript">
    ```javascript {highlight={32}}
    import { Client } from "@langchain/langgraph-sdk";
    const client = new Client({ apiUrl: <DEPLOYMENT_URL> });

    // Using the graph deployed with the name "agent"
    const assistantID = "agent";

    // create a thread
    const thread = await client.threads.create();
    const threadID = thread["thread_id"];

    // Run the graph until the interrupt is hit.
    const result = await client.runs.wait(
      threadID,
      assistantID,
      { input: { "some_text": "original text" } }   # (1)!
    );

    console.log(result['__interrupt__']); # (2)!
    // > [
    # >     {
    # >         'value': {'text_to_revise': 'original text'},
    # >         'resumable': True,
    # >         'ns': ['human_node:fc722478-2f21-0578-c572-d9fc4dd07c3b'],
    # >         'when': 'during'
    # >     }
    # > ]

    // Resume the graph
    console.log(await client.runs.wait(
        threadID,
        assistantID,
        { command: { resume: "Edited text" }}   # (3)!
    ));
    # > {'some_text': 'Edited text'}
```

    1. 그래프가 초기 state로 호출됩니다.
    2. 그래프가 interrupt에 도달하면 payload와 metadata가 포함된 interrupt 객체를 반환합니다.
    3. 그래프는 `{ resume: ... }` command 객체로 재개되며, 사람의 입력을 주입하고 실행을 계속합니다.
    </Tab>
    <Tab title="cURL">
    thread를 생성합니다:

    ```bash
    curl --request POST \
    --url <DEPLOYMENT_URL>/threads \
    --header 'Content-Type: application/json' \
    --data '{}'
    ```

    interrupt가 발생할 때까지 그래프를 실행합니다:

    ```bash
    curl --request POST \
    --url <DEPLOYMENT_URL>/threads/<THREAD_ID>/runs/wait \
    --header 'Content-Type: application/json' \
    --data "{
      \"assistant_id\": \"agent\",
      \"input\": {\"some_text\": \"original text\"}
    }"
    ```

    그래프를 재개합니다:

    ```bash
    curl --request POST \
     --url <DEPLOYMENT_URL>/threads/<THREAD_ID>/runs/wait \
     --header 'Content-Type: application/json' \
     --data "{
       \"assistant_id\": \"agent\",
       \"command\": {
         \"resume\": \"Edited text\"
       }
     }"
    ```
    </Tab>
</Tabs>

<Accordion title="확장 예제: `interrupt` 사용하기">
  이것은 LangGraph API server에서 실행할 수 있는 예제 그래프입니다.
  자세한 내용은 [LangSmith quickstart](/langsmith/deployment-quickstart)를 참조하세요.

  ```python {highlight={7,13}}
  from typing import TypedDict
  import uuid

  from langgraph.checkpoint.memory import InMemorySaver
  from langgraph.constants import START
  from langgraph.graph import StateGraph
  from langgraph.types import interrupt, Command

  class State(TypedDict):
      some_text: str

  def human_node(state: State):
      value = interrupt( # (1)!
          {
              "text_to_revise": state["some_text"] # (2)!
          }
      )
      return {
          "some_text": value # (3)!
      }


  # Build the graph
  graph_builder = StateGraph(State)
  graph_builder.add_node("human_node", human_node)
  graph_builder.add_edge(START, "human_node")

  graph = graph_builder.compile()
```

  1. `interrupt(...)`는 `human_node`에서 실행을 일시 중지하고, 주어진 payload를 사람에게 표시합니다.
  2. JSON 직렬화 가능한 모든 값을 [`interrupt`](https://reference.langchain.com/python/langgraph/types/#langgraph.types.interrupt) function에 전달할 수 있습니다. 여기서는 수정할 텍스트가 포함된 dict를 전달합니다.
  3. 재개되면 `interrupt(...)`의 반환 값은 사람이 제공한 입력이며, 이는 state를 업데이트하는 데 사용됩니다.

  실행 중인 LangGraph API server가 있으면 [LangGraph SDK](/langsmith/langgraph-python-sdk)를 사용하여 상호 작용할 수 있습니다.

    <Tabs>
        <Tab title="Python">
      ```python {highlight={2,34}}
      from langgraph_sdk import get_client
      from langgraph_sdk.schema import Command
      client = get_client(url=<DEPLOYMENT_URL>)

      # Using the graph deployed with the name "agent"
      assistant_id = "agent"

      # create a thread
      thread = await client.threads.create()
      thread_id = thread["thread_id"]

      # Run the graph until the interrupt is hit.
      result = await client.runs.wait(
          thread_id,
          assistant_id,
          input={"some_text": "original text"}   # (1)!
      )

      print(result['__interrupt__']) # (2)!
      # > [
      # >     {
      # >         'value': {'text_to_revise': 'original text'},
      # >         'resumable': True,
      # >         'ns': ['human_node:fc722478-2f21-0578-c572-d9fc4dd07c3b'],
      # >         'when': 'during'
      # >     }
      # > ]


      # Resume the graph
      print(await client.runs.wait(
          thread_id,
          assistant_id,
          command=Command(resume="Edited text")   # (3)!
      ))
      # > {'some_text': 'Edited text'}
```

      1. 그래프가 초기 state로 호출됩니다.
      2. 그래프가 interrupt에 도달하면 payload와 metadata가 포함된 interrupt 객체를 반환합니다.
            3. 그래프는 `Command(resume=...)`로 재개되며, 사람의 입력을 주입하고 실행을 계속합니다.
        </Tab>
        <Tab title="JavaScript">
      ```javascript {highlight={32}}
      import { Client } from "@langchain/langgraph-sdk";
      const client = new Client({ apiUrl: <DEPLOYMENT_URL> });

      // Using the graph deployed with the name "agent"
      const assistantID = "agent";

      // create a thread
      const thread = await client.threads.create();
      const threadID = thread["thread_id"];

      // Run the graph until the interrupt is hit.
      const result = await client.runs.wait(
        threadID,
        assistantID,
        { input: { "some_text": "original text" } }   # (1)!
      );

      console.log(result['__interrupt__']); # (2)!
      # > [
      # >     {
      # >         'value': {'text_to_revise': 'original text'},
      # >         'resumable': True,
      # >         'ns': ['human_node:fc722478-2f21-0578-c572-d9fc4dd07c3b'],
      # >         'when': 'during'
      # >     }
      # > ]

      // Resume the graph
      console.log(await client.runs.wait(
          threadID,
          assistantID,
          { command: { resume: "Edited text" }}   # (3)!
      ));
      # > {'some_text': 'Edited text'}
```

      1. 그래프가 초기 state로 호출됩니다.
      2. 그래프가 interrupt에 도달하면 payload와 metadata가 포함된 interrupt 객체를 반환합니다.
      3. 그래프는 `{ resume: ... }` command 객체로 재개되며, 사람의 입력을 주입하고 실행을 계속합니다.
        </Tab>
        <Tab title="cURL">
      thread를 생성합니다:

      ```bash
      curl --request POST \
      --url <DEPLOYMENT_URL>/threads \
      --header 'Content-Type: application/json' \
      --data '{}'
      ```

      interrupt가 발생할 때까지 그래프를 실행합니다:

      ```bash
      curl --request POST \
      --url <DEPLOYMENT_URL>/threads/<THREAD_ID>/runs/wait \
      --header 'Content-Type: application/json' \
      --data "{
        \"assistant_id\": \"agent\",
        \"input\": {\"some_text\": \"original text\"}
      }"
      ```

      그래프를 재개합니다:

      ```bash
      curl --request POST \
      --url <DEPLOYMENT_URL>/threads/<THREAD_ID>/runs/wait \
      --header 'Content-Type: application/json' \
      --data "{
        \"assistant_id\": \"agent\",
        \"command\": {
          \"resume\": \"Edited text\"
        }
      }"
      ```
        </Tab>
    </Tabs>
</Accordion>

## Static interrupts

Static interrupts(정적 중단점이라고도 함)는 노드가 실행되기 전이나 후에 트리거됩니다.

<Warning>
Static interrupts는 human-in-the-loop 워크플로우에 **권장되지 않습니다**. 디버깅 및 테스트에 가장 적합합니다.
</Warning>

컴파일 시 `interrupt_before`와 `interrupt_after`를 지정하여 static interrupts를 설정할 수 있습니다:

```python {highlight={1,2,3}}
graph = graph_builder.compile( # (1)!
    interrupt_before=["node_a"], # (2)!
    interrupt_after=["node_b", "node_c"], # (3)!
)
```

1. breakpoint는 `compile` 시점에 설정됩니다.
2. `interrupt_before`는 노드가 실행되기 전에 실행을 일시 중지해야 하는 노드를 지정합니다.
3. `interrupt_after`는 노드가 실행된 후에 실행을 일시 중지해야 하는 노드를 지정합니다.

또는 런타임에 static interrupts를 설정할 수 있습니다:

<Tabs>
    <Tab title="Python">
    ```python {highlight={1,5,6}}
    await client.runs.wait( # (1)!
        thread_id,
        assistant_id,
        inputs=inputs,
        interrupt_before=["node_a"], # (2)!
        interrupt_after=["node_b", "node_c"] # (3)!
    )
```

    1. `client.runs.wait`이 `interrupt_before` 및 `interrupt_after` 매개변수와 함께 호출됩니다. 이것은 런타임 구성이며 모든 호출마다 변경할 수 있습니다.
    2. `interrupt_before`는 노드가 실행되기 전에 실행을 일시 중지해야 하는 노드를 지정합니다.
    3. `interrupt_after`는 노드가 실행된 후에 실행을 일시 중지해야 하는 노드를 지정합니다.
    </Tab>
    <Tab title="JavaScript">
    ```javascript {highlight={1,6,7}}
    await client.runs.wait( // (1)!
        threadID,
        assistantID,
        {
        input: input,
        interruptBefore: ["node_a"], // (2)!
        interruptAfter: ["node_b", "node_c"] // (3)!
        }
    )
```

    1. `client.runs.wait`이 `interruptBefore` 및 `interruptAfter` 매개변수와 함께 호출됩니다. 이것은 런타임 구성이며 모든 호출마다 변경할 수 있습니다.
    2. `interruptBefore`는 노드가 실행되기 전에 실행을 일시 중지해야 하는 노드를 지정합니다.
    3. `interruptAfter`는 노드가 실행된 후에 실행을 일시 중지해야 하는 노드를 지정합니다.
    </Tab>
    <Tab title="cURL">
    ```bash
    curl --request POST \
    --url <DEPLOYMENT_URL>/threads/<THREAD_ID>/runs/wait \
    --header 'Content-Type: application/json' \
    --data "{
        \"assistant_id\": \"agent\",
        \"interrupt_before\": [\"node_a\"],
        \"interrupt_after\": [\"node_b\", \"node_c\"],
        \"input\": <INPUT>
    }"
    ```
    </Tab>
</Tabs>

다음 예제는 static interrupts를 추가하는 방법을 보여줍니다:

<Tabs>
    <Tab title="Python">
    ```python
    from langgraph_sdk import get_client
    client = get_client(url=<DEPLOYMENT_URL>)

    # Using the graph deployed with the name "agent"
    assistant_id = "agent"

    # create a thread
    thread = await client.threads.create()
    thread_id = thread["thread_id"]

    # Run the graph until the breakpoint
    result = await client.runs.wait(
        thread_id,
        assistant_id,
        input=inputs   # (1)!
    )

    # Resume the graph
    await client.runs.wait(
        thread_id,
        assistant_id,
        input=None   # (2)!
    )
    ```

    1. 그래프는 첫 번째 breakpoint에 도달할 때까지 실행됩니다.
    2. 그래프는 입력에 `None`을 전달하여 재개됩니다. 이렇게 하면 다음 breakpoint에 도달할 때까지 그래프가 실행됩니다.
    </Tab>
    <Tab title="JavaScript">
    ```js
    import { Client } from "@langchain/langgraph-sdk";
    const client = new Client({ apiUrl: <DEPLOYMENT_URL> });

    // Using the graph deployed with the name "agent"
    const assistantID = "agent";

    // create a thread
    const thread = await client.threads.create();
    const threadID = thread["thread_id"];

    // Run the graph until the breakpoint
    const result = await client.runs.wait(
      threadID,
      assistantID,
      { input: input }   # (1)!
    );

    // Resume the graph
    await client.runs.wait(
      threadID,
      assistantID,
      { input: null }   # (2)!
    );
    ```

    1. 그래프는 첫 번째 breakpoint에 도달할 때까지 실행됩니다.
    2. 그래프는 입력에 `null`을 전달하여 재개됩니다. 이렇게 하면 다음 breakpoint에 도달할 때까지 그래프가 실행됩니다.
    </Tab>
    <Tab title="cURL">
    thread를 생성합니다:

    ```bash
    curl --request POST \
    --url <DEPLOYMENT_URL>/threads \
    --header 'Content-Type: application/json' \
    --data '{}'
    ```

    breakpoint까지 그래프를 실행합니다:

    ```bash
    curl --request POST \
    --url <DEPLOYMENT_URL>/threads/<THREAD_ID>/runs/wait \
    --header 'Content-Type: application/json' \
    --data "{
      \"assistant_id\": \"agent\",
      \"input\": <INPUT>
    }"
    ```

    그래프를 재개합니다:

    ```bash
    curl --request POST \
    --url <DEPLOYMENT_URL>/threads/<THREAD_ID>/runs/wait \
    --header 'Content-Type: application/json' \
    --data "{
      \"assistant_id\": \"agent\"
    }"
    ```
    </Tab>
</Tabs>

## 더 알아보기

* [Human-in-the-loop 개념 가이드](/oss/python/langgraph/interrupts): LangGraph human-in-the-loop 기능에 대해 자세히 알아보세요.
* [일반적인 패턴](/oss/python/langgraph/interrupts#common-patterns): 작업 승인/거부, 사용자 입력 요청, tool 호출 검토, 사람 입력 검증과 같은 패턴을 구현하는 방법을 알아보세요.

---

<Callout icon="pen-to-square" iconType="regular">
    [Edit the source of this page on GitHub.](https://github.com/langchain-ai/docs/edit/main/src/langsmith/add-human-in-the-loop.mdx)
</Callout>
<Tip icon="terminal" iconType="regular">
    [Connect these docs programmatically](/use-these-docs) to Claude, VSCode, and more via MCP for    real-time answers.
</Tip>
